[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "このサイトの目的\n\n数学と情報と物理の知識データベース\n数学と情報と物理の3つの分野を雑多にカバーすることが、このサイトの目的です。 分かりにくい部分をできるだけわかりやすく説明していきたいと思います。\nプログラミングを学問を学ぶ基礎として取り入れており、プログラム言語のJuliaを用いて説明しています。\n\n\nウェブページの筆者について\n\n経歴\n高等専門学校　→　筑波大学情報学群　→　筑波大学大学院情報系"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Home",
    "section": "",
    "text": "※制作中ページ"
  },
  {
    "objectID": "page-julia-howtoinstall.html",
    "href": "page-julia-howtoinstall.html",
    "title": "Julia入門「アルゴリズムと数値計算を極める！」",
    "section": "",
    "text": "Juliaを使ってみよう\n\nJuliaとは？\n世の中には多くのプログラミング言語があります。 そして、それぞれのプログラム言語には適した使い方があります。\nCやC++ならOSプログラム、FortranやMatlabなら数値計算、Pythonは汎用、JavaはWebアプリ、MathematicaやMaximaなら数学の計算、Hadoopなら分散処理……などです。\n特にJuliaはPythonの代替言語として、機械学習や数値計算領域で使用例が増加してきています。\n僕も数値計算の為にJuliaを勉強しました。\nしかし、Juliaが応用できる分野は、Pythonのそれとは違います。\nなぜなら、Juliaの設計思考は、貪欲に汎用性を求め、あらゆる要求を一手に満たすことだからです。\n\n\n[引用]Juliaの考え\n\n\n簡単に言うと、我々は欲張りなのです。\n我々はMatlabのパワフルなユーザーです。中にはLispのハッカーもいます。PythonistaやRubyist、Perlのハッカーもいます。私たちの中には、まだひげを生やせない人もいますし、顔にひげが生える前からMathematicaを使っていた人もいます。私たちは、正気の範囲を超えるほど多くのRのプロットを生成してきました。Cは私たちにとって、無人島でのプログラミング言語です。\nこれらの言語を全て愛しています。それぞれが素晴らしくパワフルです。私たちが行う仕事、科学的な計算、機械学習、データマイニング、大規模な線形代数、分散および並列計算のために、それぞれが仕事の一部には完璧であり、他の部分にはひどいものです。それぞれはトレードオフです。\n私たちは欲張りです：もっと欲しいのです。\n私たちは、オープンソースの言語を望みます。Cの速度とRubyのダイナミズムを持つ言語が欲しいのです。Lispのような真のマクロを備えたホモアイコニックな言語が欲しいのですが、Matlabのような明白で馴染みのある数学表記も欲しいのです。一般的なプログラミングに使用できるPythonのようなもの、統計処理にはRのように簡単なもの、文字列処理にはPerlのように自然なもの、線形代数にはMatlabのように強力なもの、プログラムをつなぐのにはシェルのように優れたものが欲しいのです。学習が簡単でありながら、真剣なハッカーたちも満足できるものです。インタラクティブであり、コンパイルされたものが欲しいのです。\n（Cと同じくらい速いことを言いましたか？）\n要求が多い中で、私たちはHadoopの分散パワーを提供するものを望みます。ただし、JavaとXMLの冗長な記述なしで。バグを見つけるために数百台のマシン上のギガバイトのログファイルをひとつずつ見る必要はありません。複雑なレイヤーがなくても、パワーを求めます。単一のCPUのレジスタを使って、タイトなマシンコードにコンパイルされるシンプルなスカラーループを書きたいのです。A*Bと書き、数千の計算を数千のマシンで行い、巨大な行列の積を一緒に計算したいのです。\n私たちは、自分の気分に合わせて型を指定することはしたくありません。しかし、ポリモーフィックな関数が必要な場合には、ジェネリックプログラミングを使用してアルゴリズムを一度だけ書き、無限のタイプの格子に適用したいのです。さまざまなメソッド定義から関数の引数に最適なメソッドを効率的に選択するために、多重ディスパッチを使用したいのです。全く異なる型間で共通の機能を提供します。これだけのパワーにもかかわらず、言語はシンプルで清潔であることを望んでいます。\nこれらすべてを求めるのは、欲深いでしょうか？\n私たちは自分たちが非常に欲張りであることを認識していますが、それでも全てを手に入れたいと思っています。約2年半前、私たちは自分たちの欲望の言語を作るために取り組み始めました。まだ完全ではありませんが、初期のリリースの時が来ました。私たちが作った言語はJuliaと呼ばれています。それは私たちの無礼な要求の90%を既に実現しており、今は他の無礼な要求によってさらに形作られる必要があります。ですので、もしもあなたも欲張りで理不尽で要求の多いプログラマーなら、ぜひ試してみてください。\n\n\nなぜJuliaを創ったか？\n\n\nJuliaの強みと弱み\n\nプログラマ人口\nプログラマの人口は、その言語の支持率です。 どれだけ多くのライブラリがあるか、どれだけ多くのドキュメントがあるかは、人口の少ない言語では太刀打ちできません。\nJuliaのプログラマ人口は0.1%に満たないです。\nGitHut 2.0\nパフォーマンス\nJuliaについて説明するとき最も重要なのは、パフォーマンスの話です。\nPythonやJavaなどの言語と比較し、Juliaは十分なチューニングをしなくとも高速動作します。\nPython+NumPy VS Julia\nJulia VS Python 3\nJulia VS C\n\n\n\nJuliaのインストール方法\n\nインストール方法（Windows）\n2023年現在のインストール方法を説明します。 ベーシックな方法だけ紹介するので、パッケージインストーラやポータブル版を使いたい人はそれぞれ調べてください。\n\nJuliaのダウンロード\nまず、ダウンロードにアクセスし、お使いのオペレーティングシステムに基づいてダウンロードしたいJuliaのバージョンをクリックします。\n例えば、「64-bit (installer)」というリンクをクリックすると、インストーラという実行ファイルがダウンロードされます。\nexeファイルを実行する\n次に、ダウンロードした.exeファイルを実行し、Juliaのインストールを進めてください。 「Add Julia To PATH」といったチェックボックスがあれば、チェックすることを推奨します。\nこのチェックをした場合、cmd（コマンドプロンプト）から直接juliaが実行できるようになります。\nJuliaの実行\nJuliaのインストールが完了したら、Juliaを起動します。 すると、REPL（read-eval-print-loop）としても知られるJuliaのコマンドラインが表示されます：\n簡単なコードを実行する\n最後に、コードの入力/実行を開始することができます。 例えば、“Hello World”を表示する簡単なコードを以下に示します：\nprintln(\"Hello World\")\nENTERを押すと、“Hello World” の結果が得られます。\n\n\n\n\nJupyterでの動作\nREPLにてusing Pkg; Pkg.add(\"IJulia\")を実行すると、jupyter-notebookで使えるようになります。"
  },
  {
    "objectID": "page-julia-lang-wiredpart.html",
    "href": "page-julia-lang-wiredpart.html",
    "title": "Julia入門「アルゴリズムと数値計算を極める！」",
    "section": "",
    "text": "Juliaの文法基礎\n\nJuliaの変なところ\nJuliaは非常に便利な言語です。 それを支えている部分ではあるのですが、他のプログラム言語と比較して、少し変な部分もあります。\nいくつかご紹介します。\n\n\nUnicodeのサポート（ひらがなも使える）\nJuliaでは大抵のUnicode文字が使えます。 便利か不便かは人によると思いますが、奇妙なのは間違いないと思います。\n英語を使うのに慣れていない人（超初心者や小学生など）にプログラミングを説明するのに向いてるかも？\n例えば、ひらがなや漢字を使って変数を定義する以下のようなプログラムも動いてしまいます。\n\n# おまじない（関数に別名を付ける）\n表示して = println\n足す,引く,掛ける,割る = +,-,*,/\n\n# やってみる（実際に動くコードの例）\nこれは２かな = 足す(1, 1)\n表示して( これは２かな )\n言いたいこと = \"ハローワールド!\"\n表示して( 言いたいこと )\n\n2\nハローワールド!\n\n\nα, βなども含め、他のUnicode文字も使えます。\nそのため、表現力の面ではJuliaは相当強いです。\n\n\n柔軟な型システム\nJuliaは強力な型システムを持っていますが、静的な型宣言が必須ではありません。 関数や変数に明示的な型注釈を付けることもできますが、Juliaは型推論によって自動的に型を推測することもできます。\nこれにより、動的なタイピングと静的なタイピングのメリットを組み合わせた柔軟なプログラミングが可能になります。\n※Integer型の行列にFloat型の値を入れたり演算をすることはできません。pythonより少しだけ型にうるさい言語だと思っておきましょう。\n\nx::Integer = 1; println(x)\ny::Float64 = 1; println(y)\nz = 1\n\n1\n1.0\n\n\n1\n\n\n\n\n配列のインデックス\nJuliaの配列のインデックスは、一般的なプログラミング言語とは異なり、1から始まります。 多くの言語では0から始まるインデックスが一般的ですが、Juliaでは数学的な表記に近い1から始まるインデックスが採用されています。\n同じような言語として、Fortranがあります。 JuliaはFortran技術者にとっては良い言語かもしれません。\nこれは好みの問題ですが、数学的に自然なプログガムが書けるので個人的には気に入ってます。\n\na = [1, 2, 3, 4]\na[1]\n\n1\n\n\n\n\nブロードキャスト\nJuliaは、要素ごとの演算をベクトル化して高速化することが得意です。 これにより、ループを使わずにコードを記述し、高速な計算を行うことができます。 また、Juliaのブロードキャスト機能を使用すると、異なるサイズや形状の配列の間で要素ごとの演算を行うことができます。\nループを平坦化する（ネストを減らす）ことは、可読性向上の為に重要な意味があります。 余計なループは排除しましょう。\n\n# 1:10までの数字の逆数を計算する。\n1.0 ./ (1:10)\n\n10-element Vector{Float64}:\n 1.0\n 0.5\n 0.3333333333333333\n 0.25\n 0.2\n 0.16666666666666666\n 0.14285714285714285\n 0.125\n 0.1111111111111111\n 0.1\n\n\n\n# 1:10までの数字の3乗を計算する。\nf(x) = x^3\nf.(1:10)\n\n10-element Vector{Int64}:\n    1\n    8\n   27\n   64\n  125\n  216\n  343\n  512\n  729\n 1000\n\n\n\n\n多重ディスパッチ\nJuliaの型システムには多重ディスパッチと呼ばれる機能があります。 これにより、関数が引数の型に基づいて自動的に異なる実装を選択することができます。\nこの機能は、同じ操作を異なる型に対して一貫して適用する場合に特に有用です。\n\n# 同じ数字を並べて大きな数字を作る\nfunction concat(x::Int, n::Int)\n    if n == 0\n        return 0\n    end\n    return x + 10 * concat(x, n-1)\nend\n\n# 同じ文字を並べて大きな文字列を作る\nfunction concat(x::Union{AbstractChar, AbstractString}, n::Int)\n    if n == 0\n        return \"\"\n    end\n    return x*concat(x, n-1)\nend\n\ndisplay.(\n    [concat(1, 5), concat(\"a\", 4)]\n)\n;\n\n11111\n\n\n\"aaaa\""
  },
  {
    "objectID": "page-julia-lang-basic-1.html",
    "href": "page-julia-lang-basic-1.html",
    "title": "Julia入門「アルゴリズムと数値計算を極める！」",
    "section": "",
    "text": "Juliaの文法基礎\nプログラミングの構成要素となる型や値、変数などの扱いについてざっくりと列挙しています。 コピーしてREPLで実行してみてください。\n\n値と型\n\n整数(Int64)\n\n8\n\n8\n\n\n\n\n浮動小数点(Float64)\n\n2.0\n\n2.0\n\n\n\n\n文字(Char)\n\n'a'\n\n'a': ASCII/Unicode U+0061 (category Ll: Letter, lowercase)\n\n\n\n\n文字列(String)\n\n\"abc\"\n\n\"abc\"\n\n\n\n\nベクトル(Vector{TYPE})\n\n[1, 2, 5] # [1.0, 2, 5]とすればVector{Float64}型になる\n\n3-element Vector{Int64}:\n 1\n 2\n 5\n\n\n\n\n行列(Matrix{TYPE})\n\n[1 2 3; 2 6 5; 9 3 1; 1 5 1] # どれかの要素をFloat64型にすればMatrix{Float64}型になります。\n\n4×3 Matrix{Int64}:\n 1  2  3\n 2  6  5\n 9  3  1\n 1  5  1\n\n\n\n[1 2 3]\n\n1×3 Matrix{Int64}:\n 1  2  3\n\n\n\n[1; 2; 3]\n\n3-element Vector{Int64}:\n 1\n 2\n 3\n\n\n\n\nタプルNTuple{n, TYPE}\n\n(1, 2, 4, 6)\n\n(1, 2, 4, 6)\n\n\n\n\n辞書型Dict{TYPEA, TYPEB}\n\nDict(\n    \"var1\" =&gt; \"hello\",\n    \"var2\" =&gt; rand(3, 3)\n)\n\nDict{String, Any} with 2 entries:\n  \"var1\" =&gt; \"hello\"\n  \"var2\" =&gt; [0.689516 0.908698 0.967067; 0.08391 0.736939 0.972553; 0.562372 0.…\n\n\n\n\n\n代入\n\n値1の変数aへの代入\n\na = 1\n\n1\n\n\n\n\n値(\"\", \"2\", 3)を変数(b, c, d)に同時に代入\n\nb, c, d = \"\", \"2\", 3\n\n(\"\", \"2\", 3)\n\n\n\n\n値のスワップ(交換)\n\nx, y = 1, 100\nprintln(\"before: $x $y\")\nx, y = y, x\nprintln(\"after : $x $y\")\n\nbefore: 1 100\nafter : 100 1\n\n\n\n\n\n出力\n\n値の標準出力println\n\ns = \"aaaa\"\nprintln(s)\nprintln(s, \"b\", s) # , で区切ると繋げて表示される\nv = [1, 2, 4]\nprintln(v)\nV = [1 1 2; 5 4 5]\nprintln(V)\n\naaaa\naaaabaaaa\n[1, 2, 4]\n[1 1 2; 5 4 5]\n\n\n\n\n値を整形して表示display\n\ns = \"aaaa\"\ndisplay(s)\nv = [1, 2, 4]\ndisplay(v)\nV = [1 1 2; 5 4 5]\ndisplay(V)\n\n\"aaaa\"\n\n\n3-element Vector{Int64}:\n 1\n 2\n 4\n\n\n2×3 Matrix{Int64}:\n 1  1  2\n 5  4  5\n\n\n\n\n\n四則演算+α\n\n足し算+\n\n1 + 2 + 4\n\n7\n\n\n\n\n引き算-\n\n132 - 451\n\n-319\n\n\n\n\n掛け算*\n\n111 * 222\n\n24642\n\n\n\n\n割り算/\n\n10 / 3.0 # 3.0を3としても動作する\n\n3.3333333333333335\n\n\n\n\n商÷と剰余%\n\n10 ÷ 3, 10 % 3\n\n(3, 1)\n\n\n\n\n累乗^\n\n5 ^ 3\n\n125\n\n\n\n\n平方根sqrt, √\n\nsqrt(13)\n\n3.605551275463989\n\n\n\n\n\n論理演算子\n\nAND演算&, and\n\ntrue & false\n\nfalse\n\n\n\n\nOR演算|\n\ntrue | false\n\ntrue\n\n\n\n\nXOR⊻\n\ntrue ⊻ false\n\ntrue\n\n\n\n\nNOT!\n\n! true\n\nfalse\n\n\n\n\n\n比較演算子\n\n同値==\n\n1 == 1.0 # 型が違う\n\ntrue\n\n\n\n\n～より大きい&gt;=\n\n9.1 &gt;= 0.0\n\ntrue\n\n\n\n\n～より小さい&gt;=\n\n1 &lt;= -1\n\nfalse\n\n\n\n\n～と異なる!=\n\n10 != 10\n\nfalse\n\n\n\n\n\n文字列の演算\n\n結合\n\nx, y = 3, 5\ns1, s2 = \"times\", \"equalsto\"\ns1 = \"$(x) $(s1) $(y) $(s2) $(x*y) !\" \n\n\"3 times 5 equalsto 15 !\"\n\n\n\n\n\n関数の定義\n\n関数の作り方1function ~ end\n\nfunction f1(x, y)\n  println(\"calc: $x ^ $y\")\n  return x ^ y\nend\nf1(5, 3)\n\ncalc: 5 ^ 3\n\n\n125\n\n\n\n\n関数の作り方2f(...)=...\n\nf2(x, y) = x ^ y\nf2(5, 3)\n\n125\n\n\n\n\n関数の作り方3f = (...) -&gt; (...)\n\nf3 = (x, y) -&gt; x ^ y\nf3(5, 3)\n\n125\n\n\n\n\nキーワード変数function f(...;...)\n※文字列を生成した後に表示しているため、表示の順序に注意\n\nfunction f4(x, y; c=1)\n  println(\"calc: $c * $x ^ $y\")\n  return c * x ^ y\nend\nprintln(\"$(f4(5, 3)) $(f4(5, 3, c=2))\")\n\ncalc: 1 * 5 ^ 3\ncalc: 2 * 5 ^ 3\n125 250\n\n\n\n\n\nブロードキャスト\n\nベクトルと定数の間の四則演算\n他の計算も大抵同じことができます\n\nv, a = [1.0, 2, 3], 3\n\nv1   = v .+ a # それぞれの要素に足し算\nv2   = v .- a # 　　　　　　　　引き算\nv3   = v .* a # 　　　　　　　　掛け算\nv4   = v ./ a # 　　　　　　　　割り算\n\nprintln(v1, v2, v3, v4)\n\n[4.0, 5.0, 6.0][-2.0, -1.0, 0.0][3.0, 6.0, 9.0][0.3333333333333333, 0.6666666666666666, 1.0]\n\n\n\n\n関数に対しても……\n\n# f(x) = x^2\nfunction f(x)\n  return x ^ 2\nend\nprintln(f.([1, 2, 3, 5]))\n\n[1, 4, 9, 25]\n\n\n\n\n2変数関数に対しても……\n\nf(x, y) = x^y\n\nl1 = f.([1, 2, 3, 4], 2)\nl2 = f.(2, [1, 2, 3, 4])\n\ndisplay.([l1', l2']);\n\n1×4 adjoint(::Vector{Int64}) with eltype Int64:\n 1  4  9  16\n\n\n1×4 adjoint(::Vector{Int64}) with eltype Int64:\n 2  4  8  16\n\n\n\n\n多次元データのブロードキャスト\n\nf(x) = 3*x + 1\nf.([1 2 3; 4 5 6])\n\n2×3 Matrix{Int64}:\n  4   7  10\n 13  16  19"
  },
  {
    "objectID": "page-julia-lang-basic-2.html",
    "href": "page-julia-lang-basic-2.html",
    "title": "Julia入門「アルゴリズムと数値計算を極める！」",
    "section": "",
    "text": "Juliaの文法基礎\n\nif文\nif文は真理値(以下の(x == 0):: Bool)がtrueのとき内部のコードを実行します。\nif 真理値\n  コード\nend\n実際の例は以下の通りです：\n\n# x が 0 と等しい場合にそれを出力します。\nx = 0\nif x == 0 # x == 0 は比較演算子の返り値＝真理値型\n  println(\"$(x)と0は同じ値です\")\nend\n\n0と0は同じ値です\n\n\nif ~ else文は真理値がtrueのとき内部のコード1を実行し、それ以外の場合にelseの内部のコード2を実行します。\nif 真理値\n  コード1\nelse\n  コード2\nend\n実際の例は以下の通りです：\n\nx = 0\nif x == 0\n  println(\"$(x)と0は同じ値です\")\nelse\n  println(\"$(x)と0は異なります\")\nend\n\n0と0は同じ値です\n\n\n\nx = 1\nif x == 0\n  println(\"$(x)と0は同じ値です\")\nelse\n  println(\"$(x)と0は異なります\")\nend\n\n1と0は異なります\n\n\nif ~ elseif ~ else文は真理値1がtrueのときコード1を実行し、真理値k-1までがfalseのとき、真理値kがtrueならばコードkを実行します。 また、真理値nまで実行してコードが全部実行できなかったとき、elseの内部のコードn+1を実行します。\nまあ要するに、上から順番にどの条件が真になるかを確かめて、実行していく感じです。\nif     真理値1\n  コード1\nelseif 真理値2\n  コード2\n…\nelseif 真理値k-1\n  コードk-1\nelseif 真理値k\n  コードk\n…\nelseif 真理値n\n  コードn\nelse \n  コードn+1\nend\n実際の例は以下の通りです：\n\nx = -3\nif x == 0\n  println(\"$(x)と0は同じ値です\")\nelseif -3 &lt; x &lt;= 3\n  println(\"$(x)は、集合(-3,+3]に含まれます\")\nelse\n  println(\"$(x)は集合(-∞, -3]と(+3, ∞)の和集合に含まれます\")\nend\n\n-3は集合(-∞, -3]と(+3, ∞)の和集合に含まれます\n\n\n\n\nfor文\nfor文は、n回連続で『似た』処理を実行したいときに使います。 何かの順番を持つオブジェクト（イテレーティブオブジェクト）に応じて、順次、内部のコード(i)を実行します。\nfor i = イテレーティブオブジェクト\n  コード(i)\nend\n\n# iとi^2をnまで足し合わせるプログラム\nn = 0\nk = 0\nfor i = 1:10 # UnitRange型オブジェクト\n  k = k + i\n  n = n + i^2\nend\nprintln(\"$n, $k\")\n\n385, 55\n\n\nベクトルでもできます。勿論、タプルでも……。\n\nn = 0\nk = 0\nfor i = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n  k = k + i\n  n = n + i^2\nend\nprintln(\"$n, $k\")\n\n385, 55\n\n\nベクトルとか行列を作りたいとき、for文を使った内包表記という書き方ができます。\n\n# 1から10まで、2乗の和を計算する\n[i^2 for i = 1:10]\n\n10-element Vector{Int64}:\n   1\n   4\n   9\n  16\n  25\n  36\n  49\n  64\n  81\n 100\n\n\n\n\nwhile文\nwhile文は真理値がtrueの間に限り内部のコードが実行されるループです。\nwhile 真理値\n  コード\nend\n\n# n^2の和を合計が1000を越えるまで足していく。\nn = 0\nN = 0\nwhile N &lt; 1000\n  N = N + n^2\n  n = n + 1\nend\nprintln(\"0 から $(n-1) までの値の2乗の和は $N となる\")\n\n0 から 14 までの値の2乗の和は 1015 となる\n\n\n\n\ncontinue文\ncontinueはループfor, whileの内部のコードをその回の終了までスキップします。\n\n# １～１０までの間で偶数だけを出力する\nfor i = 1:10\n  if i % 2 == 1 \n    continue\n  end\n  println(\"$i は偶数です\")\nend\n\n2 は偶数です\n4 は偶数です\n6 は偶数です\n8 は偶数です\n10 は偶数です\n\n\n\n\nbreak文\nbreakはループfor, whileをその場で抜けます。\n\nfor i = 1:10\n  if i == 7\n    break\n  end\n  println(\"$i は 7 未満です\")\nend\n\n1 は 7 未満です\n2 は 7 未満です\n3 は 7 未満です\n4 は 7 未満です\n5 は 7 未満です\n6 は 7 未満です"
  },
  {
    "objectID": "page-julia-lang-basic-3.html",
    "href": "page-julia-lang-basic-3.html",
    "title": "Julia入門「アルゴリズムと数値計算を極める！」",
    "section": "",
    "text": "Juliaの文法基礎\n\n行列の使い方\n\n行列（自分で値を決めて）\n値を自分で決めて行列を作る場合、以下のようにしてください。\n\nA = [\n  1 2 4;\n  6 7 3;\n  2 2 9;\n  0 5 0.0\n]\n\n4×3 Matrix{Float64}:\n 1.0  2.0  4.0\n 6.0  7.0  3.0\n 2.0  2.0  9.0\n 0.0  5.0  0.0\n\n\n\n\n初期化された行列\n0で初期化された行列を作るには、以下のようにしてください。\n\nA = zeros(2, 2)\n\n2×2 Matrix{Float64}:\n 0.0  0.0\n 0.0  0.0\n\n\n\n\n任意行列\n中身が何でも良い適当な行列を作りたい場合は、以下のようにしてください。\n\nA = rand(3, 5)\n\n3×5 Matrix{Float64}:\n 0.413982  0.356082  0.210254  0.775376   0.357204\n 0.832919  0.263687  0.380399  0.0694848  0.204693\n 0.591149  0.144733  0.677469  0.884085   0.821686\n\n\n\n\n単位行列\n単位行列を作りたい場合は、以下のようにしてください。 型を指定しない場合、Boolの行列になってしまいます。\n\nusing LinearAlgebra\nE = Matrix{Float64}(I, 3, 3)\n\n3×3 Matrix{Float64}:\n 1.0  0.0  0.0\n 0.0  1.0  0.0\n 0.0  0.0  1.0\n\n\n\n\n行列の表示\nprintlnよりもdisplayで表示した方が見やすいので、小さい行列はそうやって表示しましょう。\n\nA = rand(3, 3)\ndisplay(A)\n\n3×3 Matrix{Float64}:\n 0.443636  0.625126  0.148404\n 0.117046  0.166121  0.891471\n 0.470388  0.960986  0.605032\n\n\n\n\n行列の型\n行列に限らず……ですが、typeof関数でどういう型になっているかを調べることができます。\n\nA = rand(ComplexF64, 10, 10)\ntypeof(A)\n\n\nMatrix{ComplexF64} (alias for Array{Complex{Float64}, 2})\n\n\n\n\n\n\n行列の参照\n説明のため、\\(9 \\times 9\\) サイズの行列を作りました。 この行列は九九の表を表してます。 効率的に覚えるため(？)、下半分を削りました。\n※なんでこうなるかは取り敢えず無視してください。\n\na = [1, 2, 3, 4, 5, 6, 7, 8, 9]\nA = (M -&gt; M - tril(M, -1))(a * a')\n\n9×9 Matrix{Int64}:\n 1  2  3   4   5   6   7   8   9\n 0  4  6   8  10  12  14  16  18\n 0  0  9  12  15  18  21  24  27\n 0  0  0  16  20  24  28  32  36\n 0  0  0   0  25  30  35  40  45\n 0  0  0   0   0  36  42  48  54\n 0  0  0   0   0   0  49  56  63\n 0  0  0   0   0   0   0  64  72\n 0  0  0   0   0   0   0   0  81\n\n\n\n特定の行（列）のベクトルとしての参照\n特定の行だけ取り出し、ベクトルとして参照したいときは、以下のようにしてください。\n\nx = A[1, :]\n\n9-element Vector{Int64}:\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n\n\n特定の列だけ取り出し、ベクトルとして参照したいときは、以下のようにしてください。\n\nx = A[:, 2]\n\n9-element Vector{Int64}:\n 2\n 4\n 0\n 0\n 0\n 0\n 0\n 0\n 0\n\n\n\n\n特定の行（列）の参照\n特定の行だけ取り出したいときは、以下のようにしてください。（行列として参照されます）\n\nx = A[1:1, :]\n\n1×9 Matrix{Int64}:\n 1  2  3  4  5  6  7  8  9\n\n\n特定の列だけ取り出したいときは、以下のようにしてください。\n\nx = A[:, 2:2]\n\n9×1 Matrix{Int64}:\n 2\n 4\n 0\n 0\n 0\n 0\n 0\n 0\n 0\n\n\n\n\n複数行（列）をまとめて取り出したい\n特定の連続する数行だけ取り出したいときは、以下のようにしてください。\n\nx = A[5:8, :]\n\n4×9 Matrix{Int64}:\n 0  0  0  0  25  30  35  40  45\n 0  0  0  0   0  36  42  48  54\n 0  0  0  0   0   0  49  56  63\n 0  0  0  0   0   0   0  64  72\n\n\n特定の連続する数列だけ取り出したいときは、以下のようにしてください。\n\nx = A[:, 2:5]\n\n9×4 Matrix{Int64}:\n 2  3   4   5\n 4  6   8  10\n 0  9  12  15\n 0  0  16  20\n 0  0   0  25\n 0  0   0   0\n 0  0   0   0\n 0  0   0   0\n 0  0   0   0\n\n\n\n\n小行列の参照\n\nx = A[5:8, 2:5]\n\n4×4 Matrix{Int64}:\n 0  0  0  25\n 0  0  0   0\n 0  0  0   0\n 0  0  0   0\n\n\n\n\n行と列を複数個指定して参照\n\nx = A[[1, 5, 6], [1, 3, 4, 9]]\n\n3×4 Matrix{Int64}:\n 1  3  4   9\n 0  0  0  45\n 0  0  0  54\n\n\n\n\n\n行列への代入\n参照した行列に代入することができます。 .=でなくて=でも代入できますが、メモリを気にするときは.=を使ってください。\n例えば、以下のようにしてください。\n\nA[[1, 5, 6], [1, 3, 4, 9]] .= zeros(3, 4)\nA\n\n9×9 Matrix{Int64}:\n 0  2  0   0   5   6   7   8   0\n 0  4  6   8  10  12  14  16  18\n 0  0  9  12  15  18  21  24  27\n 0  0  0  16  20  24  28  32  36\n 0  0  0   0  25  30  35  40   0\n 0  0  0   0   0  36  42  48   0\n 0  0  0   0   0   0  49  56  63\n 0  0  0   0   0   0   0  64  72\n 0  0  0   0   0   0   0   0  81"
  },
  {
    "objectID": "page-julia-lang-macro.html",
    "href": "page-julia-lang-macro.html",
    "title": "Julia入門「アルゴリズムと数値計算を極める！」",
    "section": "",
    "text": "Juliaのマクロ\n\nマクロとは\nマクロとは、コンパイル時に実行されるコード生成機能であり、柔軟なコード記述と静的なコード変換を可能にします。\nマクロはソースコードのAST（抽象構文木）に対して操作を行い、新しいコードを生成します。\nJuliaのマクロは、@を使って呼び出せます。\n呼び出しは、マクロに渡される引数を含んだ式として解釈され、マクロ内の処理が実行されます。その後、マクロは評価結果として新しい式を返します。この返された式は、通常のコードとして実行されます。\nつまり、マクロはプログラムを生成するプログラムと言えます。\nマクロは、繰り返しパターンやコードの自動生成、ドメイン固有言語（DSL）の構築など、柔軟なコード記述を可能とします。 マクロは、静的なコード解析やコード変換を行うための強力なツールです。\n\n\nマクロの記述方法\nマクロは以下のコードで定義されます。\n\nmacro マクロ名(引数1, 引数2, ...)\n  処理内容\n  return 式\nend\n\nマクロの使用方法は以下のように@を使えばよいです。\n\n@マクロ名 引数1 引数2 ...\n\n\n\nクオート（引用）\nクオートは以下のどちらかの方法で行われます。 なお、expr1, expr2は、そのものがプログラムだと考えてください。\n:(expr)を使う方法\n\nexpr1 = :(x + 1)\n\n:(x + 1)\n\n\nquote(), quote ~ endを使う方法\n\nexpr2 = quote \n    x + 1\nend\n\n\nquote\n    #= In[3]:2 =#\n    x + 1\nend\n\n\n\n\n\nアンクオート（引用解除）\nquote, :()でクオートした式（プログラム）の内部でアンクオート$という動作を行わせることができます。 アンクオートした部分の式(以下の$(y+1))は、マクロの展開時に評価されます。\n\ny = 3 # マクロ展開時\nexpr = quote \n    z = $(y + 1) + y\nend\ndisplay(expr)\n\n\nquote\n    #= In[4]:3 =#\n    z = 4 + y\nend\n\n\n\n\n\n評価\nクオートした式を実行して評価するには、evalを使ってください。 例えば、上で作成した \\(z \\gets y+1\\) を表現する式exprは、以下のように評価できます。\n\ny = 1\neval(expr)\ndisplay(z)\n\n5\n\n\n\n\nASTの生成\nAST(抽象構文木)を作成するには、以下のようにdumpが使えます。\n\nexpr = :(x + y / z)\ndump(expr)\n\nExpr\n  head: Symbol call\n  args: Array{Any}((3,))\n    1: Symbol +\n    2: Symbol x\n    3: Expr\n      head: Symbol call\n      args: Array{Any}((3,))\n        1: Symbol /\n        2: Symbol y\n        3: Symbol z\n\n\n\n\nエスケープ\nマクロの展開時に式が評価されることから保護するため、escが使えます。\nこれを使わないと、マクロを展開するときに勝手に式が評価されてしまいます。\nなので、以下のように、式をエスケープしてコードに埋め込んでからアンクオートすることでプログラムの順序が守られます。\n\nmacro mymacro(expr)\n    quote \n        println(\"-\"^10)\n        $(esc(expr))\n        println(\"-\"^10)\n    end\nend\n\nname = \"YAMADA\"\n@mymacro println(\"Hello \", name)\n\n----------\nHello YAMADA\n----------\n\n\n\n\nマクロの例\n時間計測のマクロは以下の通りです。 実のところ、@timeとか@timedなどのマクロが既にあるので、あまり意味はないのですが……。\n\nmacro time_measure(expr)\n    quote\n        local start_time = time()\n        local result = $(esc(expr))\n        local end_time = time()\n        println(\"Execution time: \", end_time - start_time, \" seconds\")\n        result\n    end\nend\n\nA = @time_measure begin\n    sleep(0.05)\nend\n;\n\nExecution time: 0.05200004577636719 seconds"
  },
  {
    "objectID": "page-julia-packages-Base.html",
    "href": "page-julia-packages-Base.html",
    "title": "Julia入門「アルゴリズムと数値計算を極める！」",
    "section": "",
    "text": "Juliaのパッケージ\nインストールしなくても最初から用意されている機能のパッケージです。\n\nBaseとは？\nJuliaでは、built-inの関数が大抵はこの名前空間にあります。\n例えば、rand関数はBase.rand関数と同じ関数を表しています。\nJuliaでは多重ディスパッチが許されているため、定義の違うBase.randを定義したりすることもできます。"
  },
  {
    "objectID": "page-julia-packages-Pkg.html",
    "href": "page-julia-packages-Pkg.html",
    "title": "Julia入門「アルゴリズムと数値計算を極める！」",
    "section": "",
    "text": "Juliaのパッケージ\nインストールしなくても最初から用意されているパッケージです。 主にPEPLで、使いたいタイミングでusing Pkgと指定して読み込んでください。\n\nPkgとは？\nJuliaのパッケージインストーラです。\n主に、パッケージのインストールを行う際に使うものです。 プログラム中で使うことはあまり想定されてないため、JuliaのREPL上で実行してください。\n\nパッケージのインストール\nインストール方法は２つあります（やり方が違うだけで両方同じです）。\n\nPkgパッケージの関数addを使ってインストールする。\nusing Pkg; Pkg.add(\"パッケージ名\")というコマンドによって、インストールできます。\n]add パッケージ名でパッケージインストーラを起動する。\nREPL上でjulia&gt; ]として、(***) pkg&gt;と出た時点で、add パッケージ名としてください。\n\n\n\nプロジェクトの操作\n\nパッケージの作成\n以下のコマンドを実行して、新しいパッケージを作成します。 これにより、パッケージのskeltonが生成されます。\n] generate パッケージのパス\nパッケージのアクティベート\nJuliaのREPL（対話型環境）で以下のコマンドを実行します。このコマンドは、作成したプロジェクトのディレクトリをアクティブな環境として設定します。\n] activate パッケージのパス\nJuliaで開発を行う際には、Revise.jlというパッケージを使うと便利です。 Reviseは、外部から与えられる変更を監視してREPL上で扱われるパッケージの内容が自動で更新されるので便利です。"
  },
  {
    "objectID": "page-julia-packages-Revise.html",
    "href": "page-julia-packages-Revise.html",
    "title": "Julia入門「アルゴリズムと数値計算を極める！」",
    "section": "",
    "text": "Juliaのパッケージ\nインストールするには、JuliaのREPLでusing Pkg; Pkg.add(\"Revise\")を実行してください。\n\nReviseとは？\nJuliaのReviseパッケージは、Juliaのソースコードを変更した際に、自動的に変更を検知して再評価するためのツールです。\nReviseパッケージを使用すると、開発者はREPL環境でソースコードの変更をリアルタイムに反映させることができます。\n参考\n\n\nReviseの使い方\n以下のような使用感になります。 以下は、vscodeで書き換えてREPLで評価してみた実行結果です。\n\npkg  &gt; activate プロジェクト\njulia&gt; using Revise        # `using プロジェクト`の前に実行してください\njulia&gt; using プロジェクト\njulia&gt; \njulia&gt; プロジェクト.f(2)\nUndefVarError: f not defined\n...\njulia&gt; # 外部ファイルで関数f(x)=x^2を追加\njulia&gt; プロジェクト.f(2)\n4\njulia&gt; # 外部ファイルで関数f(x)=x^3に変更\njulia&gt; プロジェクト.f(2)\n8\njulia&gt;"
  },
  {
    "objectID": "page-julia-packages-Random.html",
    "href": "page-julia-packages-Random.html",
    "title": "Julia入門「アルゴリズムと数値計算を極める！」",
    "section": "",
    "text": "Juliaのパッケージ\nインストールするには、JuliaのREPLでusing Pkg; Pkg.add(\"Random\")を実行してください。\n\nRandomとは？\n乱数生成はありとあらゆる場所で使われています。 特に、確率的に起こる事象を扱う場合に使われます。\n参考文献\n\n\nRandomの使い方\nRandomの使い方で大切なのは、randとRandom.seed!くらいです。 他は余り使わないと思います。\n\n0~1間の乱数\nなお、rand関数はusing Randomを宣言する前からBaseに含まれています。\n\n乱数生成\n以下のように、乱数を生成できます。\n\nrand()\n\n0.9259514657867665\n\n\n\n\n５次元の配列（ベクトル）\n以下のように、ベクトルを作ることもできます。\n\nrand(5)\n\n5-element Vector{Float64}:\n 0.8734592245400642\n 0.37552520280371326\n 0.868689742682809\n 0.7372339218074444\n 0.6306159145806376\n\n\n\n\n\\(2 \\times 4\\) の行列\n以下のように、行列も作れます。\n\nrand(2,4)\n\n2×4 Matrix{Float64}:\n 0.398236  0.832817  0.883952  0.398993\n 0.535115  0.770394  0.727902  0.848999\n\n\n\n\n\\(3 \\times 4\\) の複素行列\n以下のように、型に沿った行列を作るみたいなこともできます。\n\nrand(ComplexF64, 3, 4)\n\n3×4 Matrix{ComplexF64}:\n 0.814702+0.357975im  0.732157+0.383766im  …  0.134832+0.116715im\n 0.812023+0.55844im   0.158352+0.997993im     0.728772+0.629283im\n 0.113732+0.277736im  0.829216+0.900735im      0.31183+0.0957434im\n\n\n\n\nランダム選択\n以下のように、さいころの出目みたいなものを扱うこともできます。\n\nchoise = [\"A\", \"B\", \"C\", 1, 2, 3]\nn      = 10\nrand(choise, n)\n\n10-element Vector{Any}:\n 3\n  \"C\"\n 3\n 3\n  \"A\"\n 1\n 1\n 1\n  \"B\"\n  \"B\"\n\n\n\n\n\n乱数のシードの設定\n乱数は「シード」と言われるパラメータを用いて生成しています。 シードは現在時刻などを参照して決められます。\nこのシードの値を用いて、非常に周期の長い（同じパターンが起こりにくい）疑似乱数を生成しています。\nプログラムに乱数を使っている場合、シードを設定していないと「再現性」の面で問題が起きる場合があり、シードをプログラム内で設定してやることが求められる事があります。数値計算のプログラムなどではシードを設定しておくことをお勧めします。\n\nusing Random\nRandom.seed!(0)\n;\n\n\n\nランダムな置換\n\nx = [1,2,3,4,5]\nx[randperm(length(x))]\n\n5-element Vector{Int64}:\n 4\n 5\n 3\n 2\n 1\n\n\n\n\n置換によるシャッフル\n\nx = [\"a\", \"b\", \"c\", \"d\"]\nshuffle(x)\n\n4-element Vector{String}:\n \"a\"\n \"d\"\n \"b\"\n \"c\""
  },
  {
    "objectID": "page-julia-packages-Plots.html",
    "href": "page-julia-packages-Plots.html",
    "title": "Julia入門「アルゴリズムと数値計算を極める！」",
    "section": "",
    "text": "Juliaのパッケージ\nインストールするには、JuliaのREPLでusing Pkg; Pkg.add(\"Plots\")を実行してください。\n実行時には、以下のように読み込んでください。\n\nusing Plots\n\n\nPlotsとは？\n数字だけ見てもデータの意味が分かりにくいことが多いので、グラフの利用は数値計算の分野では重要です。\n例えば、乱数を生成するrand関数で作った３次元の点群がどのようになっているかを数字とグラフでそれぞれ表示してみます。\n\nusing Random\nRandom.seed!(0)\n\nn = 100\nx, y, z = rand(n), rand(n), rand(n)\ndisplay.([x', y', x'])\n;\n\n1×100 adjoint(::Vector{Float64}) with eltype Float64:\n 0.455238  0.547642  0.773354  0.940585  …  0.351491  0.193291  0.116989\n\n\n1×100 adjoint(::Vector{Float64}) with eltype Float64:\n 0.655636  0.774666  0.781732  0.55538  …  0.355375  0.524008  0.279907\n\n\n1×100 adjoint(::Vector{Float64}) with eltype Float64:\n 0.455238  0.547642  0.773354  0.940585  …  0.351491  0.193291  0.116989\n\n\n\nusing Plots \nscatter(x, y, z)\n\n\n\n\n勿論、グラフの方が分かりやすいと思います。\nこのように、Plotsでは、数値を可視化する機能が複数用意されています。\n\n\n折れ線グラフplot, plot!\nplotは連続的なデータや関数の表示が得意な関数です。 基本的には、折れ線グラフの表示を行いますが、他のプロットにも使える多機能な関数です。\n\n関数のプロット\n以下のように、関数をプロットできます。\n\nplt = plot(sin)\nplot!(plt, cos) # 重ねて描く\n\ndisplay(plt)\n;\n\n\n\n\n\n\nデータのプロット\nデータの点群を与えると、直線で結んで表示してくれます。\n\nx = 0:0.1:1\ny = (n -&gt; n^2).(x)\nplt1 = plot(x, y)\n\n\n\n\n\n\n\n\n\n\n\n散布図scatter, scatter!\nscatterは散布図を作成する関数です。 散布図とは、データを散らしたグラフのことです。\n\nデータのプロット\n以下のようにして使えます。\n\n# 2dimプロット\nx = 0:0.1:1\ny = (n -&gt; n^2).(x)\nscatter(x, y)\n# 3dimプロット\nx = 0:0.1:1\ny = sin.(x)\nz = exp.(x)\nplt2 = scatter(x, y, z)\n\ndisplay.([plt1, plt2])\n;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n円グラフpie\n円グラフを作成できます。\n\nデータの表示\n\nx = [\"nitrogen\", \"oxygen\", \"argon\", \"carbon dioxide gas\"]\ny = [78.11, 20.96, 0.9343, 0.03]\nplt = pie(x, y, title=\"Volume ratio of atmospheric composition on the ground\",l = 0.5)\ndisplay(plt)\n;\n\n\n\n\n\n\n\n\n参考\n\n\n\n棒グラフbar\n棒グラフを作成できます。\n\nx = [\"A\", \"B\", \"C\", \"D\"]  # x軸のラベル\ny = [3, 5, 2, 7]  # 各バーの高さ\n\nbar(x, y)\n\n\n\n\n\n\nプロットやグラフの整形方法\nグラフにタイトルを付けたいとき、描画範囲を指定したいとき、方対数グラフを作りたいときなど、参考にしてください。\n\nそのプロット全体に適用\n\nグラフのタイトルをつける\ntitle = \"Title\"\nグラフの範囲を決める\nxlims = (1.0^-5. 1)\nylims = (0, 1)\nグラフのフォントサイズを設定する\ntickfontsize = 20\nグラフの軸を対数にする\nxaxis = :log\nyaxis = :log\nグラフを箱で囲む\nframestyle = :box\nグラフに指定の目盛りを付ける\nyticks = [0, 10, 20, 30, 40, 50]\nグラフのアスペクト比を制御する。\naspect_ratio = 1.0\n\n\n\nそのグラフに適用\n\nグラフの凡例ラベルをつける\nlabel = \"func\"\n線の色を変更する\nlinecolor = :red\nグラフの線の長さを決める\nlinewidth = 3\nマーカーを設定する。\nmarkershape = :x\n\n\n\n\nプロットテクニック\n\nテンプレート\n適当に全部詰めたテンプレートが以下の通りです。 要らないものは消してください。\n\nplt = plot(\n    title = \"ThisIsTitle\",    # タイトル\n    xlims = (-10, 10),        # xの範囲\n    ylims = (1e-1, 1e10),     # yの範囲\n    tickfontsize = 5,         # フォントサイズ\n    yaxis = :log,             # y軸方対数グラフ\n    framestyle   = :box,      # 枠で囲む\n    yticks= exp.((0:10) .^ 2) # 目盛り\n)\nplot!(plt, x -&gt; exp(x^2), \n    label = \"exp(x^2)\",       # 凡例のラベル\n    linecolor   = :red,       # 赤い線\n    linewidth   = 2,          # 線の太さ\n    markershape = :x          # マーカーの設定\n)\n\n\n\n\n\n\n対数の下駄履かせ\nイテレーションの回数などのパラメータを変化させていった時の相対誤差をプロットしたいときなど、対数プロットをしたいときがあると思います。\nコンピュータの計算では、誤差の計算結果が0になることはよくあるため、結果に下駄を履かせないとプロットが正確に行われない場合があります。\nこのとき、計算結果が0のデータは正常に表示できないため、以下のようにepsを足して下駄を履かせることで、プロットを正常に行えます。\n例えば、以下はsin関数を \\(n3\\) 次のマクローリン展開で近似した関数sin_macとの相対誤差のグラフです。\n\nfunction sin_mac(n, x)\n    q = p = x; k  = round(n/2) - 1\n    for i = 1:k\n        q = q * ((- 1) / ( (2*i) * (2*i + 1))) * x^2; p = p  + q\n    end\n  return p\nend\n\nx   = range(-10π, 10π, 1000)\ny   = sin_mac.(10, x)\ny_t = sin.(x)\n\neps = 1e-19\n\nrelerr_y = abs.((y_t - y) ./ y) .+ eps\n\nplot(x, relerr_y, yaxis=:log, ylims=(1e-10, 1e1))"
  },
  {
    "objectID": "page-julia-packages-MAT.html",
    "href": "page-julia-packages-MAT.html",
    "title": "Julia入門「アルゴリズムと数値計算を極める！」",
    "section": "",
    "text": "Juliaのパッケージ\nインストールするには、JuliaのREPLでusing Pkg; Pkg.add(\"MAT\")を実行してください。\n\nMATとは？\n数値計算や機械学習の分野では、計算途中のデータを保存することで、事故の発生を防ぎたいことがあります。 多くの場合、.csvや.txtや.jsonといったファイル形式で保存するのですが、その他の方法として、Matlabの変数を格納する.mat形式のファイルを使いたい場合があります。\nこんなとき、MATパッケージを使用すれば、変数を辞書型にまとめて保存することができ、その辞書をファイルからそのまま取り出すこともできます。\nまた、このファイルは「MATLAB v7.3 format.」によって書き込まれるため、matlabでも読み込み可能です。\n参考文献\n\n\nMATの使い方\n\n書き込み\n書き込みは以下のように、ファイルのパスを与えて辞書型のデータを関数に渡すことで行います。\n\nusing MAT\n\nd = Dict(\n    \"var1\" =&gt; \"hello\",\n    \"var2\" =&gt; rand(3, 3)\n)\n\nmatwrite(\"tmp/__matfile.mat\", d)\n\n\n\n読み込み\n読み込みは以下のように、ファイルのパスを与えて辞書型のデータを受け取ることで行います。\n\ne = matread(\"tmp/__matfile.mat\")\ne\n\nDict{String, Any} with 2 entries:\n  \"var1\" =&gt; \"hello\"\n  \"var2\" =&gt; [0.952911 0.144923 0.90566; 0.488179 0.206452 0.55324; 0.066522 0.0…"
  },
  {
    "objectID": "page-julia-packages-LinearAlgebra.html",
    "href": "page-julia-packages-LinearAlgebra.html",
    "title": "Julia入門「アルゴリズムと数値計算を極める！」",
    "section": "",
    "text": "Juliaのパッケージ\nインストールしなくても最初から用意されているパッケージです。 プログラムの最初の方でusing LinearAlgebraと指定して読み込んでください。\n\nLinearAlgebraとは？\n行列の計算などをするのに適したパッケージです。 ただし、疎行列などの問題に適したアルゴリズムではないので注意してください。\n数値計算で使われる機能は大半このパッケージに含まれます。 また、BLASやLAPACKの機能が含まれます。\nここで述べる学問領域は僕の得意分野ですが、このセクションでは簡単な使い方の例を紹介するに留めます。\n参考\n\n\n基本的な機能\n\nノルム\nベクトルのノルムを求められます。 デフォルトはユークリッド空間における通常のノルム(２ノルム)になります。\n\nusing LinearAlgebra\nnorm([1, 2, 1])\n\n2.449489742783178\n\n\n\n\n内積\nベクトル同士のドット積（内積）を求められます。\n\ndot([1,3,2], [4,1,6])\n\n19\n\n\n\n\n外積\nベクトル同士のクロス積（外積）を求められます。\n\ncross([1,3,2], [4,1,6])\n\n3-element Vector{Int64}:\n  16\n   2\n -11\n\n\n\n\n行列式\n行列の行列式を求められます。\n\nA = [\n    1 2 4;\n    5 4 1;\n    9 2 6.0\n]\ndet(A)\n\n-124.0\n\n\n\n\nトレース\n行列のトレースを求められます。\n\nA = [\n    1 2 4;\n    5 4 1;\n    9 2 6.0\n]\ntr(A)\n\n11.0\n\n\n\n\n\n固有値問題\n固有値問題を解きます。\n\nA = rand(10, 10)\n\nF = eigen(A) # Λ, V = eigen(A)でもOK\nΛ, V = F.values, F.vectors\n\nnorm(\n    A*V - V*diagm(Λ)\n)\n\n6.134920475494778e-15\n\n\n\n\n特異値分解\n特異値分解を解きます。(エコノミーサイズです)\n\nA = rand(10, 8)\n\nF = svd(A) # U, S, V = svd(A)でもOK\nU, S, V = F.U, F.S, F.V\n\nnorm(\n    A - U*diagm(S)*V'\n)\n\n3.365276716682402e-14\n\n\n\n\nLU分解\nLU分解を解きます。\n\nA = rand(10, 8)\n\nF = lu(A) # L, U = lu(A)\nL, U, p = F.L, F.U, F.p\n\nnorm(\n   A[p,:] - L*U\n)\n\n3.5564792857210866e-16\n\n\n\n\nQR分解\nQR分解を解きます。\n\nA = rand(10, 8)\n\nF = qr(A)\nQ, R = F.Q, F.R\n\nnorm(\n    A - Q*R\n)\n\n1.83444414964578e-15"
  },
  {
    "objectID": "page-julia-packages-TaylorSeries.html",
    "href": "page-julia-packages-TaylorSeries.html",
    "title": "Julia入門「アルゴリズムと数値計算を極める！」",
    "section": "",
    "text": "Juliaのパッケージ\nインストールするには、JuliaのREPLでusing Pkg; Pkg.add(\"TaylorSeries\")を実行してください。 使いたいタイミングでusing TaylorSeriesと指定して読み込んでください。\n\nusing TaylorSeries\n\n\nTaylorSeriesとは？\nマクローリン展開やテイラー展開を扱うライブラリです。\n\n\nTaylorSeriesの使い方\n以下のように、テイラー展開のモデルと変数を定義できます。\n※Taylor1とかTaylorNという関数で変数を定義する方法もありますが、あまり有用性が分かりませんでした。\n\ntaylor_vars = set_variables(\n  \"x\",      # 変数の組\n  order = 5 # テイラー展開で計算する次数\n)\n\nx = taylor_vars[1]\ntaylor_expr = sin(x)\n\ntaylor_expr\n\n 1.0 x - 0.16666666666666666 x³ + 0.008333333333333333 x⁵ + 𝒪(‖x‖⁶)\n\n\n変数が２つの場合は以下のようになります。\n\ntaylor_vars = set_variables(\n  \"x y\",    # 変数の組\n  order = 7 # テイラー展開で計算する次数\n)\n\nx, y = taylor_vars\ntaylor_expr = exp(x + y)\n\ntaylor_expr\n\n 1.0 + 1.0 x + 1.0 y + 0.5 x² + 1.0 x y + 0.5 y² + 0.16666666666666666 x³ + 0.5 x² y + 0.5 x y² + 0.16666666666666666 y³ + 0.041666666666666664 x⁴ + 0.16666666666666666 x³ y + 0.25 x² y² + 0.16666666666666666 x y³ + 0.041666666666666664 y⁴ + 0.008333333333333333 x⁵ + 0.041666666666666664 x⁴ y + 0.08333333333333333 x³ y² + 0.08333333333333333 x² y³ + 0.041666666666666664 x y⁴ + 0.008333333333333333 y⁵ + 0.001388888888888889 x⁶ + 0.008333333333333333 x⁵ y + 0.020833333333333332 x⁴ y² + 0.027777777777777776 x³ y³ + 0.020833333333333332 x² y⁴ + 0.008333333333333333 x y⁵ + 0.001388888888888889 y⁶ + 0.0001984126984126984 x⁷ + 0.001388888888888889 x⁶ y + 0.004166666666666667 x⁵ y² + 0.006944444444444443 x⁴ y³ + 0.006944444444444443 x³ y⁴ + 0.004166666666666667 x² y⁵ + 0.001388888888888889 x y⁶ + 0.0001984126984126984 y⁷ + 𝒪(‖x‖⁸)"
  },
  {
    "objectID": "page-julia-packages-Images.html",
    "href": "page-julia-packages-Images.html",
    "title": "Julia入門「アルゴリズムと数値計算を極める！」",
    "section": "",
    "text": "Juliaのパッケージ\nインストールするには、JuliaのREPLでusing Pkg; Pkg.add(\"Images\")を実行してください。 使いたいタイミングでusing Imagesと指定して読み込んでください。\n\nusing Images\n\n\nImagesとは？\nImagesはjuliaの画像処理を扱うパッケージです。\n画像データの読み込み、保存、変換、操作など、さまざまな画像処理タスクをサポートしています（ゲームなどで画像を扱いたいときは別のライブラリを使ってください）。\n高速な画像処理を実現するために、Juliaの高性能な数値計算機能や並列処理機能を活用しています。\nImages.jlは、画像データを表現するためのImage型や、画像処理関数の集合などの主要な要素から構成されています。以下に、Images.jlの主な機能と使用例をいくつか示します。\nImageViewやImageShowというパッケージを併せて使えば、imshowなどの関数によって画像の表示ができますが、保存やnotebookでの表示は成功するので気にしないでください（このパッケージ、なぜか重いので私の環境では使っていません）。\n画像の確認はdisplayで行ってください。\n参考\n\n\nImagesの使い方\n\n画像の読み込み\n画像はload関数で読み込めます。\n\nimg1 = load(\"tmp/__imagesample1.bmp\")\ndisplay(img1)\n\n\n\n\n\n\n画像の書き込み（保存）\n書き込みはsave関数です。\n\nx = collect(1.0:-0.1:0)\nimg2 = Gray.(x * x')\ndisplay(img2)\nsave(\"tmp/__imagesample2.png\", img2)\n\n\n\n\n\n\n画像の操作\nグレイスケールにする。\n\nimg1_gray = Gray.(img1)\n\n\n\n\nサイズを変更する。\n\nsiz = (10, 10)\nimg1_resized = imresize(img1, siz)\n\n\n\n\n回転する。\n\nimg1_rotated = imrotate(img1, 45)\n\n\n\n\n切り取る。\n\nss = size(img1)\nimg1_cropped = img1[1:ss[1] ÷ 2, 1:ss[2]  ÷ 2]"
  },
  {
    "objectID": "page-julia-packages-MLDatasets.html",
    "href": "page-julia-packages-MLDatasets.html",
    "title": "Julia入門「アルゴリズムと数値計算を極める！」",
    "section": "",
    "text": "Juliaのパッケージ\nインストールするには、JuliaのREPLでusing Pkg; Pkg.add(\"MLDatasets\"); Pkg.add(\"DataFrames\")を実行してください。\n実行時には、以下のように読み込んでください。\n\nusing DataFrames, MLDatasets\n\n\nMLDatasetsとは？\n機械学習やパターン認識で、サンプルとして一般的に使われるデータを提供するパッケージです。 個人のパソコンなどでも扱える、比較的小さなデータです。 主に以下のサイトにあるデータセットをダウンロードして提供します（初使用時にダウンロードします）。\nこれらのデータは何らかのアルゴリズムの有用性を試す際に、試用的に用いるのが良いでしょう。\nデータセットのサイト\n参考\n以下のようなデータセットがあります。\n\nMNIST（MLDatasets.MNIST）\n28*28のサイズにリサイズされた70000個の手書き数字画像のデータセットです。\n訓練データ \\(\\{X_T, y_T\\}\\) は、mnist_train=MNIST(split=:train)で読み込みます。データのサイズは、\\(X_T \\in \\mathbb{R}^{28 \\times 28 \\times 60000}\\) です。\nまた，テストデータ \\(\\{X_t, y_t\\}\\) は、mnist_test=MNIST(split=:test)で読み込みます。データのサイズは、\\(X_t \\in \\mathbb{R}^{28 \\times 28 \\times 10000}\\) です。\nFashion MNIST（MLDatasets.FashionMNIST）\nMNISTの代わりとなるデータセットです。\nCIFAR-10（MLDatasets.CIFAR10）\n60000個の小さい画像のデータセットです。\nCIFAR-100（MLDatasets.CIFAR100）\nIris（MLDatasets.Iris）\n３種（setosa, versicolor and virginica）の各アヤメの50例のデータ。\nデータの種類は、４種類（sepal length, sepal width, petal length and petal width）となる。\nBoston Housing（MLDatasets.BostonHousing）\nPTBLM\nCiteSeer\nCora\nPubMed\n\n\n\nMLDatasetsの使い方\nIris（アヤメの特徴を格納したデータセット）を例として、使い方を説明します。\n\n読み込み\n以下のようにして、データセットを読み込むことができます。 このように、irisの中身を表示すると、データセットの中に以下の３種のデータフレームがあることが分かると思います。\n\nusing DataFrames, MLDatasets\n\niris = Iris()\n\ndataset Iris:\n  metadata   =&gt;    Dict{String, Any} with 4 entries\n  features   =&gt;    150×4 DataFrame\n  targets    =&gt;    150×1 DataFrame\n  dataframe  =&gt;    150×5 DataFrame\n\n\nfeaturesが特徴で、targetsが分類されるクラス（どの種か？）で、dataframeがそれらを１つのデータフレームとしたものです。\n\n\n開放\n使わなくなったデータは以下のようにしてメモリを開放してください。 次にGC（ガーベッジコレクタ）が実行されたときに自動で開放されますが、手動でやりたい場合は、gc()を実行してください（あまりお勧めしませんが）。\n\niris = Nothing\n\nNothing"
  },
  {
    "objectID": "page-julia-packages-DataFrames.html",
    "href": "page-julia-packages-DataFrames.html",
    "title": "Julia入門「アルゴリズムと数値計算を極める！」",
    "section": "",
    "text": "Juliaのパッケージ\nインストールするには、JuliaのREPLでusing Pkg; Pkg.add(\"DataFrames\")を実行してください。 使いたいタイミングでusing DataFramesと指定して読み込んでください。\n\nusing DataFrames\n\nなおデータフレームを使うパッケージとして、juliaにはPandasというパッケージもあります。\n\nDataFramesとは？\nデータフレームとは、主にPythonのpandasというライブラリで使われるデータの形式です。 特に機械学習で使われているイメージです。\nが、余り高速ではないので、本当に高い効率を必要とするなら、普通に行列を使ってください。\n表を模したデータ構造で、一般的に 行(row)方向にはデータの系列を説明する特徴量(feature)が並び、 列(column)方向には特徴を表現するデータ(index)が並びます。\n\n\n\nsepallength\nsepalwidth\npetallength\npetalwidth\nclass\n\n\n\n\n5.1\n3.5\n1.4\n0.2\nIris-setosa\n\n\n4.9\n3.0\n1.4\n0.2\nIris-setosa\n\n\n-\n-\n-\n-\n-\n\n\n\n仕様が頻繁に変更される場合があることは注意しておいてください。\n\n\nDataFrameコンストラクタ\n\n空のデータを生成する\nDataFrameはデータフレームを表す型で、コンストラクタにより以下のように生成できる。\n\ndf = DataFrame()\n\n\n0×0 DataFrame\n\n\n\n\n行列から生成する。\n特徴名feature_nameはStringでもSymbolでも大丈夫です。 この記事ではSymbolとします（SymbolはExprが包含する変数を表す型だと思ってください）。\n特徴名を自動生成したい場合、以下の第二引数を:autoにしてください。\n\nA = [\n  1 2.0 \"a\";\n  3 4.0 \"b\";\n  5 6.0 \"d\";\n  7 8.0 \"d\";\n  9 0.0 \"e\"\n]\nfeature_name = [:num_odd, :num_even, :alphabet]\ndf = DataFrame(A, feature_name)\n\n5×3 DataFrame\n\n\n\nRow\nnum_odd\nnum_even\nalphabet\n\n\n\nAny\nAny\nAny\n\n\n\n\n1\n1\n2.0\na\n\n\n2\n3\n4.0\nb\n\n\n3\n5\n6.0\nd\n\n\n4\n7\n8.0\nd\n\n\n5\n9\n0.0\ne\n\n\n\n\n\n\n\n\n辞書から生成する。\n表記があれですが、上と似た結果になってるのが分かると思います。\n\nd = Dict(\n  :num_odd  =&gt; [1  , 3  , 5  , 7  , 9  ], \n  :num_even =&gt; [2.0, 4.0, 6.0, 8.0, 0.0], \n  :alphabet =&gt; [\"a\", \"b\", \"c\", \"d\", \"e\"]\n)\ndf = DataFrame(d)\n\n5×3 DataFrame\n\n\n\nRow\nalphabet\nnum_even\nnum_odd\n\n\n\nString\nFloat64\nInt64\n\n\n\n\n1\na\n2.0\n1\n\n\n2\nb\n4.0\n3\n\n\n3\nc\n6.0\n5\n\n\n4\nd\n8.0\n7\n\n\n5\ne\n0.0\n9\n\n\n\n\n\n\n\n\n直接生成する。\nDataFrameの内部の可変長引数の仕組みを使って直接生成することもできます。\n\ndf = DataFrame(\n  :num_odd  =&gt; [1  , 3  , 5  , 7  , 9  ], \n  :num_even =&gt; [2.0, 4.0, 6.0, 8.0, 0.0], \n  :alphabet =&gt; [\"a\", \"b\", \"c\", \"d\", \"e\"]\n)\n\n5×3 DataFrame\n\n\n\nRow\nnum_odd\nnum_even\nalphabet\n\n\n\nInt64\nFloat64\nString\n\n\n\n\n1\n1\n2.0\na\n\n\n2\n3\n4.0\nb\n\n\n3\n5\n6.0\nc\n\n\n4\n7\n8.0\nd\n\n\n5\n9\n0.0\ne\n\n\n\n\n\n\n以下、以下の乱数生成されたデータフレームを参考に記します。\n\nusing Random\nRandom.seed!(0)\ndf = DataFrame(\n  round.(rand(100, 10), digits=3), \n  :auto\n)\n;\n\n\n\n\nデータの参照\n\n最初のn行\n\ndf_first5 = first(df, 5)\ndf_first5\n\n5×10 DataFrame\n\n\n\nRow\nx1\nx2\nx3\nx4\nx5\nx6\nx7\nx8\nx9\nx10\n\n\n\nFloat64\nFloat64\nFloat64\nFloat64\nFloat64\nFloat64\nFloat64\nFloat64\nFloat64\nFloat64\n\n\n\n\n1\n0.455\n0.735\n0.555\n0.876\n0.107\n0.291\n0.694\n0.864\n0.919\n0.408\n\n\n2\n0.548\n0.994\n0.521\n0.572\n0.17\n0.943\n0.313\n0.991\n0.041\n0.282\n\n\n3\n0.773\n0.704\n0.47\n0.975\n0.435\n0.334\n0.079\n0.169\n0.105\n0.871\n\n\n4\n0.941\n0.151\n0.207\n0.594\n0.928\n0.925\n0.148\n0.409\n0.347\n0.945\n\n\n5\n0.03\n0.409\n0.206\n0.659\n0.37\n0.014\n0.835\n0.198\n0.321\n0.864\n\n\n\n\n\n\n\n\n最後のn行\n\ndf_last5 = last(df, 5)\ndf_last5\n\n5×10 DataFrame\n\n\n\nRow\nx1\nx2\nx3\nx4\nx5\nx6\nx7\nx8\nx9\nx10\n\n\n\nFloat64\nFloat64\nFloat64\nFloat64\nFloat64\nFloat64\nFloat64\nFloat64\nFloat64\nFloat64\n\n\n\n\n1\n0.375\n0.924\n0.433\n0.892\n0.885\n0.388\n0.836\n0.698\n0.88\n0.326\n\n\n2\n0.183\n0.749\n0.313\n0.896\n0.574\n0.974\n0.334\n0.382\n0.026\n0.504\n\n\n3\n0.039\n0.909\n0.222\n0.834\n0.031\n0.471\n0.96\n0.293\n0.306\n0.436\n\n\n4\n0.892\n0.043\n0.794\n0.295\n0.185\n0.288\n0.609\n0.854\n0.586\n0.062\n\n\n5\n0.475\n0.776\n0.378\n0.803\n0.143\n0.906\n0.539\n0.228\n0.803\n0.534\n\n\n\n\n\n\n\n\n行の取り出し\n\ndf_trim_rows = df[4:10, :]\ndf_trim_rows\n\n7×10 DataFrame\n\n\n\nRow\nx1\nx2\nx3\nx4\nx5\nx6\nx7\nx8\nx9\nx10\n\n\n\nFloat64\nFloat64\nFloat64\nFloat64\nFloat64\nFloat64\nFloat64\nFloat64\nFloat64\nFloat64\n\n\n\n\n1\n0.941\n0.151\n0.207\n0.594\n0.928\n0.925\n0.148\n0.409\n0.347\n0.945\n\n\n2\n0.03\n0.409\n0.206\n0.659\n0.37\n0.014\n0.835\n0.198\n0.321\n0.864\n\n\n3\n0.747\n0.865\n0.52\n0.65\n0.805\n0.777\n0.42\n0.633\n0.979\n0.746\n\n\n4\n0.747\n0.646\n0.449\n0.89\n0.709\n0.566\n0.972\n0.843\n0.347\n0.16\n\n\n5\n0.977\n0.693\n0.749\n0.419\n0.44\n0.236\n0.159\n0.936\n0.762\n0.864\n\n\n6\n0.329\n0.254\n0.596\n0.248\n0.798\n0.725\n0.855\n0.899\n0.51\n0.15\n\n\n7\n0.672\n0.87\n0.768\n0.998\n0.581\n0.829\n0.813\n0.753\n0.991\n0.013\n\n\n\n\n\n\n\n\n列の取り出し\n\n行数を指定\n\n\ndf_trim_columns = df[:, 3:6]\nfirst(df_trim_columns, 5)\n\n5×4 DataFrame\n\n\n\nRow\nx3\nx4\nx5\nx6\n\n\n\nFloat64\nFloat64\nFloat64\nFloat64\n\n\n\n\n1\n0.555\n0.876\n0.107\n0.291\n\n\n2\n0.521\n0.572\n0.17\n0.943\n\n\n3\n0.47\n0.975\n0.435\n0.334\n\n\n4\n0.207\n0.594\n0.928\n0.925\n\n\n5\n0.206\n0.659\n0.37\n0.014\n\n\n\n\n\n\n\n行名を指定\n\n\ndf_trim_columns = df[:, [:x2, :x5, :x7]]\nfirst(df_trim_columns, 5)\n\n5×3 DataFrame\n\n\n\nRow\nx2\nx5\nx7\n\n\n\nFloat64\nFloat64\nFloat64\n\n\n\n\n1\n0.735\n0.107\n0.694\n\n\n2\n0.994\n0.17\n0.313\n\n\n3\n0.704\n0.435\n0.079\n\n\n4\n0.151\n0.928\n0.148\n\n\n5\n0.409\n0.37\n0.835\n\n\n\n\n\n\n\n\n\nデータのフィルタリング（条件抽出）\n\nfilter関数を用いる方法\nフィルターをかけて、抽出できます。 フィルター関数はデータ（DataFrameの１行分）を受け取って、そのデータがtrueかfalseかを出力する関数です。\n\n\nf = x -&gt; (x[:x1] &gt;= 0.9)\ndf_above9 = filter(f, df)\ndf_above9\n\n14×10 DataFrame\n\n\n\nRow\nx1\nx2\nx3\nx4\nx5\nx6\nx7\nx8\nx9\nx10\n\n\n\nFloat64\nFloat64\nFloat64\nFloat64\nFloat64\nFloat64\nFloat64\nFloat64\nFloat64\nFloat64\n\n\n\n\n1\n0.941\n0.151\n0.207\n0.594\n0.928\n0.925\n0.148\n0.409\n0.347\n0.945\n\n\n2\n0.977\n0.693\n0.749\n0.419\n0.44\n0.236\n0.159\n0.936\n0.762\n0.864\n\n\n3\n0.985\n0.356\n0.753\n0.731\n0.185\n0.182\n0.677\n0.939\n0.378\n0.582\n\n\n4\n0.908\n0.109\n0.914\n0.765\n0.642\n0.338\n0.23\n0.284\n0.607\n0.499\n\n\n5\n0.94\n0.224\n0.321\n0.324\n0.031\n0.825\n0.126\n0.123\n0.376\n0.098\n\n\n6\n0.923\n0.519\n0.488\n0.242\n0.235\n0.486\n0.963\n0.3\n0.318\n0.058\n\n\n7\n0.908\n0.84\n0.057\n0.008\n0.542\n0.201\n0.641\n0.195\n0.035\n0.568\n\n\n8\n0.933\n0.921\n0.013\n0.769\n0.151\n0.429\n0.393\n0.011\n0.218\n0.8\n\n\n9\n0.997\n0.567\n0.697\n0.426\n0.387\n0.563\n0.054\n0.423\n0.858\n0.393\n\n\n10\n0.97\n0.804\n0.489\n0.815\n0.51\n0.656\n0.205\n0.739\n0.755\n0.206\n\n\n11\n0.994\n0.562\n0.755\n0.429\n0.569\n0.19\n0.332\n0.045\n0.778\n0.547\n\n\n12\n0.903\n0.446\n0.088\n0.384\n0.062\n0.661\n0.891\n0.732\n0.514\n0.396\n\n\n13\n0.952\n0.086\n0.117\n0.392\n0.098\n0.003\n0.347\n0.051\n0.469\n0.154\n\n\n14\n0.951\n0.527\n0.45\n0.221\n0.426\n0.02\n0.792\n0.165\n0.872\n0.433\n\n\n\n\n\n\n\n条件演算を用いる方法\n\n条件演算子を使ってアクセスできます。 ちなみにこれは普通の行列の場合も同じように使えます。\n\ndf_bool = (df[:, :x1] .&gt;= 0.9)\ndf_above9 = df[df_bool, :]\ndf_above9\n\n14×10 DataFrame\n\n\n\nRow\nx1\nx2\nx3\nx4\nx5\nx6\nx7\nx8\nx9\nx10\n\n\n\nFloat64\nFloat64\nFloat64\nFloat64\nFloat64\nFloat64\nFloat64\nFloat64\nFloat64\nFloat64\n\n\n\n\n1\n0.941\n0.151\n0.207\n0.594\n0.928\n0.925\n0.148\n0.409\n0.347\n0.945\n\n\n2\n0.977\n0.693\n0.749\n0.419\n0.44\n0.236\n0.159\n0.936\n0.762\n0.864\n\n\n3\n0.985\n0.356\n0.753\n0.731\n0.185\n0.182\n0.677\n0.939\n0.378\n0.582\n\n\n4\n0.908\n0.109\n0.914\n0.765\n0.642\n0.338\n0.23\n0.284\n0.607\n0.499\n\n\n5\n0.94\n0.224\n0.321\n0.324\n0.031\n0.825\n0.126\n0.123\n0.376\n0.098\n\n\n6\n0.923\n0.519\n0.488\n0.242\n0.235\n0.486\n0.963\n0.3\n0.318\n0.058\n\n\n7\n0.908\n0.84\n0.057\n0.008\n0.542\n0.201\n0.641\n0.195\n0.035\n0.568\n\n\n8\n0.933\n0.921\n0.013\n0.769\n0.151\n0.429\n0.393\n0.011\n0.218\n0.8\n\n\n9\n0.997\n0.567\n0.697\n0.426\n0.387\n0.563\n0.054\n0.423\n0.858\n0.393\n\n\n10\n0.97\n0.804\n0.489\n0.815\n0.51\n0.656\n0.205\n0.739\n0.755\n0.206\n\n\n11\n0.994\n0.562\n0.755\n0.429\n0.569\n0.19\n0.332\n0.045\n0.778\n0.547\n\n\n12\n0.903\n0.446\n0.088\n0.384\n0.062\n0.661\n0.891\n0.732\n0.514\n0.396\n\n\n13\n0.952\n0.086\n0.117\n0.392\n0.098\n0.003\n0.347\n0.051\n0.469\n0.154\n\n\n14\n0.951\n0.527\n0.45\n0.221\n0.426\n0.02\n0.792\n0.165\n0.872\n0.433\n\n\n\n\n\n\n\n\nデータの追加と特徴の追加\n行方向にデータが、列方向に特徴があるのはもう説明しましたね。\nデータの追加は、push!かvcat関数を用いて行い、特徴の追加は、hcatを用いて行ってください。 ここでは、データの追加をpush!で、特徴の追加をhcatを使ってやる方法を示します。\n以下が元のデータフレームです。\n\ndf1 = DataFrame(rand(5, 3), :auto)\n\n5×3 DataFrame\n\n\n\nRow\nx1\nx2\nx3\n\n\n\nFloat64\nFloat64\nFloat64\n\n\n\n\n1\n0.160143\n0.774666\n0.624384\n\n\n2\n0.501136\n0.781732\n0.0565774\n\n\n3\n0.0187437\n0.55538\n0.871887\n\n\n4\n0.860183\n0.913038\n0.355375\n\n\n5\n0.655636\n0.409758\n0.524008\n\n\n\n\n\n\npush!を使うと以下のように、元のデータフレームにデータが追加されました。\n\npush!(df1, rand(3))\ndf1\n\n6×3 DataFrame\n\n\n\nRow\nx1\nx2\nx3\n\n\n\nFloat64\nFloat64\nFloat64\n\n\n\n\n1\n0.160143\n0.774666\n0.624384\n\n\n2\n0.501136\n0.781732\n0.0565774\n\n\n3\n0.0187437\n0.55538\n0.871887\n\n\n4\n0.860183\n0.913038\n0.355375\n\n\n5\n0.655636\n0.409758\n0.524008\n\n\n6\n0.279907\n0.215293\n0.379568\n\n\n\n\n\n\n更に、以下のように特徴をデータフレームに追加します。\n\ndf2 = DataFrame(:a =&gt; rand(6))\ndf3 = hcat(df1, df2)\ndf3\n\n6×4 DataFrame\n\n\n\nRow\nx1\nx2\nx3\na\n\n\n\nFloat64\nFloat64\nFloat64\nFloat64\n\n\n\n\n1\n0.160143\n0.774666\n0.624384\n0.577181\n\n\n2\n0.501136\n0.781732\n0.0565774\n0.281778\n\n\n3\n0.0187437\n0.55538\n0.871887\n0.890973\n\n\n4\n0.860183\n0.913038\n0.355375\n0.131291\n\n\n5\n0.655636\n0.409758\n0.524008\n0.30215\n\n\n6\n0.279907\n0.215293\n0.379568\n0.642936\n\n\n\n\n\n\n\n\nSQLライクな操作\nDataFramesの機能を用いてSQLっぽい操作ができます。\n\nselect\n\n# select x1, x4, x5 as a\ndf_select = select(df, :x1, :x4, :x5 =&gt; :a)\nfirst(df_select, 5)\n\n5×3 DataFrame\n\n\n\nRow\nx1\nx4\na\n\n\n\nFloat64\nFloat64\nFloat64\n\n\n\n\n1\n0.455\n0.876\n0.107\n\n\n2\n0.548\n0.572\n0.17\n\n\n3\n0.773\n0.975\n0.435\n\n\n4\n0.941\n0.594\n0.928\n\n\n5\n0.03\n0.659\n0.37\n\n\n\n\n\n\n\n\nwhere\n\n# where x1 &lt; 0.5 & x1 &gt; 0.2\nf = x -&gt; (0.2 &lt; x[:x1] &lt; 0.5)\ndf_filter = filter(f, df)\nfirst(df_filter, 5)\n\n5×10 DataFrame\n\n\n\nRow\nx1\nx2\nx3\nx4\nx5\nx6\nx7\nx8\nx9\nx10\n\n\n\nFloat64\nFloat64\nFloat64\nFloat64\nFloat64\nFloat64\nFloat64\nFloat64\nFloat64\nFloat64\n\n\n\n\n1\n0.455\n0.735\n0.555\n0.876\n0.107\n0.291\n0.694\n0.864\n0.919\n0.408\n\n\n2\n0.329\n0.254\n0.596\n0.248\n0.798\n0.725\n0.855\n0.899\n0.51\n0.15\n\n\n3\n0.23\n0.456\n0.867\n0.198\n0.694\n0.004\n0.686\n0.99\n0.022\n0.67\n\n\n4\n0.47\n0.352\n0.158\n0.938\n0.537\n0.979\n0.528\n0.933\n0.17\n1.0\n\n\n5\n0.415\n0.677\n0.688\n0.042\n0.326\n0.164\n0.447\n0.532\n0.61\n0.386\n\n\n\n\n\n\n\n\n他の関数\n他にもgroupby, join, sort, aggregateなどがあります。 でもあまり使わないと思います。"
  },
  {
    "objectID": "page-julia-packages-ForwardDiff.html",
    "href": "page-julia-packages-ForwardDiff.html",
    "title": "Julia入門「アルゴリズムと数値計算を極める！」",
    "section": "",
    "text": "Juliaのパッケージ\nインストールするには、JuliaのREPLでusing Pkg; Pkg.add(\"ForwardDiff\")を実行してください。 使いたいタイミングでusing ForwardDiffと指定して読み込んでください。\n\nusing ForwardDiff\n\n\nForwardDiffとは？\n関数の微分を自動でしてくれるパッケージです。\nあまり正確なところは分からないのですが、SymPyみたいな解析的な微分ではなく、前進微分で数値微分を行っているものと考えてください。\n\n\nForwardDiffの使い方\n\n微分\n\\[\n\\left. \\frac{d}{dx} f(x) \\right|_{x=x_0} = f'(x_0)\n, \\;\\;\\; x \\in \\mathbb{R}, f: \\mathbb{R} \\rightarrow \\mathbb{R}\n\\]\n以下のようにして微分を計算できます。 xをベクトルとして与えたい（複数点の微分を計算したい）なら、ForwardDiff.derivative.(f, [x1, x2, ...])としてブロードキャストして与えてください。\n\nusing LinearAlgebra\n\nf(x)   = 2^x # 対象とする関数\nf_d(x) = log(2) * 2^x # 解析的な微分\n\nx0 = rand()\nf_d_x0 = ForwardDiff.derivative(f, x0)\n\nf_d(x0) - f_d_x0 # 誤差\n\n0.0\n\n\n\n\nベクトルの微分\n\\[\n\\left. \\frac{d}{dx} \\mathbb{f}(x) \\right|_{x=x_0} = \\mathbb{f}'(x_0)\n, \\;\\;\\; x \\in \\mathbb{R}, \\mathbb{f}: \\mathbb{R} \\rightarrow \\mathbb{R}^n\n\\]\n\nusing LinearAlgebra\n\nf(x)   = [2^x         ; 3*x^3 + x] # 対象とする関数\nf_d(x) = [log(2) * 2^x; 9*x^2 + 1] # 解析的な微分\n\nx0 = rand()\nf_d_x0 = ForwardDiff.derivative(f, x0)\n\nf_d(x0) - f_d_x0 # 誤差\n\n2-element Vector{Float64}:\n 0.0\n 0.0\n\n\n\n\n勾配\n\\[\n\\left. \\frac{\\partial}{\\partial \\mathbb{x}} f(\\mathbb{x}) \\right|_{\\mathbb{x}=\\mathbb{x}_0} =\n\\left. \\nabla f(\\mathbb{x}) \\right|_{\\mathbb{x}=\\mathbb{x}_0}\n=\n\\begin{bmatrix} \\frac{f(\\mathbb{x}_0)}{dx_1} & \\frac{df(\\mathbb{x}_0)}{dx_2} & \\dots & \\frac{df(\\mathbb{x}_0)}{dx_n}\\end{bmatrix}\n, \\;\\;\\; \\mathbb{x} \\in \\mathbb{R}^n, f: \\mathbb{R}^n \\rightarrow \\mathbb{R}\n\\]\n以下のようにして勾配を計算できます。 複数点の勾配を計算したいなら、ForwardDiff.gradient.(f, [x1, x2, ...])としてブロードキャストして与えてください。\n\nf(x1, x2)   = x1^2 + 4 * x2^3 + 3 * x1 * x2\nf(x)        = f(x[1], x[2]) # 対象とする関数\nf_d(x1, x2) = [2*x1 + 3 * x2; 12*x2^2 + 3*x1]\nf_d(x)      = f_d(x[1], x[2]) # 解析的な勾配\n\nx0 = rand(2, 1)\nf_d_x0 = ForwardDiff.gradient(f, x0)\n\nf_d(x0) - f_d_x0 # 誤差\n\n2×1 Matrix{Float64}:\n 0.0\n 0.0\n\n\n\n\nヤコビ行列\n\\[\n\\left. \\frac{\\partial}{\\partial \\mathbb{x}} \\mathbb{f}(\\mathbb{x}) \\right|_{\\mathbb{x}=\\mathbb{x}_0}\n=\n\\begin{bmatrix} \\frac{d \\mathbb{f}(\\mathbb{x}_0)}{dx_1} & \\frac{d \\mathbb{f}(\\mathbb{x}_0)}{dx_2} & \\dots & \\frac{d \\mathbb{f}(\\mathbb{x}_0)}{dx_n}\\end{bmatrix}\n, \\;\\;\\; \\mathbb{x} \\in \\mathbb{R}^n, \\mathbb{f}: \\mathbb{R}^n \\rightarrow \\mathbb{R}^n\n\\]\n以下のようにしてヤコビ行列を計算できます。 複数点のヤコビ行列を計算したいなら、ForwardDiff.jacobian.(f, [x1, x2, ...])としてブロードキャストして与えてください。\n\nf(x1, x2)   = [x1 + x2 + x1*x2                  ;  \n               4 * x1^2 + 3 * x2^2 + 2 * x1^2 * x2^3]\nf(x)        = f(x[1], x[2]) # 対象とする関数\nf_d(x1, x2) = [1 + x2                  1 + x1                  ;\n               8 * x1 + 4 * x1 * x2^3  6 * x2 + 6 * x1^2 * x2^2]\nf_d(x)      = f_d(x[1], x[2]) # 解析的なヤコビ行列\n\nx0 = rand(2, 1)\nf_d_x0 = ForwardDiff.jacobian(f, x0)\n\nf_d(x0) - f_d_x0 # 誤差\n\n2×2 Matrix{Float64}:\n 0.0  0.0\n 0.0  0.0\n\n\n\n\nヘッセ行列（Hessian）\n\\[\n\\left. \\nabla^2 f(\\mathbb{x}) \\right|_{\\mathbb{x}=\\mathbb{x}_0}=\n\\begin{bmatrix}\n  \\frac{\\partial}{\\partial \\mathbb{x}} \\left( \\frac{\\partial f(\\mathbb{x_0})}{\\partial x_1} \\right)\n  &\n  \\frac{\\partial}{\\partial \\mathbb{x}} \\left( \\frac{\\partial f(\\mathbb{x_0})}{\\partial x_2} \\right)\n  & \\dots &\n  \\frac{\\partial}{\\partial \\mathbb{x}} \\left( \\frac{\\partial f(\\mathbb{x_0})}{\\partial x_n} \\right)\n\\end{bmatrix}\n, \\;\\;\\; \\mathbb{x} \\in \\mathbb{R}^n, f: \\mathbb{R}^n \\rightarrow \\mathbb{R}\n\\]\n以下のようにしてヘッセ行列を計算できます。 複数点のヘッセ行列を計算したいなら、ForwardDiff.hessian.(f, [x1, x2, ...])としてブロードキャストして与えてください。\n\nf(x1, x2)   = 2 * x1^3 + x2^2 + sin(x1*x2) + 5 * x1\nf(x)        = f(x[1], x[2]) # 対象とする関数\nf_d(x1, x2) = [(12*x1 - x2^2 * sin(x1*x2))      (cos(x1*x2) - x1*x2*sin(x1*x2)); \n               (cos(x1*x2) - x1*x2*sin(x1*x2))  (2 - x1^2 * sin(x1*x2))        ]\nf_d(x)      = f_d(x[1], x[2]) # 解析的なヘッセ行列\n\nx0 = rand(2, 1)\nf_d_x0 = ForwardDiff.hessian(f, x0)\n\nf_d(x0) - f_d_x0 # 誤差\n\n2×2 Matrix{Float64}:\n 0.0  0.0\n 0.0  0.0"
  },
  {
    "objectID": "page-julia-crypto-1.html",
    "href": "page-julia-crypto-1.html",
    "title": "Julia入門「アルゴリズムと数値計算を極める！」",
    "section": "",
    "text": "暗号理論\n\nAとB = Alice と Bob\n暗号の人たちは、AとかBとかにアリスとかボブとかいう名前を付けたがります。 大体、以下のような感じになっていると考えて下さい。\n\n\n\n\n\n\n\n\n名前\nname\n詳細\n\n\n\n\nアリス\nAlice\n一般人\n\n\nボブ\nBob\n一般人\n\n\nキャサリン\nCathy\n一般人\n\n\nデイブ\nDave\n一般人\n\n\nイブ\nEve\n盗聴者(eavesdropper?)。通信を盗聴する。\n\n\n\\(\\vdots\\)\n\\(\\vdots\\)\n\\(\\vdots\\)\n\n\nマロリー\nMallory\n能動的攻撃者(malicious？)。通信妨害やメッセージの偽装をする。\n\n\n\\(\\vdots\\)\n\\(\\vdots\\)\n\\(\\vdots\\)\n\n\nヴィクター\nVictor\n検証者(validator?)。\n\n\n\\(\\vdots\\)\n\\(\\vdots\\)\n\\(\\vdots\\)\n\n\n\n例えば、アリスがボブにメールを送るとき、悪意のある盗聴者イブがメールを盗み見ようとしたりします。 暗号理論では悪意のある第三者の存在を前提にすることが多いです。\n\n\n暗号化(encrypt)と復号化(decrypt)\n暗号化とは、平文(plaintext)を、意味の分からない文、つまり暗号文(ciphertext)に変換することです。 復号化はその逆で、暗号文から平文に変換することです。\n普通、平文よりも暗号文の方がサイズの大きいデータになります。\n\n\n\n\nflowchart LR\n  a[\"平文=Hello World!\"] -- 暗号化 --&gt;b[\"暗号文=0avjmgc,qn7%xa#mx\"]\n  b -- 復号化 --&gt; a\n\n\n\n\n\n\n\n送信者、受信者、盗聴者\nインターネット上でやり取りされるデータは、通信路の間でコピーすることが容易です。 そのため、以下の図におけるEveのような盗聴者が存在するものとして考える必要があります。\n\n\n\n\nflowchart LR\n  a2 --&gt; b2\n  a2 --&gt; c2\n  subgraph Alice_送信者\n    a1[平文] -- 暗号化 --&gt; a2[暗号文]\n  end\n  subgraph Bob_受信者\n    b2[暗号文] -- 復号 --&gt; b1[平文]\n  end\n  subgraph Eve_盗聴者\n    c2[暗号文]\n  end"
  },
  {
    "objectID": "page-julia-crypto-2.html",
    "href": "page-julia-crypto-2.html",
    "title": "Julia入門「アルゴリズムと数値計算を極める！」",
    "section": "",
    "text": "暗号理論\n\n暗号アルゴリズム（計算機登場以前）\n\nシーザー暗号\nシーザー暗号は、古代ローマの将軍であるガイウス・ユリウス・カエサルが使用したとされる、非常にシンプルな代替暗号の一種です。 シーザー暗号は、アルファベットの文字を一定の数だけシフトさせて暗号化します。\n単位換字暗号\n単一換字暗号は、平文の各文字を別の文字に1対1で置き換える暗号化手法です。\nエニグマ\nエニグマは、第二次世界大戦中にドイツが使用した複雑な電子機械式暗号装置です。\n\n\n\nシーザー暗号\nシーザー暗号は、「鍵」を文字のシフト数 \\(n \\in K=\\{0,1,2,\\dots,2\\}\\) とする暗号です。 鍵空間 \\(K\\) の大きさはここでは \\(|K|=26\\) であり、ブルート・フォース・アタックでの突破が容易な暗号である。\n文字のシフトとは、例えば以下のように、表をもとに文字をずらす手法です。\n\n'あ' + 5\n\n'ぇ': Unicode U+3047 (category Lo: Letter, other)\n\n\nそれぞれの文字（アルファベット）を n_shift だけシフトさせるプログラムは以下の通りです。\n\nfunction char_shift(c, n_shift)\n    if !isletter(c)\n        return c\n    end\n    if !('a' &lt;= lowercase(c) &lt;= 'z')\n        return c\n    end\n    a = 'a'\n    if isuppercase(c)\n        a = 'A'\n    end\n    i = c - a\n    j = (i + n_shift) % 26\n    return a + j\nend\n\nchar_shift.(['a', 'X'], 3)\n\n2-element Vector{Char}:\n 'd': ASCII/Unicode U+0064 (category Ll: Letter, lowercase)\n 'A': ASCII/Unicode U+0041 (category Lu: Letter, uppercase)\n\n\nシーザー暗号の実装は以下の通りです。\n\nfunction encode_caesar(\n    plaintext::AbstractString, \n    n_shift::Integer # key\n)\n    l_plaintext  = collect(plaintext)\n    l_ciphertext = char_shift.(l_plaintext, n_shift)\n    ciphertext   = join(l_ciphertext)\n    return ciphertext\nend\n\nfunction decode_caesar(ciphertext, n_shift)\n    return encode_caesar(ciphertext, 26 - n_shift)\nend\n\n# key\nmykey = 3\n\n# encode\nplaintext  = \"hello world\"\nciphertext = encode_caesar(plaintext, mykey)\n\n# decode\nplaintext_ = decode_caesar(ciphertext, mykey)\n\nplaintext_\n\n\"hello world\"\n\n\n\n\n単一換字暗号\n単一換字暗号は、「鍵」を換字表 \\(\\text{Tbl} \\in K\\) とする暗号です。 鍵空間 \\(K\\) の大きさは \\(|K|=26!=403291461126605635584000000\\) であり、ブルート・フォース・アタックでの突破は困難ですが、頻度分析により比較的簡単に突破できます。\nそれぞれの文字（アルファベット）を Tbl に従って置換するプログラムは以下の通りです。\n\nfunction char_replace(c, tbl)\n    if !isletter(c)\n        return c\n    end\n    if !('a' &lt;= lowercase(c) &lt;= 'z')\n        return c\n    end\n    return tbl[c]\nend\n\nchar_replace (generic function with 1 method)\n\n\n単一換字暗号の暗号は以下の通りです。\n\nfunction encode_monoalphabetic(\n    plaintext::AbstractString, \n    key\n)\n    tbl = Dict(\n        zip(\n            collect(key[1]), collect(key[2])\n        )\n    )\n    l_plaintext  = collect(plaintext)\n    l_ciphertext = (c -&gt; char_replace(c, tbl)).(l_plaintext)\n    ciphertext   = join(l_ciphertext)\n    return ciphertext\nend\n\nfunction decode_monoalphabetic(ciphertext, key)\n    key = (key[2], key[1])\n    return encode_monoalphabetic(ciphertext, key)\nend\n\n# key\nmykey = (\n    collect(\"abcdefghijklmnopqrstuvwxyz\"), \n    collect(\"gpkhayvwcoxzqntudeflmijbrs\")\n)\n\n# encode\nplaintext  = \"hello world\"\nciphertext = encode_monoalphabetic(plaintext, mykey)\n\n# decode\nplaintext_ = decode_monoalphabetic(ciphertext, mykey)\n\nplaintext_\n\n\"hello world\"\n\n\n\n\nエニグマ\nエニグマ（Enigma）は、第二次世界大戦中にドイツで使用された暗号化機械です。 当時は非常に高度な暗号化手法であるとされ、暗号文の解読が非常に困難であると考えられていました。\n機械式の代替暗号装置であり、電気信号を用いて文字を暗号化した暗号です。\nエニグマは、複数の可変ローター（回転ディスク）とプラグボード（Steckerboard）と呼ばれる接続装置から構成されており、これによって文字の置換と交換が行われました。 暗号学の歴史上、重要な節目となる装置であり、暗号解読の研究や教育においても広く取り上げられています。 平文の文字を入力すると、可変ローターの回転と接続装置の置換によって暗号文の文字が出力されます。\nエニグマは KEK(key encrypting key)と言われる、鍵を暗号化するための日替わり鍵を導入したことでも知られています。 そのため、同じ文字が連続して入力されても、異なる文字が出力されるため、エニグマは多重換字暗号として知られる複雑な暗号方式でした。\n※実装は省略します。\n\n\n\n\ngraph LR\n    A[平文] --&gt; B((暗号化))\n    D --&gt; E[暗号化通信鍵と暗号文]\n    F[通信鍵] -.-&gt; B\n    B --&gt; C[暗号文]\n    F --&gt; H((暗号化))\n    I[KEK] -.-&gt; H\n    subgraph LR\n        B\n        C --&gt; D((結合))\n        G[暗号化通信鍵] --&gt; D\n        H --&gt; G\n    end\n\n\n\n\n\n\n\n解読アルゴリズム\n\nブルート・フォース・アタック\nブルート・フォース・アタックは、全ての可能な組み合わせを試行することで、暗号を解読する攻撃手法です。\n頻度分析\n頻度分析は、暗号文の中の文字や記号の出現頻度を解析し、元の平文を特定する手法です。\n\n\n\nブルート・フォース・アタック\nencode_caesarによる暗号は鍵空間が小さいので、ブルート・フォース・アタックで簡単に解読できる。\n以下のシーザー暗号によって暗号化された暗号文を解読することを考える。\n\nciphertext = \"twzgpozrd\"\n\n\"twzgpozrd\"\n\n\n復号化のアルゴリズムは知っているため、decode_caesarを使うことができるものと考え、鍵を\n\nkeys        = collect(0:25)\ndecodetexts = (key -&gt; decode_caesar(ciphertext, key)).(keys)\noutputs     = collect(zip(keys, decodetexts))\n\n26-element Vector{Tuple{Int64, String}}:\n (0, \"twzgpozrd\")\n (1, \"svyfonyqc\")\n (2, \"ruxenmxpb\")\n (3, \"qtwdmlwoa\")\n (4, \"psvclkvnz\")\n (5, \"orubkjumy\")\n (6, \"nqtajitlx\")\n (7, \"mpszihskw\")\n (8, \"loryhgrjv\")\n (9, \"knqxgfqiu\")\n (10, \"jmpwfepht\")\n (11, \"ilovedogs\")\n (12, \"hknudcnfr\")\n (13, \"gjmtcbmeq\")\n (14, \"filsbaldp\")\n (15, \"ehkrazkco\")\n (16, \"dgjqzyjbn\")\n (17, \"cfipyxiam\")\n (18, \"behoxwhzl\")\n (19, \"adgnwvgyk\")\n (20, \"zcfmvufxj\")\n (21, \"ybelutewi\")\n (22, \"xadktsdvh\")\n (23, \"wzcjsrcug\")\n (24, \"vybirqbtf\")\n (25, \"uxahqpase\")\n\n\nこの中で、意味の通る文章は\"ilovedogs\"だけです。 鍵は11なので、次も同じ鍵を使ってた場合、内容がバレバレになってしまいます。\n犬が好きらしいですね。\n\n\n頻度分析\nencode_monoalphabeticによる暗号は鍵空間は少々大きいので、ブルート・フォース・アタックで解読するのは難しそうです。なので、頻度分析と言う手法を使います。\n以下の単一換字暗号によって暗号化された暗号文を解読することを考える。\n\nciphertext = \"cnkerultveguwrgkcuwaetekruwaecfgngzvteclwqyteuaeyteqcnvankerulctntehakerulctngfaecaftyjazzhaycnahflauflwglkgnpaytzztjahgfguetkahmeagngzlaenglciazaffktqqtnlaeqcfankcuwaeqanlltankcuwaeteankthacfltktniaelcnyteqglctncnltkcuwaetekthacnktqqtnugezgnkakcuwaecffrntnrqtmfjclwkthagflwargeaptlwgfaltyflauflwglankerulgqaffgvawtjaiaelwaktnkaulfgeahcflcnklcnkerultveguwrafuakcgzzrkzgffckgzkerultveguwr\"\n\n\"cnkerultveguwrgkcuwaetekruwaecfgngzvteclwqyteuaeyteqcnvankerulctntehakerulctngfaecaftyjazzhaycnahflauflwglkgnpaytzztjahgfguetkahmeagngzlaenglciazaffktqqtnlaeqcfankcuwaeqanlltankcuwaeteankthacfltktniaelcnyteqglctncnltkcuwaetekthacnktqqtnugezgnkakcuwaecffrntnrqtmfjclwkthagflwargeaptlwgfaltyflauflwglankerulgqaffgvawtjaiaelwaktnkaulfgeahcflcnklcnkerultveguwrafuakcgzzrkzgffckgzkerultveguwr\"\n\n\n古典的な頻度分析の手法として、以下のようなアイデアがある。文字列の中に頻出する文字（文字列）を推定できる可能性がある。ただし、これらのアイデアは偏りのない巨大な文章に対しては意味があるが、そうでなければ上手くいかない。\n\n出現するアルファベットの頻度\n多い順に、e, t, a, o, i, n, …, j, x, q, z\n出現する２文字のアルファベット文字列の頻度\n多い順に、th, he, in, er, …\n出現する３文字のアルファベット文字列の頻度\nthe, and, ing, ion,\n参考\n\nこれらのアイデアを利用するために、以下のようにパターンを解析するプログラムを実装した。\n\nfunction pattern_frequency_analysis(\n    text::AbstractString, n::Integer\n)\n    pattern_counts = Dict() # Dict{SubString, Int64}()\n    for i in 1:length(text)- n + 1\n        pattern = text[i:i+n-1]\n        if haskey(pattern_counts, pattern)\n            pattern_counts[pattern] += 1\n        else\n            pattern_counts[pattern] = 1\n        end\n    end\n    result = sort(collect(pattern_counts), by = x -&gt; x[2], rev=true)\n    return result\nend\n\nfunction frequency_analysis(ciphertext, N)\n    for n = 1:N\n        result = pattern_frequency_analysis(ciphertext, n)\n        display(result[1:8])\n    end\nend\n\nfrequency_analysis(ciphertext, 3)\n\n\n\n8-element Vector{Pair{Any, Any}}:\n \"a\" =&gt; 46\n \"t\" =&gt; 35\n \"e\" =&gt; 34\n \"l\" =&gt; 30\n \"n\" =&gt; 28\n \"c\" =&gt; 27\n \"g\" =&gt; 27\n \"k\" =&gt; 27\n\n\n8-element Vector{Pair{Any, Any}}:\n \"ae\" =&gt; 12\n \"nk\" =&gt; 11\n \"uw\" =&gt; 9\n \"wa\" =&gt; 8\n \"tn\" =&gt; 8\n \"te\" =&gt; 8\n \"cn\" =&gt; 8\n \"ul\" =&gt; 7\n\n\n8-element Vector{Pair{Any, Any}}:\n \"ker\" =&gt; 6\n \"wae\" =&gt; 6\n \"eru\" =&gt; 6\n \"rul\" =&gt; 6\n \"uwa\" =&gt; 6\n \"cuw\" =&gt; 5\n \"kcu\" =&gt; 5\n \"ank\" =&gt; 5\n\n\n\n\nここで、aの頻度が多いことから、aをeだと考えて置換する。\n\nciphertext = replace(ciphertext, 'a' =&gt; 'e', 'e' =&gt; 'a')\nfrequency_analysis(ciphertext, 3)\n\n\n\n8-element Vector{Pair{Any, Any}}:\n \"e\" =&gt; 46\n \"t\" =&gt; 35\n \"a\" =&gt; 34\n \"l\" =&gt; 30\n \"n\" =&gt; 28\n \"c\" =&gt; 27\n \"g\" =&gt; 27\n \"k\" =&gt; 27\n\n\n8-element Vector{Pair{Any, Any}}:\n \"ea\" =&gt; 12\n \"nk\" =&gt; 11\n \"uw\" =&gt; 9\n \"we\" =&gt; 8\n \"tn\" =&gt; 8\n \"cn\" =&gt; 8\n \"ta\" =&gt; 8\n \"ul\" =&gt; 7\n\n\n8-element Vector{Pair{Any, Any}}:\n \"wea\" =&gt; 6\n \"aru\" =&gt; 6\n \"uwe\" =&gt; 6\n \"rul\" =&gt; 6\n \"kar\" =&gt; 6\n \"enk\" =&gt; 5\n \"cuw\" =&gt; 5\n \"kcu\" =&gt; 5\n\n\n\n\nここで、eaはerとすることにする。\n\nciphertext = replace(ciphertext, 'a' =&gt; 'r', 'r' =&gt; 'a')\nfrequency_analysis(ciphertext, 3)\n\n\n\n8-element Vector{Pair{Any, Any}}:\n \"e\" =&gt; 46\n \"t\" =&gt; 35\n \"r\" =&gt; 34\n \"l\" =&gt; 30\n \"n\" =&gt; 28\n \"c\" =&gt; 27\n \"g\" =&gt; 27\n \"k\" =&gt; 27\n\n\n8-element Vector{Pair{Any, Any}}:\n \"er\" =&gt; 12\n \"nk\" =&gt; 11\n \"uw\" =&gt; 9\n \"we\" =&gt; 8\n \"tn\" =&gt; 8\n \"cn\" =&gt; 8\n \"tr\" =&gt; 8\n \"ul\" =&gt; 7\n\n\n8-element Vector{Pair{Any, Any}}:\n \"aul\" =&gt; 6\n \"uwe\" =&gt; 6\n \"rau\" =&gt; 6\n \"wer\" =&gt; 6\n \"kra\" =&gt; 6\n \"enk\" =&gt; 5\n \"cuw\" =&gt; 5\n \"kcu\" =&gt; 5\n\n\n\n\nこのように、頻度表を用いて試行錯誤していくことで少ない時間で解ける……場合がある。\n# 元の文章\nincryptographyacipherorcypherisanalgorithmforperformingencryptionordecryption—aseriesofwelldefinedstepsthatcanbefollowedasaprocedureanalternativelesscommontermisenciphermenttoencipherorencodeistoconvertinformationintocipherorcodeincommonparlancecipherissynonymouswithcodeastheyarebothasetofstepsthatencryptamessagehowevertheconceptsaredistinctincryptographyespeciallyclassicalcryptography\n引用した文章"
  },
  {
    "objectID": "page-julia-numericalanalysis-QR.html",
    "href": "page-julia-numericalanalysis-QR.html",
    "title": "Julia入門「アルゴリズムと数値計算を極める！」",
    "section": "",
    "text": "数値解析の基礎\n\nQR分解\nQR分解（QR decomposition）は、行列 \\(A\\) を直交行列 \\(Q\\) と上三角行列 \\(R\\) の積に分解する手法です。\nQR分解は数値解析や線形代数の応用分野で広く使われています。\n\\[\nA = QR\n\\]\nQR分解は正方行列に限らず、 \\(A \\in \\mathbb{R}^{m\\times n}, m \\ge n\\) の行列に適用できます。その時の式は以下の通りです。\nこの場合も \\(Q \\in \\mathbb{R}^{m \\times m}, R \\in \\mathbb{R}^{m \\times n}\\) の形式を使うのが一般的ですが、数値計算上の効率性を考えると \\(Q_1 \\in \\mathbb{R}^{m \\times n}, R_1 \\in \\mathbb{R}^{n \\times n}\\) の形式（エコノミー分解形式）を使う方がより適切です。\n\\[\nA = Q R = \\begin{bmatrix} Q_1 & Q_2 \\end{bmatrix} \\begin{bmatrix} R_1 \\\\ O \\end{bmatrix}\n  = Q_1 R_1\n\\]\n\n\nグラム・シュミットの直交化法\n「グラム・シュミットの直交化法によるQR分解」は、QR分解を分かりやすく説明するうえで重要なアルゴリズムです。\nただし、実際の実装では使いにくいため、このアルゴリズムを用いて数値計算を行うことは稀です。\n\n\n\n\ngraph LR\n  A[A] -- 直交化 --&gt; B[Q]\n  B --&gt; C[R]\n\n\n\n\n\n\n\\(A\\) からグラム・シュミットの直交化により、\\(Q\\) を構築\nグラム・シュミットの直交化は、ベクトル \\(\\{x_j \\in \\mathbb{R}^{m}\\}_{j=1}^{n}\\) を使って直交する \\(n\\) 本のベクトル \\(\\{e_j \\in \\mathbb{R}^{m}\\}_{j=1}^{n}\\) を作るアルゴリズムです。\nこの手法は、次のような漸化式で計算されます(\\(e_j\\) などは縦ベクトルを想定)。\nこれをプログラムで実装することを考える。\n\\[\ne_i = \\frac{u_i}{\\|u_i\\|}, \\;\\;\\; u_i = x_i - \\sum_{j=1}^{i-1} e_j e_j^\\mathrm{T} x_i, \\;\\;\\; e_1 = \\frac{x_1}{\\|x_1\\|}\n\\]\n\\(n\\) についての漸化式によって、\\(e_i\\) を求めるプログラムを実装すると、以下の通りになる。\n\nusing LinearAlgebra\n\nfunction e_orth!(x, E, i)\n    u = x - sum( E[:,j]' * x * E[:,j] for j = 1:i-1 )\n    e = u / norm(u)\n    E[:,i] = e\nend\n;\n\nよって、グラム・シュミットの直交化は以下のように実装される。\n\nfunction orth_gram_schmidt(X)\n   E = zeros(size(X))\n   E[:, 1] = X[:,1] / norm(X[:,1])\n   for i = 2:size(X, 2)\n       xi = X[:,i]\n       e_orth!(xi, E, i)\n   end\n   return E\nend\n\nE = orth_gram_schmidt(rand(3, 3))\nE' * E # 単位行列になっている。\n\n3×3 Matrix{Float64}:\n  1.0          -2.77556e-16  1.20737e-15\n -2.77556e-16   1.0          9.22873e-16\n  1.20737e-15   9.22873e-16  1.0\n\n\n\n\n\\(Q\\) から \\(R\\) を構築\n作成した直交行列を用いると、行列 \\(A=[a_1, a_2, ..., a_n]\\) の各ベクトル \\(a_i\\) は以下のように表現されることになります。\n\\[\na_i = \\sum_{j=1}^{i} e_j e_j' a_i = [e_1, \\dots, e_i, e_{i+1}, \\dots, e_n] \\begin{bmatrix}e_1' a_i \\\\ \\vdots \\\\ e_i' a_i \\\\ 0 \\\\ \\vdots \\\\ 0 \\end{bmatrix}\n\\]\nよって、\\(A\\) は以下のようになります。\n\\[\nA =\n[e_1, \\dots, e_i, e_{i+1}, \\dots, e_n]\n\\begin{bmatrix}\n  e_1'a_1 & e_1'a_2 & e_1'a_3 & \\dots \\\\\n  0       & e_2'a_2 & e_2'a_3 & \\dots \\\\\n  0       & 0       & e_2'a_3 & \\dots \\\\\n  \\vdots  & \\vdots  & \\vdots  & \\vdots\n\\end{bmatrix}\n\\]\nこれをプログラムで実装すると、以下の通りになります。\n\nfunction Q_to_R(Q, A)\n    n = size(A, 2)\n    R = zeros(n, n)\n    for i = 1:n\n        for j = i:n\n            ei, aj = Q[:,i],  A[:,j]\n            R[i,j] = ei' * aj\n        end\n    end\n    return R\nend\n\nA = rand(5, 4)\nQ = orth_gram_schmidt(A)\nR = Q_to_R(Q, A)\n\n4×4 Matrix{Float64}:\n 1.10023  0.967791  0.558673  0.704853\n 0.0      1.03814   1.144     0.44762\n 0.0      0.0       0.587009  0.591543\n 0.0      0.0       0.0       0.368326\n\n\n\n\nQR分解の実装\nグラム・シュミットの直交化法によりQR分解を行う関数myqr_gram_schmidtは以下の通りになります。\n\nfunction myqr_gram_schmidt(A)\n    Q = orth_gram_schmidt(A)\n    R = Q_to_R(Q, A)\n    return Q, R\nend\n\nA = rand(6, 4)\nQ, R = myqr_gram_schmidt(A)\n\nnorm(A - Q*R) \n\n2.982917421429737e-16\n\n\n\n\n\nハウスホルダー法\n「ハウスホルダー法によるQR分解」は、QR分解の実用的なアルゴリズムの１つです。\n\n\n\n\ngraph LR\n  A[A] --&gt; B[A']\n  B -- 変換 --&gt; C[Qi]\n  C -- 小行列化 --&gt; B\n  C --&gt; D[R]\n\n\n\n\n\n\nハウスホルダー変換の意味\nハウスホルダー変換とは、法線ベクトル \\(e\\) の超平面に対して対称に点を写す変換のことです。\n変換を表す以下の行列 \\(H\\) は直交行列かつ対称行列です。\n\\[\nH = I - 2 e e^\\mathrm{T}\n\\]\nハウスホルダー変換は直交変換であるため、どんな超平面を選んでも元のベクトルのノルムを半径とした超球面上にしか変換を行うことはできないことに注意します。\nそうすると、例えば、以下のような変換を行うように \\(e\\) を選んでやることもできます。\n\\[\ny = Hx, \\;\\;\\;  y = \\begin{bmatrix} \\|x\\| \\\\ 0_{m-1} \\end{bmatrix}\n\\]\nこのときの \\(e\\) は以下のベクトルになる。\n\\[\ne =\\frac{x-y}{\\|x-y\\|}\n\\]\n\n\nQR法でのハウスホルダー変換\n以下、全体の変換により得られる行列を \\(A_i\\) 、行列Aを変換していく際の小行列として表れる行列を \\(B_i\\) と定めます。\n\\[\nA_1 = A = B_1\n\\]\n行列 \\(A_1 = A=[a_!, \\dots , a_n]\\) に対して、 \\(x=a_1, \\;\\;\\; y=[\\|x\\|, 0_{m-1}^\\mathrm{T}]^\\mathrm{T}\\) とした時のハウスホルダー変換行列 \\(H_1\\) を作用させると以下のようになります。\n\\[\nA_2 = H_1 A_1 = [H_1 a_1 , \\dots , H_1 a_n] =\n\\begin{bmatrix}\n    \\|a_1\\| & * \\\\\n    0_{m-1} & B_2\n\\end{bmatrix}\n\\]\nここで、小行列を逐次作用させていくことで、\\(k\\) 次上三角行列 \\(R_k\\) と小行列 \\(B_k\\) により、以下のような行列が作れるものとする。\n\\[\nA_k =\n\\begin{bmatrix}\n    R_k & * \\\\\n    O   & B_{k}\n\\end{bmatrix}\n\\]\nここで、\\(B_k\\) という行列に対しても同じようにハウスホルダー変換を施すことができるので、その行列を \\(H_k\\) とすると、以下のように、\\(A_k\\) から \\(A_{k+1}\\) を得る式が求められます。\n\\[\n\\begin{bmatrix}\n    I & O^\\mathrm{T}\\\\\n    O   & H_{k}\n\\end{bmatrix}\nA_k\n=\n\\begin{bmatrix}\n    I & O^\\mathrm{T}\\\\\n    O   & H_{k}\n\\end{bmatrix}\n\\begin{bmatrix}\n    R_k & * \\\\\n    O   & B_{k}\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n    R_k & *\\\\\n    O   & H_{k}B_{k}\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n    R_{k+1} & * \\\\\n    O       & B_{k+1}\n\\end{bmatrix}\n=\nA_{k+1}\n\\]\n\n\nQR法でのハウスホルダー変換の漸化式\nまとめると、\\(Q\\)、\\(R\\) を構築する以下の漸化式が得られます。\n\\[\nR = A_n, \\;\\;\\; Q = Q_1^\\mathrm{T} Q_2^\\mathrm{T} \\dots Q_t^\\mathrm{T}, \\;\\;\\; t=\\text{min}(m-1, n)\n\\]\n\\[\nA_{k+1} = Q_k A_k, \\;\\;\\; A_k=\\begin{bmatrix} R_k & * \\\\ O & B_k \\end{bmatrix} \\;\\;\\; A_1 = A = B_1\n\\]\nここで、直行行列 \\(Q_k\\) は以下の式で表されます。 なお、\\(I\\) は \\(k\\) 次単位行列、\\(O\\) はそれぞれの大きさのゼロ行列です。\n\\[\nQ_k =\n\\begin{bmatrix}\n    I & O^\\mathrm{T}\\\\\n    O   & H_{k}\n\\end{bmatrix}, \\;\\;\\;\nH_k = I - 2 ee', \\;\\;\\;\ne =\\frac{x-y}{\\|x-y\\|}, \\;\\;\\;\nx = b_1, \\;\\;\\;\ny=\\begin{bmatrix} \\|b_1\\| \\\\ 0 \\end{bmatrix}, \\;\\;\\;\nb_1 = B_k[:, 1]\n\\]\n\n\nQR分解の実装\nハウスホルダー変換を行う行列を生成するプログラムは以下の通りです。\n\nusing LinearAlgebra\n\n# e を使って行列 H_k を構築する。\nH(e)    = Matrix{Float64}(I, length(e), length(e)) - 2 * e * e'\n\n# x, y を使って行列 H_k を構築する。\nH(x, y) = H((v -&gt; v / norm(v))(x - y))\n\n# b1 を使って行列 H_k を構築する。\nfunction Bk_to_Hk(Bk)\n    b1 = Bk[:,1]\n    x  = b1\n    y  = zeros(size(b1)); y[1] = norm(b1)\n    return H(x, y)\nend\n\n# 行列 Q_k を構築する。\nfunction Ak_to_Qk!(Qk, Ak, k)\n    Qk[:, :] .= 0\n    Qk[1:k, 1:k]     = Matrix{Float64}(I, k, k)\n    Qk[k:end, k:end] = Bk_to_Hk(Ak[k:end, k:end])\nend\n;\n\n以下のように、本来計算上0になるべき部分にごく小さい値が入っているため、効率はやや悪いですが、細かい部分なのでそこを気にするのは取り敢えず止めておきます。\n\nA = rand(5, 5)\nQ = zeros(size(A))\nAk_to_Qk!(Q, A, 1)\nQ * A\n\n5×5 Matrix{Float64}:\n 1.32355       0.619678   0.308057    1.3399     0.682148\n 5.98989e-18   0.758162   0.169191    0.206891   0.978876\n 2.10574e-16   0.160813   0.0857661  -0.159994   0.0734148\n 1.7442e-16   -0.164528  -0.0646709   0.337136  -0.29762\n 6.33839e-17   0.509526   0.385578    0.561284   0.466446\n\n\n漸化式を適用していく部分を実装すると以下の通りになります。\n\nfunction A_next!(Q, Qk, Ak, k)\n    Ak_to_Qk!(Qk, Ak, k)\n    Ak .= Qk*Ak \n    Q  .= Q*Qk'\nend\n;\n\nQR分解の実装は以下の通りになります。\n\nfunction myqr_house(AA)\n    m, n  = size(AA)\n    Ak = copy(AA)\n    Qk = zeros(m, m)\n    Q  = Matrix{Float64}(I, m, m)\n    t = min(m-1, n)\n    for k = 1:t\n        A_next!(Q, Qk, Ak, k)\n    end\n    R = Ak\n    return Q, R\nend\n\nA = rand(4, 4)\nQ, R = myqr_house(A)\n\nnorm(A - Q*R)\n\n4.873060251453353e-16\n\n\n参考\n\n\n\nギブンス回転\n「ギブンス回転」を用いる方法は、QR分解の実用的なアルゴリズムの１つです。 並列化に向いている手法です。\n説明は暇があったら書きます。\n\n# 行列の下三角の部分だけを返す\nfunction tril_indices(m, n)\n    idx = []\n    for i = 1:m\n        for j = 1:i-1\n            if j &gt; n\n                break\n            end\n            push!(idx, (i,j))\n        end\n    end\n    return idx\nend\n;\n\n\nfunction cos_givens_rotation(a, b)\n    r = √(a^2 + b^2)\n    rot = [\n        a/r -b/r; #  cos sin\n        b/r  a/r  # -sin cos\n    ]\n    return rot\nend\n\n\nfunction myqr_givens_rotation(A)\n    m, n = size(A)\n    Q = Matrix{Float64}(I, m, m)\n    R = copy(A)\n    for ij = tril_indices(m, n)\n        i, j = ij\n        if R[i, j] == 0\n            continue\n        end\n        G = Matrix{Float64}(I, m, m)\n        G[[j, i], [j, i]] = cos_givens_rotation(R[j, j], R[i, j])\n\n        R = G * R\n        Q = Q * G'\n    end\n    return Q, R\nend\n;\n\n\nA = rand(6, 4)\nQ, R = myqr_givens_rotation(A)\n\nnorm(A - Q*R)\n\n5.635475559608569e-16\n\n\n参考"
  },
  {
    "objectID": "page-julia-numericalanalysis-LU.html",
    "href": "page-julia-numericalanalysis-LU.html",
    "title": "Julia入門「アルゴリズムと数値計算を極める！」",
    "section": "",
    "text": "数値解析の基礎\n\nLU分解\nLU分解（LU decomposition）は、正方行列 \\(A\\) を下三角行列（Lower triangular matrix） \\(L\\) と上三角行列（Upper triangular matrix） \\(U\\) の積に分解することです。\nLU分解は数値解析や線形代数の応用分野で広く使われています。\n以下のように、\\(L\\) の対角成分を \\(1\\) とすることが多いです。\n\\[\nA = LU\n  =\n\\begin{bmatrix}\n  1      & 0      & 0      & \\dots  \\\\\n  l_{21} & 1      & 0      & \\dots  \\\\\n  l_{31} & l_{32} & 1      & \\dots  \\\\\n  \\vdots & \\vdots & \\vdots & \\vdots  \n\\end{bmatrix}\n\\begin{bmatrix}\n  u_{11} & u_{12} & u_{13} & \\dots  \\\\\n  0      & u_{22} & u_{23} & \\dots  \\\\\n  0      & 0      & u_{33} & \\dots  \\\\\n  \\vdots & \\vdots & \\vdots & \\vdots\n\\end{bmatrix}\n\\]\nまた、LU分解により生じる行列は、零要素や \\(L\\) の1になる対角成分が含まれ、メモリに格納する際に無駄になることから、プログラム上では以下のような因子として保存されているものと考えてください。\n\\[\nF_\\text{lu} =\n\\begin{bmatrix}\n  u_{11} & u_{12} & u_{13} & \\dots  \\\\\n  l_{21} & u_{22} & u_{23} & \\dots  \\\\\n  l_{31} & l_{32} & u_{33} & \\dots  \\\\\n  \\vdots & \\vdots & \\vdots & \\vdots\n\\end{bmatrix}\n\\]\nなお、この説明では行列が適当に使いやすい行列であるものと仮定してます（一部の要素が０の場合、ピボッティングをしない場合は上手くいかないケースがあるので……）。\n\n\nJuliaのLU分解\nJuliaではLinearAlgebraパッケージにluという関数が用意されています。 以下のように使用できます。\n一見、格納されている行列に無駄があるように見えますが、実際に格納されているのはF.factorsなので大丈夫です。\n\nusing LinearAlgebra\n\nA = rand(5, 5)\nF = lu(A)\nA[F.p, :] - F.L * F.U\n\n5×5 Matrix{Float64}:\n 0.0   0.0          0.0  0.0  0.0\n 0.0   0.0          0.0  0.0  0.0\n 0.0  -1.40946e-17  0.0  0.0  0.0\n 0.0   0.0          0.0  0.0  0.0\n 0.0   0.0          0.0  0.0  0.0\n\n\n\n\nガウスの消去法（ドゥーリトル法）\n\nガウスの消去法\nまず、\\(A\\) を以下のようにベクトルとして考えて、\\(L_1, U_1, A_1\\) を以下のように設定してください。\n\\[\nU_1 = A_1 = A = \\begin{bmatrix} a_1^\\mathrm{T} \\\\ a_2^\\mathrm{T} \\\\ \\vdots \\\\ a_n^\\mathrm{T} \\end{bmatrix}\n, \\;\\;\\;\nL_1 = I\n\\]\nガウスの消去法による列の消去は以下の方法で行います（\\(a_i\\) の１つ目の要素を消したいというモチベーションが働いています）。\n\\[\nu_i \\gets a_i - \\frac{a_{i1}}{a_{11}} a_1, \\;\\;\\; i=2, 3, \\dots, n\n\\]\nこれを行列化すると、以下の通りです。\n\\[\nU_2\n=\n\\begin{bmatrix} a_1^\\mathrm{T} \\\\ a_2^\\mathrm{T} - \\frac{a_{21}}{a_{11}} a_1^\\mathrm{T} \\\\ \\vdots \\\\ a_n^\\mathrm{T} - \\frac{a_{n1}}{a_{11}} a_1^\\mathrm{T} \\end{bmatrix}\n=\n\\begin{bmatrix}\n    1                       & 0     & 0     & \\dots & 0 \\\\\n    - \\frac{a_{21}}{a_{11}} & 1     & 0     & \\dots & 0 \\\\\n    - \\frac{a_{31}}{a_{11}} & 0     & 1     & \\dots & 0 \\\\\n    \\vdots                  & \\vdots& \\vdots& \\dots & 0 \\\\\n    - \\frac{a_{n1}}{a_{11}} & 0     & 0     & \\dots & 1\n\\end{bmatrix}\n\\begin{bmatrix} a_1^\\mathrm{T} \\\\ a_2^\\mathrm{T} \\\\ \\vdots \\\\ a_n^\\mathrm{T} \\end{bmatrix}\n=\nL_2 A\n\\]\nここで、出来上がった行列 \\(U_2\\) は１列目の第１要素以外の全てが0になっています。 即ち、以下のような行列になっています。 ここの \\(A_2\\) という行列は、\\(U_2\\) の小行列です。\n\\[\nU_2 =\n\\begin{bmatrix}\n  a_{11} & \\begin{bmatrix}a_{12} & \\dots & a_{1n} \\end{bmatrix}\\\\\n  \\begin{bmatrix} 0\\\\ \\vdots \\\\0 \\end{bmatrix}       & A_2\n\\end{bmatrix}\n\\]\nこの行列 \\(A_2\\) に対して、同じことをやっていけば、最終的には以下のような行列になるって寸法です。\n\\[\nL^{-1} A = (L_n \\dots L_3 L_2)^{-1} A = U_n = U\n\\]\nLの逆行列は単に符号を逆にしていけばいいだけなので、恐れるに足りません。即座に以下の行列が得られます。\n\\[\nA = LU\n\\]\n\n\nガウスの消去法のコード\nまず、小行列 \\(A_k\\) に対して１行目に対する処理を行う関数は以下の通りです。\n\n\"\"\"\n行列 Amin から L, U の要素を生成する関数です。\n\"\"\"\nfunction gausselim!(L, U, Amin, idx)\n    # 小行列のビューの作成（破壊的操作を可能とする）\n    Lmin, Umin = view(L, idx, idx), view(U, idx, idx)\n    # 小行列に対する消去法による列の変形\n    jdx = 2:length(idx)\n    Lmin[jdx, 1] = Amin[jdx, 1] / Amin[1, 1]\n    for i = jdx\n        Umin[i, jdx] = Umin[i, jdx] - Lmin[i, 1] * Umin[1, jdx]\n    end\n    Umin[jdx, 1] .= 0\nend\n\nA    = rand(3, 3)\nL, U = diagm(ones(3)), copy(A)\n\ngausselim!(L, U, A, 1:3)\ndisplay.(\n    [L, U, L*U - A]\n)\n;\n\n\n\n3×3 Matrix{Float64}:\n  1.0     0.0  0.0\n 52.1943  1.0  0.0\n 42.0676  0.0  1.0\n\n\n3×3 Matrix{Float64}:\n 0.0129682    0.728014    0.35789\n 0.0        -37.9956    -18.1654\n 0.0        -29.7356    -14.7065\n\n\n3×3 Matrix{Float64}:\n 0.0  0.0           0.0\n 0.0  1.88738e-15   6.66134e-16\n 0.0  1.44329e-15  -6.66134e-16\n\n\n\n\n次に、LU分解を行う関数は以下の通りです。\n\nfunction lu_Doolittle(A)\n    n = size(A, 1)\n    L, U = diagm(ones(n)), copy(A)\n    for k = 1:n # n-1まででも同じです。\n        idx  = k:n\n        Amin = U[idx, idx]\n        gausselim!(L, U, Amin, idx)\n    end\n    return L, U\nend\n\nA    = rand(5, 5)\nL, U = lu_Doolittle(A)\nA - L * U\n\n5×5 Matrix{Float64}:\n 0.0          0.0   0.0           0.0           0.0\n 1.11022e-16  0.0   0.0           0.0           0.0\n 0.0          0.0  -1.11022e-16  -6.66134e-16   3.33067e-16\n 0.0          0.0   3.44169e-15   6.32827e-15   1.25455e-14\n 0.0          0.0  -3.88578e-16   3.33067e-16  -2.22045e-16\n\n\n\n\n\nクラウトの方法\n以下のように上三角行列の対角要素を1とします。\n\\[\nA = LU\n  =\n\\begin{bmatrix}\n  l_{11} & 0      & 0      & \\dots  \\\\\n  l_{21} & l_{22} & 0      & \\dots  \\\\\n  l_{31} & l_{32} & l_{33} & \\dots  \\\\\n  \\vdots & \\vdots & \\vdots & \\vdots  \n\\end{bmatrix}\n\\begin{bmatrix}\n  1      & u_{12} & u_{13} & \\dots  \\\\\n  0      & 1      & u_{23} & \\dots  \\\\\n  0      & 0      & 1      & \\dots  \\\\\n  \\vdots & \\vdots & \\vdots & \\vdots\n\\end{bmatrix}\n\\]\n上記の等式を書き直すと、以下のようになります。\n\\[\nA\n=\n\\begin{bmatrix}\n  l_1^\\mathrm{T} \\\\ l_2^\\mathrm{T} \\\\ \\vdots \\\\ l_n^\\mathrm{T}\n\\end{bmatrix}\n\\begin{bmatrix}\n  u_1 & u_2 & \\dots & u_n\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n  l_1^\\mathrm{T} u_1 & l_1^\\mathrm{T} u_2 & \\dots & l_1^\\mathrm{T} u_n \\\\\n  l_2^\\mathrm{T} u_1 & l_2^\\mathrm{T} u_2 & \\dots & l_2^\\mathrm{T} u_n \\\\\n  \\vdots             & \\vdots             & \\dots & \\vdots             \\\\\n  l_n^\\mathrm{T} u_1 & l_n^\\mathrm{T} u_2 & \\dots & l_n^\\mathrm{T} u_n\n\\end{bmatrix}\n\\] \\[\nl_k =\n\\begin{bmatrix}\n  l_{k1} & \\dots & l_{kk} & 0 & \\dots & 0\n\\end{bmatrix}\n^\\mathrm{T}\n\\] \\[\nu_k =\n\\begin{bmatrix}\n  u_{k1} & \\dots & u_{kk} & 0 & \\dots & 0\n\\end{bmatrix}\n^\\mathrm{T}\n\\]\nすなわち、以下が成り立ちます。\n\\[\na_{ij} = l_{i}^\\mathrm{T} u_j = \\sum_{k=1}^{\\min(i, j)} l_{ik} u_{kj}\n\\]\nこれを、\\(l_{ij}\\) と \\(u_{ij}\\) について解くと以下の式が得られます。\n\\[\n\\left\\{\n\\begin{matrix}\nl_{ij} = a_{ij} - \\sum_{k=1}^{j-1} l_{ik} u_{kj} & (i \\ge j)\\\\\nu_{ij} = \\left( a_{ij} - \\sum_{k=1}^{j-1} l_{ik} u_{kj} \\right) / l_{ii} & (i&lt;j, \\;\\; l_{ii} \\neq 0)\n\\end{matrix}\n\\right.\n\\]\n以下が、クラウト法のプログラムとなります。 loop1, loop2とloop1', loop2'はそれぞれループを交換できます。\n\nfunction lu_Crout(A)\n    n = size(A, 1)\n    L = zeros(n, n)\n    U = zeros(n, n)\n    for k = 1:n\n        # lij\n        for i = k:n # loop1\n            if k == 1\n                s = 0.0\n            else\n                s = sum(L[i, j] * U[j, k] for j = 1:k-1) # loop2\n            end\n            L[i,k] = A[i,k] - s\n        end\n        # uij\n        for j = k+1:n # loop1'\n            if k == 1\n                s = 0.0\n            else\n                s = sum(L[k,i] * U[i,j] for i = 1:k-1) # loop2'\n            end\n            U[k,j] = (A[k,j] - s) / L[k,k]\n        end\n    end\n    U = U + diagm(ones(n))\n    return L, U\nend\n\n\nA = rand(5, 5)\nL, U = lu_Crout(A)\n\nA - L * U\n\n5×5 Matrix{Float64}:\n 0.0   0.0          0.0  0.0  0.0\n 0.0  -1.11022e-16  0.0  0.0  0.0\n 0.0   0.0          0.0  0.0  0.0\n 0.0   0.0          0.0  0.0  0.0\n 0.0   0.0          0.0  0.0  1.11022e-16"
  },
  {
    "objectID": "page-julia-numericalanalysis-Cholesky.html",
    "href": "page-julia-numericalanalysis-Cholesky.html",
    "title": "Julia入門「アルゴリズムと数値計算を極める！」",
    "section": "",
    "text": "数値解析の基礎\n\nCholesky分解\nコレスキー分解とは、正定値エルミート行列 \\(A\\) を下三角行列 \\(L\\) を用いて以下のような分解形式で表すことである。 この分解の手法は、ガウスの消去法の自然な拡張とも言える。\n\n\n具体的な手法\n\\[\nA_1 = A\n\\]\nここで、以下のように各変数を定める。\n\\[\nA_1\n=\n\\begin{bmatrix}\n  a_{11} & \\begin{bmatrix} a_{12} & \\dots & a_{1n} \\end{bmatrix} \\\\\n  \\begin{bmatrix} a_{12} \\\\ \\vdots \\\\ a_{1n} \\end{bmatrix} & *\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n  a_{11} & c_1^* \\\\\n  c_1 & B_1\n\\end{bmatrix}\n\\]\nこの行列を \\(a_{11} \\gets 1\\) （\\(a_{11}\\) の場所が1になるようにしたい）かつ、\\(c_1=0\\)（列要素をガウスの消去法的に削除したい） にしたい。 そのため、以下のように変形する。\n\\[\n\\begin{bmatrix}\n  a_{11} & c_1^* \\\\\n  c_1 & B_1\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n  \\sqrt{a_{11}} & 0 \\\\\n  \\frac{1}{\\sqrt{a_{11}}} c_1 & I\n\\end{bmatrix}\n\\begin{bmatrix}\n  \\sqrt{a_{11}} & \\frac{1}{\\sqrt{a_{11}}} c_1^* \\\\\n  0 & B_1 - \\frac{1}{a_{11}} c_1 c_1^*\n\\end{bmatrix}\n\\]\n\\[\n\\begin{bmatrix}\n  a_{11} & c_1^* \\\\\n  c_1 & B_1\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n  \\sqrt{a_{11}} & 0^* \\\\\n  \\frac{1}{\\sqrt{a_{11}}} c_1 & I\n\\end{bmatrix}\n\\begin{bmatrix}\n  1 & 0^* \\\\\n  0 & B_1 - \\frac{1}{a_{11}} c_1 c_1^*\n\\end{bmatrix}\n\\begin{bmatrix}\n  \\sqrt{a_{11}} & \\frac{1}{\\sqrt{a_{11}}} c_1^* \\\\\n   0 & I\n\\end{bmatrix}\n\\]\nまとめると、\\(A_1\\) は以下のようになる。 \\[\nA_1 =\nL_1\n\\begin{bmatrix}  \n  1 & 0^* \\\\\n  0 & A_2\n\\end{bmatrix}\nL_1^*\n, \\;\\;\\;\nL_1 =\n\\begin{bmatrix}\n  \\sqrt{a_{11}} & 0^* \\\\\n  \\frac{1}{\\sqrt{a_{11}}} c_1 & I\n\\end{bmatrix}\n, \\;\\;\\;\nA_2 = B_1 - \\frac{1}{a_{11}} c_1 c_1^*\n\\]\nこの行列 \\(A_2\\) に対して、同じことをやっていけば、最終的には以下のような行列になります。 \\[\nA = (L_n \\dots L_2 L_1) (L_1^* L_2^* \\dots L_n^*)\n\\]\nよって、以下の式が求められました。\n\\[\nA = L L^*\n\\]\n\n\n実装\n消去法の実装は以下の通りです。\n\nusing LinearAlgebra\n\nfunction cholelim!(LL, AA, idx)\n  n = size(AA, 1)\n  jdx = 2:size(idx, 1)\n  L, A = view(LL, idx, idx), view(AA, idx, idx)\n\n  # 行列Lの要素を作成\n  L[1, 1] = √(A[1, 1])\n  L[jdx, 1] = A[jdx, 1] / √(A[1, 1])\n  for j = jdx\n    L[j, j] = 1\n  end\n  # 行列Aの要素を作成\n  A[jdx, jdx] = A[jdx, jdx] - A[jdx, 1] * A[jdx, 1]' / A[1, 1]\n  A[jdx, 1] .= 0; A[1, jdx] .= 0\n  A[1, 1] = 1\nend\n\nA = (x -&gt; tril(x, -1) + triu(x))(rand(5, 5))\nL = zeros(size(A))\nA_orig = copy(A)\ncholelim!(L, A, 1:5)\n\ndisplay.([L, A]);\n\n5×5 Matrix{Float64}:\n 0.900252  0.0  0.0  0.0  0.0\n 0.346827  1.0  0.0  0.0  0.0\n 0.591462  0.0  1.0  0.0  0.0\n 0.810241  0.0  0.0  1.0  0.0\n 1.10622   0.0  0.0  0.0  1.0\n\n\n5×5 Matrix{Float64}:\n 1.0   0.0         0.0        0.0        0.0\n 0.0   0.671009    0.738131   0.535455  -0.269104\n 0.0  -0.192149    0.269381   0.251301  -0.0610811\n 0.0   0.37925     0.518042  -0.100037  -0.694046\n 0.0   0.0819181  -0.291624  -0.415095  -0.625166\n\n\nコレスキー分解の実装は以下の通りです。\n\nfunction colesky_func(A)\n  n = size(A, 1)\n  AA = copy(A)\n  L  = zeros(n, n)\n  for i = 1:n-1\n    idx = i:n\n    if size(idx, 1) &lt;= 1 \n      continue\n    end\n    cholelim!(L, AA, idx)\n  end\n  return L\nend\n\nA = (x -&gt; tril(x) * tril(x)')(rand(5,5))\nL = colesky_func(A)\n\nA - L * L'\n\n5×5 Matrix{Float64}:\n 0.0   0.0           0.0          0.0   0.0\n 0.0   2.22045e-16  -5.55112e-17  0.0   0.0\n 0.0  -5.55112e-17  -2.22045e-16  0.0   1.11022e-16\n 0.0   0.0           0.0          0.0   0.0\n 0.0   0.0           1.11022e-16  0.0  -0.863632"
  },
  {
    "objectID": "page-julia-numbertheory-1.html",
    "href": "page-julia-numbertheory-1.html",
    "title": "Julia入門「アルゴリズムと数値計算を極める！」",
    "section": "",
    "text": "整数論\n\n漸化式\n漸化式は僕の分野だと何に役立つか良く分かりません。 同次形の微分方程式にちょっと似てるかなってくらいです。\nただ、再帰的な解法を解くためのツールとして、何かに役立つかもしれないと思います。\nNaiveな方法なら、初期項 \\(a_0\\) から 更新式 \\(a_n = f(a_{n-1}, ..., a_0)\\) で逐次求めていけば良いだけのものです。\n\n\n漸化式の解法\n\nケースA\nA  \\(a_n = a_{n-1} + d\\)   \\(\\Rightarrow\\)  A’  \\(\\Delta a_n = a_n - a_{n-1} = d\\)   \\(\\Rightarrow\\)   \\(a_n = nd + a_0\\) \n\n\nケースB\nB  \\(a_n = r a_{n-1}\\)  \\(\\Rightarrow\\)   \\(a_n = r^n a_0\\) \n\n\nケースC\nC  \\(a_n = a_{n-1} + f(n)\\)   \\(\\Rightarrow\\)  C’  \\(\\Delta a_n = a_n - a_{n-1} = f(n)\\)   \\(\\Rightarrow\\)   \\(a_n= a_0 + \\sum_{k=1}^{n} f(k)\\) \n\n\nケースD\nD  \\(a_n = p a_{n-1} + q\\)   \\(\\Rightarrow\\)  D’  \\(b_n = p b_{n-1}\\)   \\(\\Rightarrow\\)  B\n\n\n式変形\n\n\\(p \\neq 1\\) かつ \\(n \\rightarrow \\infty\\) において \\(a_n \\rightarrow \\alpha\\) とする。 このとき、\\(b_n = a_n - \\alpha\\) と置くと、以下のように変形できます。 \\[\n\\begin{array}{rr}\n           & a_n    = p a_{n-1} + q\\\\\n  +\\big{)} & \\alpha = p \\alpha  + q\\\\\n  \\hline\n           & b_n    = p b_{n-1}\n\\end{array}\n\\]\n\n\n\nケースE\nE  \\(a_n = p a_{n-1} + q r^n\\)   \\(\\Rightarrow\\)  E’  \\(b_n = \\frac{p}{r} b_{n-1} + q\\)   \\(\\Rightarrow\\)  D\n\n\n式変形\n\n\\(b_n=\\frac{a_n}{r^n}\\) と置くと、以下のように変形できます。 \\[\n\\frac{a_n}{r^n} = \\frac{p a_{n-1}}{r^n}               + q \\Rightarrow\n\\frac{a_n}{r^n} = \\frac{p}{r} \\frac{a_{n-1}}{r^{n-1}} + q \\Rightarrow\nb_n             =         b_{n-1}                     + q\n\\]\n\n\n\nケースF\nF  \\(a_n = p a_{n-1} + q n + r\\)   \\(\\Rightarrow\\)  F’  \\(b_n = p b_{n-1} + q\\)   \\(\\Rightarrow\\)  D\n\n\n式変形\n\n\\(b_n=a_n - a_{n-1}\\) と置くと、以下のように変形できます。 \\[\n\\begin{array}{rr}\n           & a_n     = p a_{n-1} + q n     + r\\\\\n  +\\big{)} & a_{n-1} = p a_{n-2} + q (n-1) + r\\\\\n  \\hline\n           & b_n     = p b_{n-1} + q\n\\end{array}\n\\]\n\n\n\nケースG\nG  \\(a_n + p a_{n-1} + q a_{n-2} = 0\\)   \\(\\Rightarrow\\)  特性方程式  \\(\\Rightarrow\\)   \\(t^n + p t^{n-1} + q t^{n-2} = 0, a_n=t^n\\)   \\(\\Rightarrow\\)   \\(t^2 + p t + q = 0, a_n=t^n\\) \n\n\nケースH1\nH1  \\(a_n^k = r a_{n-1}^l\\)   \\(\\Rightarrow\\)  H1’  \\(k b_n = \\log(r) + l b_{n-1}\\)   \\(\\Rightarrow\\)  D\n\n\n式変形\n\n\\(b_n = \\log(a_n)\\)とすると、以下のように書き表せる。 \\[k \\log(a_n) = \\log(r) + l \\log(a_{n-1})\\] \\[k b_n = \\log(r) + l b_{n-1}\\]\n\n\n\nケースH2\nH2  \\(a_n^k = r a_{n-1}^l a_{n-2}^m\\)   \\(\\Rightarrow\\)  対数\n\n\nケースI\nI  \\(a_n = \\frac{p a_{n-1}}{r a_{n-1} + s}\\)   \\(\\Rightarrow\\)  逆数\n\n\nケースJ\nJ  \\(a_n = \\frac{p a_{n-1}}{r a_{n-1} + s}\\)   \\(\\Rightarrow\\)  \\(x=\\frac{p x}{r x + s}\\) で平行移動\n\n\nケースK\nK  \\(a_n=p a_{n-1}+q b_{n-1} , b_n = r a_{n-1} + s b_{n-1}\\)   \\(\\Rightarrow\\)  行列の固有値"
  },
  {
    "objectID": "page-julia-calculus-1.html",
    "href": "page-julia-calculus-1.html",
    "title": "Julia入門「アルゴリズムと数値計算を極める！」",
    "section": "",
    "text": "微分積分\n微分積分学について説明します。 あまり厳密には扱いません。\n\n微分と積分\n微分と積分は、数学の基本的な操作であり、相互関係を持つ重要な概念です。 微分は関数の変化率を求める操作であり、積分は関数の面積や累積量を求める操作です。 以下にそれぞれの操作を説明し、相互関係についても触れます。\n\n微分\n微分（Differentiation）は、関数の微小な変化率や勾配を求める操作です。ある関数の微分は、その関数の各点での傾きを表します。微分は関数の変化を詳細に分析するために使用され、物理学や経済学などの科学的なモデリングにおいても重要です。\n\\[\n\\frac{d}{dx} F(x) = f(x)\n\\]\n左辺は以下の極限で表すこともできます。 実用上、とても大切な式です。\n\\[\n\\lim_{\\delta x -&gt; 0} \\frac{f(x + \\delta x) - f(x)}{\\delta x}\n\\]\n\n\n積分\n積分（Integration）は、関数の面積や累積量を求める操作です。積分は関数を積み上げることにより、元の関数が表す領域の面積や累積を求めます。積分は、物理学の運動方程式の解析や確率論の確率密度関数の計算などで使用されます。\n\\[\nF(x) = \\int_{c}^{x} f(t) dt\n\\]\n微分と積分の相互関係は、微分と積分の逆操作を表します。\n\n\n微分と積分の関係\n微分と積分は基本的な定理によって関連付けられています。 ニュートン・ライプニッツの基本定理によれば、ある関数f(x)の積分とその関数の原始関数F(x)の微分は互いに逆の関係にあります。\n\\[\n\\int_{a}^{b} f(x) dx = F(b) - F(a)  \n\\]\nこの定理により、積分は微分の逆操作として捉えることができます。\n具体的には、関数f(x)を微分して得られる導関数f’(x)を求め、その導関数を積分すると元の関数f(x)が得られます。\n\\[\n\\frac{d}{dx} f(x) = f'(x)\n\\]\n\\[\n\\int f'(x) dx = f(x) + C\n\\]\nここで、Cは積分定数です。微分と積分の逆操作によって、元の関数を復元することができます。\nこのように、微分と積分は相互に関連しており、微分によって関数の変化率や勾配を求め、積分によって関数の面積や累積量を求めることができます。微分と積分は数学の基礎であり、物理学、経済学、工学、統計学などのさまざまな分野で広く応用されています。\n数値積分、数値微分は数値解析の説明に譲ります。\n\n\n\n微分公式\nそれぞれの微分公式をJuliaで確認しましょう。\nSymPyでは微分積分などを扱えますが、対応していない計算に対しては動作しないので過信しないでください。\n\n\n\\(f(x)=x^n\\)\n微分すると、 \\(f'(x)=nx^{n-1}\\) となる。 これをJuliaで書くと以下のようになる:\n\nusing SymPy\n@vars x\ndiff(x^10, x)\n\n\\(10 x^{9}\\)\n\n\n\n\n\n\\(f(x)=\\sin(x), g(x)=\\cos(x)\\)\n微分すると、 \\(f'(x)=\\cos(x), g'(x)=-\\sin(x)\\) となる。 これをJuliaで書くと以下のようになる:\n\ndisplay.(\n    (diff(sin(x), x), diff(cos(x), x))\n);\n\n\\(\\cos{\\left(x \\right)}\\)\n\n\n\\(- \\sin{\\left(x \\right)}\\)\n\n\n\n\n\n\\(f(x)=e^x\\)\n微分すると、 \\(f'(x)=e^x\\) となる。 これをJuliaで書くと以下のようになる:\n\ndiff(exp(x), x)\n\n\\(e^{x}\\)\n\n\n\n\n\n\\(f(x)=a^x\\)\n微分すると、 \\(f'(x)= a^x \\log(a)\\) となる。 これをJuliaで書くと以下のようになる:\n\ndiff(10^x, x)\n\n\\(10^{x} \\log{\\left(10 \\right)}\\)\n\n\n\n\n\n\\(f(x)=e^x\\)\n微分すると、 \\(f'(x)=e^x\\) となる。 これをJuliaで書くと以下のようになる:\n\ndiff(exp(x), x)\n\n\\(e^{x}\\)\n\n\n\n\n\n\\(f(x)=\\log(x)\\)\n微分すると、 \\(f'(x)=\\frac{1}{x}\\) となる。 これをJuliaで書くと以下のようになる:\n\ndiff(log(x), x)\n\n\\(\\frac{1}{x}\\)\n\n\n\n\n\n\\(f(x)=\\sinh(x), g(x)=\\cosh(x)\\)\n微分すると、 \\(f'(x)=\\cosh(x), g'(x)=\\sinh(x)\\) となる。 これをJuliaで書くと以下のようになる:\n\ndisplay.(\n    (diff(sinh(x), x), diff(cosh(x), x))\n);\n\n\\(\\cosh{\\left(x \\right)}\\)\n\n\n\\(\\sinh{\\left(x \\right)}\\)\n\n\n\n\n\n関数の和 \\(h(x)=(f+g)(x)\\)\n微分すると、 \\(h'(x)=(f'+g')(x)\\) となる。 これをJuliaで書くと以下のようになる:\n\nf = sympy.Function(\"f\")(x)\ng = sympy.Function(\"g\")(x)\ndiff((f + g)(x), x)\n\n\\(\\frac{d}{d x} f{\\left(x \\right)} + \\frac{d}{d x} g{\\left(x \\right)}\\)\n\n\n\n\n\n関数の積 \\(h(x)=f(x)g(x)\\)\n微分すると、 \\(h'(x)=(f'*g)(x)+(f*g')(x)\\) となる。 これをJuliaで書くと以下のようになる:\n\nf = sympy.Function(\"f\")(x)\ng = sympy.Function(\"g\")(x)\ndiff((f * g)(x), x)\n\n\\(f{\\left(x \\right)} \\frac{d}{d x} g{\\left(x \\right)} + g{\\left(x \\right)} \\frac{d}{d x} f{\\left(x \\right)}\\)\n\n\n\n\n\n合成関数 \\(h(x)=f(g(x))\\)\n微分すると、 \\(h'(x)=f'(g(x))g'(x)\\) となる。 これをJuliaで書くと以下のようになる:\n\nf = sympy.Function(\"f\")(x)\ng = sympy.Function(\"g\")(x)\ndiff(f(g(x)), x)\n\n\\(\\frac{d}{d g{\\left(x \\right)}} f{\\left(g{\\left(x \\right)} \\right)} \\frac{d}{d x} g{\\left(x \\right)}\\)\n\n\n\n\n\n例えば……合成関数 \\(f(x)=\\sin(x^{10})\\)\n微分すると、 \\(f'(x)=10x^9 cos(x^{10})\\) となる。 これをJuliaで書くと以下のようになる:\n\ndiff(sin(x^10), x)\n\n\\(10 x^{9} \\cos{\\left(x^{10} \\right)}\\)\n\n\n\n\n\n\n積分公式\nそれぞれの積分公式をJuliaで確認しましょう。\nなお、今回は積分定数を無視します。\n\n\n\\(f(x)=x^n, g(x)=\\frac{1}{x}\\)\n積分すると、\\(F(x)=\\frac{1}{n+1}x^{n+1}, G(x)=\\log(|x|)\\) となる。 これをJuliaで書くと以下のようになる:\n\nusing SymPy\n@vars x\ndisplay.(\n  (integrate(x^10, x), integrate(1/x, x))\n)\n;\n\n\\(\\frac{x^{11}}{11}\\)\n\n\n\\(\\log{\\left(x \\right)}\\)\n\n\n\n\n\n\\(f(x)=\\sin(x), g(x)=\\cos(x), h(x)=\\tan(x)\\)\n積分すると、\\(F(x)=-\\cos(x), G(x)=\\sin(x), H(x)=-\\log(|\\cos(x)|)\\) となる。 これをJuliaで書くと以下のようになる:\n\ndisplay.(\n    (integrate(sin(x), x), integrate(cos(x), x), integrate(tan(x), x))\n)\n;\n\n\\(- \\cos{\\left(x \\right)}\\)\n\n\n\\(\\sin{\\left(x \\right)}\\)\n\n\n\\(- \\log{\\left(\\cos{\\left(x \\right)} \\right)}\\)\n\n\n\n\n\n\\(f(x)=e^x\\)\n積分すると、\\(F(x)=e^x\\) となる。 これをJuliaで書くと以下のようになる:\n\nintegrate(exp(x), x)\n\n\\(e^{x}\\)\n\n\n\n\n\n\\(f(x)=\\log(x)\\)\n積分すると、\\(F(x)=x \\log(x) - x\\) となる。 これをJuliaで書くと以下のようになる:\n\nintegrate(log(x), x)\n\n\\(x \\log{\\left(x \\right)} - x\\)\n\n\n\n\n\n\\(f(x)=\\sinh(x), g(x)=\\cosh(x)\\)\n積分すると、\\(F(x)=\\cosh(x), G(x)=\\sinh(x)\\) となる。 これをJuliaで書くと以下のようになる:\n\ndisplay.(\n    (integrate(sinh(x)), integrate(cosh(x)))\n)\n;\n\n\\(\\cosh{\\left(x \\right)}\\)\n\n\n\\(\\sinh{\\left(x \\right)}\\)"
  },
  {
    "objectID": "page-julia-linearalgebra-1.html",
    "href": "page-julia-linearalgebra-1.html",
    "title": "Julia入門「アルゴリズムと数値計算を極める！」",
    "section": "",
    "text": "線形代数\n\n行列とは？\n行列は、数値や変数を配列したものです。 行と列からなる2次元のデータ構造で、さまざまな分野で広く使用されています。\n一般的な行列は、以下のように表現されます: \\[\n\\begin{bmatrix}\na_{11} & a_{12} & \\ldots & a_{1n} \\\\\na_{21} & a_{22} & \\ldots & a_{2n} \\\\\n\\vdots & \\vdots & \\ddots & \\vdots \\\\\na_{m1} & a_{m2} & \\ldots & a_{mn} \\\\\n\\end{bmatrix}\n\\]\n行列における加減乗除は、以下のように計算できます。\n\nA = [\n    1 2  1;\n    4 5 -2;\n    3 2 1.0\n]\nB = [\n    -1 5  6;\n     4 3 -7;\n     2 4 9.0\n]\n;\n\n行列の和\n\nA + B\n\n3×3 Matrix{Float64}:\n 0.0  7.0   7.0\n 8.0  8.0  -9.0\n 5.0  6.0  10.0\n\n\n行列の差\n\nA - B\n\n3×3 Matrix{Float64}:\n 2.0  -3.0  -5.0\n 0.0   2.0   5.0\n 1.0  -2.0  -8.0\n\n\n行列の積\n\nA * B\n\n3×3 Matrix{Float64}:\n  9.0  15.0    1.0\n 12.0  27.0  -29.0\n  7.0  25.0   13.0\n\n\n行列の除算(逆行列の作用)\n\nA \\ B\n\n3×3 Matrix{Float64}:\n  1.5       -0.5       1.5\n -0.777778   1.77778  -0.444444\n -0.944444   1.94444   5.38889\n\n\n行列の転置\n\nA'\n\n3×3 adjoint(::Matrix{Float64}) with eltype Float64:\n 1.0   4.0  3.0\n 2.0   5.0  2.0\n 1.0  -2.0  1.0\n\n\n\n\n行列の便利さ\n線形代数における行列は非常に重要です。 行列は、数値の集合を整理し、ベクトルや線形写像の表現や解析に利用されます。 以下に、行列の重要性をいくつか説明します。\n※内容について詳しく理解する必要はありません。\n\n線形写像の表現\n行列は線形写像を表現するための重要な道具です。 線形写像はベクトル空間から別のベクトル空間への線形な変換を表すものであり、例えば、以下のような表現ができます。 \\[ f(x) = Ax \\] \\[g \\bullet f(x) = BAx \\]\n線形方程式の解法\n行列は線形方程式の解法にも使用されます。 線形方程式は未知の変数に関する線形な等式の集合です。 \\[ Ax = b \\]\n固有値と固有ベクトル\n行列の固有値と固有ベクトルは、線形写像の特性を表す重要な概念です。 固有値とは、線形写像がベクトルに対して与える変換のスケールを表し、固有ベクトルはそのスケールが現れる方向を表します。行列の固有値と固有ベクトルを求めることで、線形写像の性質や変換の効果を理解することができます。固有値分解や特異値分解などの手法も、行列の固有値と固有ベクトルを利用しています。 \\[ Ax=\\lambda x \\]\nデータ解析と機械学習\n行列はデータ解析や機械学習の分野でも広く利用されます。例えば、多次元データを行列の形で表現することで、特徴ベクトルや特徴行列を得ることができます。これにより、データの類似性や相関関係を解析したり、機械学習アルゴリズムによるパターン識別や予測を行うための入力として利用することができます。また、行列の演算や変換を用いて、データの次元削減や特徴抽出などの処理も行われます。\n線形独立性と行列のランク\n行列の線形独立性と行列のランクは、ベクトルや行列の性質を理解する上で重要な概念です。行列の線形独立性は、ベクトルや行列の組が線形的に独立しているかどうかを示し、行列のランクはその独立な列または行の最大の数を表します。線形独立性とランクは、行列の性質や特徴を解析する際に役立ちます。\n\n\n\n有名な行列\n一般的な名前のついた行列について、可能な限り網羅します。 また、その性質についても説明します。\n\nゼロ行列（Zero Matrix）：すべての要素が0の行列です。\nゼロ行列は行列演算の加法単位元(「……？」って人はとりあえず無視)です。\nJuliaでのゼロ行列の作成方法は次の通りです。\n\nusing LinearAlgebra\n# 3x3のゼロ行列\nO = zeros(3, 3)\nO\n\n3×3 Matrix{Float64}:\n 0.0  0.0  0.0\n 0.0  0.0  0.0\n 0.0  0.0  0.0\n\n\n\n任意の行列Aとゼロ行列Oの和は元の行列Aと等しくなります。 \\[ A+O = O+A \\]\n任意の行列Aとゼロ行列Oの積はゼロ行列となります。 \\[ AO = OA = O \\]\nゼロ行列は任意のスカラー倍によってゼロ行列となります。 \\[ cO = Oc = O, c \\in \\mathbb{R} \\]\n\n\n\n単位行列（Identity Matrix）：主対角線上の要素がすべて1で、それ以外の要素が0の行列です。\n単位行列はは行列演算の乗法単位元です。\nJuliaでの単位行列の作成方法は次の通りです。\n\n# 3x3の単位行列\nE = Matrix{Float64}(I, 3, 3)\nE\n\n3×3 Matrix{Float64}:\n 1.0  0.0  0.0\n 0.0  1.0  0.0\n 0.0  0.0  1.0\n\n\n\n任意の行列Aと単位行列Iの積は元の行列Aと等しくなります。 \\[ A * I = I * A = A \\]\n単位行列を任意の非負定数乗すると、同じ単位行列が得られます。 \\[ I^n = I \\]\n逆行列は単位行列となる。 \\[ II^{-1} = I^{-1}I = I \\]\n単位行列は、対称行列である。\n\n\n\n対角行列（Diagonal Matrix）：主対角線上以外の要素がすべて0で、主対角線上の要素が非ゼロの行列です。\nJuliaでの対角行列の作成方法は次の通りです。\n\n# 3x3の対角行列（対角要素：1, 2, 3）\nD = Diagonal([1, 2, 3])\nD\n\n3×3 Diagonal{Int64, Vector{Int64}}:\n 1  ⋅  ⋅\n ⋅  2  ⋅\n ⋅  ⋅  3\n\n\n\n\n対称行列（Symmetric Matrix）：転置しても元の行列と等しい行列です。主対角線を中心に対称な要素を持ちます。\nJuliaでの対称行列の作成方法は次の通りです。\n\n# 3x3の対称行列\nSym = Symmetric(\n    [1 2 3;\n     2 4 5;\n     3 5 6]\n)\nSym\n\n3×3 Symmetric{Int64, Matrix{Int64}}:\n 1  2  3\n 2  4  5\n 3  5  6\n\n\n\n転置した行列と等しい。 \\[ D^\\mathrm{T} = D \\]\n対称行列の和は対称行列になる。 \\[ (D_1 + D_2)D_1^\\mathrm{T} = D_1 + D_2 \\]\n要素全てが実数のエルミート行列である。\n\n\n\n上三角行列（Upper Triangular Matrix）：主対角線より下の要素がすべて0である行列です。\nJuliaでの上三角行列の作成方法は次の通りです。\n\n# 3x3の上三角行列（対角要素：1, 2, 3）\nUT = UpperTriangular(\n    [1 2 3; \n     0 4 5; \n     0 0 6]\n)\nUT\n\n3×3 UpperTriangular{Int64, Matrix{Int64}}:\n 1  2  3\n ⋅  4  5\n ⋅  ⋅  6\n\n\n\n\n下三角行列（Lower Triangular Matrix）：主対角線より上の要素がすべて0である行列です。\nJuliaでの下三角行列の作成方法は次の通りです。\n\n# 3x3の下三角行列（対角要素：1, 2, 3）\nLT = LowerTriangular(\n    [1 0 0;\n     2 3 0;\n     4 5 6]\n)\nLT\n\n3×3 LowerTriangular{Int64, Matrix{Int64}}:\n 1  ⋅  ⋅\n 2  3  ⋅\n 4  5  6\n\n\n\n\nエルミート行列（Hermitian Matrix）：転置共役しても元の行列と等しい行列です。主対角線を中心にエルミート（共役転置）な要素を持ちます。\nJuliaでのエルミート行列の作成方法は次の通りです。\n\n# 3x3のエルミート行列\nHermit = Hermitian(\n    [1     2+3im 4-1im;\n     2-3im 5     6+2im;\n     4+1im 6-2im 7     ]\n)\nHermit\n\n3×3 Hermitian{Complex{Int64}, Matrix{Complex{Int64}}}:\n 1+0im  2+3im  4-1im\n 2-3im  5+0im  6+2im\n 4+1im  6-2im  7+0im\n\n\n\n\nフロベニウス行列（Frobenius Matrix）：非負整数の正方行列で、各行の要素が行番号と列番号の積と等しい行列です。\nJuliaでのフロベニウス行列の作成方法は次の通りです。\n\nusing SpecialMatrices\n# 3x3のフロベニウス行列\nFrobenius(3, [1, 2, 3])\n\n6×6 Frobenius{Int64}:\n 1  0  0  0  0  0\n 0  1  0  0  0  0\n 0  0  1  0  0  0\n 0  0  1  1  0  0\n 0  0  2  0  1  0\n 0  0  3  0  0  1\n\n\n\n\n巡回行列（Circulant Matrix）：行列の各行が循環的にシフトされた結果得られる行列です。\nJuliaでの巡回行列の作成方法は次の通りです。\n\nusing ToeplitzMatrices\n# 3x3の巡回行列\nCirculant([1, 2, 3])\n\n3×3 Circulant{Int64, Vector{Int64}}:\n 1  3  2\n 2  1  3\n 3  2  1\n\n\n\n\nハンケル行列（Hankel Matrix）：対角線から左上方向と右下方向に同じ要素が並ぶ行列です。\nJuliaでのハンケル行列の作成方法は次の通りです。\n\n# 3x3のハンケル行列\nHankel([1,2,3,4,5,6], (3,4))\n\n3×4 Hankel{Int64, Vector{Int64}, Tuple{Int64, Int64}}:\n 1  2  3  4\n 2  3  4  5\n 3  4  5  6"
  },
  {
    "objectID": "page-julia-linearalgebra-2.html",
    "href": "page-julia-linearalgebra-2.html",
    "title": "Julia入門「アルゴリズムと数値計算を極める！」",
    "section": "",
    "text": "線形代数\n行列の分解手法は沢山ありますが、固有値分解は最も汎用的に役立つ例の一つです。\n\n固有値と固有ベクトル\n固有値（Eigenvalues）と固有ベクトル（Eigenvectors）は、線形代数において重要な概念です。 これらの対（組）を固有対（eigenpair）と呼ぶことがあります。 固有値と固有ベクトルは、行列に対して特定の性質を持つベクトルとスカラー値です。\n行列Aが与えられたとき、ベクトル \\(v\\) とスカラー \\(\\lambda\\) に対して以下の式が成り立つとき、\\(v\\) を \\(A\\) の固有ベクトル、\\(\\lambda\\) を \\(A\\) の固有値と呼びます。\n\\[ A v = \\lambda v \\]\nこの式は、行列 \\(A\\) によってベクトル \\(v\\) が \\(\\lambda\\) 倍に変換されることを表しています。 固有ベクトルは方向が変化せずにスケールされるため、行列の変換の中で特別な役割を果たします。\n固有ベクトルは、行列を関数として扱いたいときに効力を発揮します。 超便利！\n行列が異なる固有値を持つ \\(n\\) 個の線形独立な固有ベクトルを持つ場合、その行列は対角化可能だと言えます。 この『対角化』とは、行列 \\(A\\) を以下の形式で表せるということです。 実際、式をいじってみるとこうなります。 \\[ A = PDP^{-1} \\]\nJuliaで固有値、固有ベクトルを求める方法は以下の通りです：\n\nusing LinearAlgebra\nA = rand(3, 3)\nF = eigen(A) # F.valuesが固有値, F.vectorsが固有ベクトル\nF\n\nEigen{ComplexF64, ComplexF64, Matrix{ComplexF64}, Vector{ComplexF64}}\nvalues:\n3-element Vector{ComplexF64}:\n 0.08308200761683276 - 0.44573113013363286im\n 0.08308200761683276 + 0.44573113013363286im\n  1.7044633459422398 + 0.0im\nvectors:\n3×3 Matrix{ComplexF64}:\n -0.333971-0.430515im  -0.333971+0.430515im  -0.393287+0.0im\n -0.396317+0.263419im  -0.396317-0.263419im  -0.687586+0.0im\n  0.690408-0.0im        0.690408+0.0im       -0.610369+0.0im\n\n\nF.valuesを見ると内部が昇順にソートされてるのが分かると思います。 固有値は大きさで挙動が変わるので確かめておくと便利です。\nちなみに、固有値の定義から以下のように計算すると、実際に値が正しいか確認できます。\n\nP, D = F.vectors, diagm(F.values)\nA - P * D * inv(P)\n\n3×3 Matrix{ComplexF64}:\n -1.11022e-16-4.66675e-17im  …  6.10623e-16+4.19441e-17im\n          0.0-1.23175e-16im     7.77156e-16+2.48059e-17im\n -3.33067e-16-1.43258e-16im     1.11022e-16-5.73539e-18im\n\n\n誤差が十分小さいので、\\(A\\) を表現できたと確認できましたね。\nもし、使いたい行列が \\(A=PDP^{-1}\\) となったとしたら、そのことは凄く重要な意味を持ちます。\n\n\n固有値の性質\n\nトレースが全ての固有値の和になる\n\n\ntr(A) - sum(F.values)\n\n8.881784197001252e-16 - 0.0im\n\n\n\n行列式が全ての固有値の積になる。\n\n\ndet(A) - prod(F.values)\n\n-3.3306690738754696e-16 - 0.0im\n\n\n\n逆行列が固有値の逆数で簡単に求められる（後述する行列関数の特殊ケース）\n\n\ninv_D = diagm(F.values .^ -1)\ninv(A) - (P * inv_D * inv(P))\n\n3×3 Matrix{ComplexF64}:\n  1.11022e-15-1.3664e-16im   …  4.44089e-16-1.6165e-16im\n  2.44249e-15+6.62355e-17im             0.0+6.40496e-17im\n -3.55271e-15-1.20016e-17im     2.77556e-16+7.57959e-18im\n\n\n\n行列関数の高速計算に使える。 \\(A^n\\) みたいな計算を特に考えずに \\(AAA...AA\\) と行列の積で計算しようとする相当なコストがかかります。 なぜなら、\\(A\\) が \\(m\\times m\\) 行列だとすれば、単純な掛け算が \\(O(nm^3)\\) も行われるからです。 しかし、固有値を使うと、\\(A=PDP^{-1}\\) より、\\(A^n = A=P D^n P^{-1}\\) になります。 計算量は（固有値分解に係るコストを無視すれば）相当に抑えることができます。\n\n\nn = 10\nA^n - P * (D^n) * inv(P)\n\n3×3 Matrix{ComplexF64}:\n 1.84741e-13-9.03642e-15im  …  3.19744e-13+1.7228e-15im\n 3.48166e-13-1.57984e-14im     5.96856e-13+3.01193e-15im\n 2.84217e-13-1.40243e-14im     4.83169e-13+2.67367e-15im\n\n\n\n\n行列関数\n行列関数（Matrix function）は、行列を入力として受け取り、行列を出力する関数です。 通常の数値関数がスカラーを操作するのに対して、行列関数は行列を操作するための特殊な関数です。 行列関数は線形代数や数値計算、物理学、統計学などの分野で広く使用されます。\nJuliaでは行列関数が標準で実装されているものが多く、固有値分解は勝手にやってくれてます。\n行列関数の具体的な例としては、以下のようなものがあります。\n\n行列の \\(n\\) 乗 \\[ A^n = P D^n P^{-1} \\]\n\n\nA ^ 5\n\n3×3 Matrix{Float64}:\n 2.38053  3.88034  3.36437\n 4.13445  6.78976  5.89316\n 3.6911   6.00212  5.24617\n\n\n\n行列の指数関数 行列指数関数は指数関数を行列に適用したもので、指数級数を用いて定義されます。 行列指数関数は、物理学や制御工学などで連立微分方程式の解を求める際に使用されます。 内部の詳細な仕様は知りませんが、固有値を使うと以下のように書けます。 \\[ e^{A} = P e^{D} P^{-1} \\]\n\n\nexp(A)\n\n3×3 Matrix{Float64}:\n 1.54178   1.51131  0.846944\n 0.950071  3.23801  1.93422\n 1.69066   1.53527  2.67958\n\n\n\n行列の対数関数 行列対数関数は対数関数を行列に適用したもので、行列指数関数の逆操作となります。 行列対数関数は、行列の対角化や行列の対称性を利用するなどの目的で使用されます。 \\[ \\log A = P \\log D P^{-1} \\]\n\n\nlog(A)\n\n3×3 Matrix{Float64}:\n -1.11638    1.22603   -0.318213\n -0.661488   0.21397    0.785896\n  1.92048   -0.495273  -0.14627\n\n\n\n行列の三角関数 行列の三角関数には行列のサイン、コサイン、タンジェントなどがあります。これらの関数は行列の固有値や固有ベクトルの計算、回転行列の操作などで使用されます。 \\[ \\sin A = P \\sin D P^{-1} \\]\n\n\nsin(A)\n\n3×3 Matrix{Float64}:\n  0.0596995  0.53024    0.00280859\n -0.0860126  0.641437   0.449297\n  0.753893   0.0289707  0.472678\n\n\n\n一般の関数 関数 \\(f(x)\\) のフーリエ級数が収束するなど、ある程度良い条件のもとでは、一般の関数 \\(f(x)\\) に対しても行列関数を適用できます。 \\[ f(x) = P f(D) P^{-1} \\]\n\n\nfunction f_MatrixFunction(f, A)\n  F    = eigen(A)\n  P, D = F.vectors, diagm(F.values)\n  f_D = diagm(f.(F.values))\n  return P * f_D * inv(P)\nend\n\nf_MatrixFunction(x -&gt; tan(x+pi), A)\n\n3×3 Matrix{ComplexF64}:\n -1.33408-3.52467e-16im    -1.759-1.17877e-16im  -1.95063+2.72109e-17im\n -2.48043-5.67696e-16im  -3.35218-1.47176e-16im  -3.00296+1.0823e-16im\n -1.44085-4.76187e-16im  -3.45766-7.6695e-17im   -2.61318+9.60753e-17im"
  },
  {
    "objectID": "page-julia-calculus-vartrans.html",
    "href": "page-julia-calculus-vartrans.html",
    "title": "Julia入門「アルゴリズムと数値計算を極める！」",
    "section": "",
    "text": "微分積分\n\n変数変換とヤコビアン\n\n変数変換\n変数変換とは、変数を他の変数の表現に変換することを言います。 微分積分でよく用いられる概念です。\n例えば、地球から見た火星の座標を太陽からみた火星の座標に変換する的な感じです。 火星の絶対的な位置は変わらないものの、相対的な見え方が変わるので、火星を表現するデータにも変換を加えなければならないことに注意してください。\nなお、ここでは一旦、変換を何らかの写像 \\(T\\) で行ってるものと考えます。\n\\[\nT: x \\rightarrow y\n\\]\n変数変換を行うと、扱う変数の定義域や座標系上のオブジェクトの位置が置換されます。\n定義域は、以下のように変換されます。\n\\[\nT: X \\rightarrow Y\n\\]\n点の位置は、以下のように変換されます。 点の集まりの直線とか面積とか立体も、\\(T\\) で変換されます。\n\\[\ny_0 = T(x_0)\n\\]\n\n\nヤコビ行列\nこの変換を微分積分の文脈で用いるとき、ヤコビ行列と言われる行列が意味を持ちます。 ヤコビ行列は以下の式における \\(\\frac{dy}{dx}\\) です。 \\(J\\) や \\(\\frac{\\partial y}{\\partial x}\\) と書くことの方が多いかもしれないです。\nちなみに、ヤコビ行列は勾配の意味で使われたりすることもあります。 要は、多変数やベクトルに対して微分をどのように定義するかと言うだけの話なので、気にしないで。\n\\[\ndy = \\frac{dy}{dx} dx\n, \\;\\;\\;\n\\frac{dy}{dx} =\n\\begin{bmatrix}\n  \\frac{\\partial y}{\\partial x_1} & \\frac{\\partial y}{\\partial x_2} & \\dots & \\frac{\\partial y}{\\partial x_n}\n\\end{bmatrix}\n, \\;\\;\\;\n\\frac{\\partial y}{\\partial x_i} =\n\\frac{\\partial}{\\partial x_i}\n\\begin{bmatrix}\n  y_1 \\\\ y_2 \\\\ \\vdots \\\\ y_n\n\\end{bmatrix}\n\\]\n\n\nヤコビアン\nヤコビアン（拡大率）とは、ヤコビ行列の行列式です。 色々な表記があるので拡大率の名目で使われているかをちゃんと見てください。\n\\[\n|J|\n=\n|\\frac{dy}{dx}|\n=\n\\left|\n  \\begin{matrix}\n    \\frac{\\partial y_1}{\\partial x_1} & \\frac{\\partial y_2}{\\partial x_1} & \\dots & \\frac{\\partial y_n}{\\partial x_1} \\\\\n    \\frac{\\partial y_1}{\\partial x_2} & \\frac{\\partial y_2}{\\partial x_2} & \\dots & \\frac{\\partial y_n}{\\partial x_2} \\\\\n    \\vdots                            & \\vdots                            & \\vdots& \\vdots                            \\\\\n    \\frac{\\partial y_1}{\\partial x_n} & \\frac{\\partial y_2}{\\partial x_n} & \\dots & \\frac{\\partial y_n}{\\partial x_n}\n  \\end{matrix}\n\\right|\n\\]\nヤコビアンは微小面積にたいして \\(dxdy=rdr\\theta\\) のように拡大の大きさを示す。\n\n\n逆変換\n微分積分の文脈で変数変換を逆に行うのはそう難しいことではありません。 普通の微分と同じで、ただ逆行列を計算するだけです。\n\\[\n\\left(\\frac{dy}{dx}\\right) ^ {-1} = \\frac{dx}{dy}\n\\]\nこれはつまり、\\(\\frac{dy}{dx}\\) と \\(\\frac{dx}{dy}\\) のうち微分が簡単な方を選んで微分すれば両方を計算したことと同じだということです。\n\n\n\n変数変換の例\n変数変換について、幾つかの象徴的な例を説明します。\n\n線形変換\n線形変換 \\(A=\\begin{bmatrix} 3 & 2 \\\\ 4 & 1 \\end{bmatrix}\\) によって２次元ユークリッド空間から同じく２次元ユークリッド空間に変数変換することを考える。\n\\(A: \\begin{bmatrix} x_1 \\\\ x_2 \\end{bmatrix} \\rightarrow \\begin{bmatrix} y_1 \\\\ y_2 \\end{bmatrix}\\)\nこれは簡単で、１次元のときの微分と同じで、係数行列 \\(A\\) をそのままヤコビ行列とすれば大丈夫です。\n\\[\n\\frac{dy}{dx} = A\n\\]\nなので、ヤコビアンは \\(|J|=|A|=-5\\) より、\\(d y_1 d y_2=-5 d x_1 d x_2\\)\n例えば、\\(J \\left( \\begin{bmatrix} 1 & 1 \\end{bmatrix}^\\mathrm{T} \\right)=\\begin{bmatrix} 3 & 2 \\\\ 4 & 1 \\end{bmatrix}\\)\n\n# Tは変換: y = T(x)\nusing ForwardDiff\n\nT(x) = [3 2; 4 1] * x\nx0 = [1; 1]\nForwardDiff.jacobian(T, x0)\n\n2×2 Matrix{Int64}:\n 3  2\n 4  1\n\n\nプログラムでもちゃんと確認できました。\n\n\n極座標（2-dimension）\n変換によって 極座標平面 \\((r, \\theta)\\) を２次元ユークリッド空間 \\(\\begin{bmatrix}x \\\\ y\\end{bmatrix}\\) に変数変換することを考える。\n\\[\n\\begin{bmatrix}x \\\\ y\\end{bmatrix}\n=\nr\n\\begin{bmatrix}\\cos\\theta \\\\ \\sin\\theta\\end{bmatrix}\n\\]\nヤコビ行列は、\\(p=\\begin{bmatrix}r \\\\ \\theta \\end{bmatrix}\\) とすると以下のようになる。\n\\[\n\\frac{d}{dp} \\begin{bmatrix} x \\\\ y \\end{bmatrix}\n=\n\\begin{bmatrix}\n  \\frac{d}{dr} \\begin{bmatrix} x \\\\ y \\end{bmatrix} &\n  \\frac{d}{d\\theta} \\begin{bmatrix} x \\\\ y \\end{bmatrix}\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n  \\frac{d}{dr} \\begin{bmatrix} x \\\\ y \\end{bmatrix} &\n  \\frac{d}{d\\theta} \\begin{bmatrix} x \\\\ y \\end{bmatrix}\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n  \\cos\\theta & - r\\sin\\theta \\\\\n  \\sin\\theta &   r\\cos\\theta\n\\end{bmatrix}\n\\]\nなので、ヤコビアンは \\(|J|=r\\) より、\\(dxdy=rdrd\\theta\\)\n例えば、\\((r, \\theta)=(2, \\frac{pi}{4})\\) とすると、以下のようになる。 \\[\nJ \\left(   \\begin{bmatrix} 2 & \\frac{π}{4} \\end{bmatrix}^\\mathrm{T} \\right)=\n=\n\\begin{bmatrix}\n  \\cos \\frac{\\pi}{4} & - 2 \\sin \\frac{\\pi}{4} \\\\\n  \\sin \\frac{\\pi}{4} &   2 \\cos \\frac{\\pi}{4}\n\\end{bmatrix}\n=\n\\frac{1}{\\sqrt{2}}\n\\begin{bmatrix}\n  1 & - 2 \\\\\n  1 &   2\n\\end{bmatrix}\n\\]\n\nT(r, θ) = r * [cos(θ); sin(θ)]\nT(p)    = T(p[1], p[2])\nx0 = [2; π/4]\nForwardDiff.jacobian(T, x0)\n\n2×2 Matrix{Float64}:\n 0.707107  -1.41421\n 0.707107   1.41421\n\n\nプログラムでもちゃんと確認できました。\n\n\n極座標（3-dimention）\n変換によって 極座標平面 \\((r, \\theta, \\phi)\\) を２次元ユークリッド空間 \\(\\begin{bmatrix}x \\\\ y \\\\ z \\end{bmatrix}\\) に変数変換することを考える。\n\\[\n\\begin{bmatrix}x \\\\ y \\\\ z \\end{bmatrix}\n=\nr\n\\begin{bmatrix}\\sin\\theta \\cos\\phi \\\\ \\sin\\theta \\sin\\phi \\\\ \\cos\\theta \\end{bmatrix}\n\\]\nヤコビ行列は、\\(p=\\begin{bmatrix}r \\\\ \\theta \\end{bmatrix}\\) とすると以下のようになる。\nヤコビアンは、\\(|J|=r \\sin^2 \\theta\\) より、\\(dxdydz=r^2 \\sin \\theta dr d \\theta d \\phi\\)\n\nT(r, θ, φ) = r * [sin(θ)*cos(φ); sin(θ)*sin(φ); cos(θ)]\nT(p)       = T(p[1], p[2], p[3])\nx0 = [2; π/4; π/6]\nJ = ForwardDiff.jacobian(T, x0)\n\nusing LinearAlgebra\nr0, θ0, φ0 = x0\nr0^2*sin(θ0) - det(J)\n\n4.440892098500626e-16\n\n\nプログラムでもちゃんと確認できました。"
  },
  {
    "objectID": "page-julia-numericalanalysis-MonteCarlo.html",
    "href": "page-julia-numericalanalysis-MonteCarlo.html",
    "title": "Julia入門「アルゴリズムと数値計算を極める！」",
    "section": "",
    "text": "数値解析の基礎\n\nモンテカルロ法\nモンテカルロ法とは、シミュレーションや数値計算を乱数を用いて行う手法の総称です。 元々は、中性子が物質中を動き回る様子を探るためにスタニスワフ・ウラムが考案しジョン・フォン・ノイマンにより命名された手法です。 カジノで有名な国家モナコ公国の4つの地区（カルティ）の1つであるモンテカルロから名付けられた。ランダム法とも呼ばれます。\n円周率の計算が例として挙げられますが、上記の通りとてもふわふわした定義なので、応用範囲もとても膨大です。\n参考\n\n\nモンテカルロ法で公式を求める\n円周率や四角錐や球などの公式は、数理モデルを上手く予測できれば、モンテカルロ法で簡単に解くことができます。\n\n円の公式を求める\n円の面積の公式を求めたいものとします。 面積は \\(r^2\\) に比例するというモデルを採用し、 \\(A = p r^2\\) という式を予測します。\n円を囲う正方形の面積は、\\(B=4r^2\\) であり、\\(A:B = p:4\\) となることが分かります。\nここで、一様に乱数を \\(B\\) 内部に発生させた場合、その乱数が \\(A\\) に入っている割合は \\(\\frac{A}{B}=\\frac{p}{4}\\) に収束するはずです。\n実際にやってみます。\nまず、乱数を生成します。なお、0~1範囲で考えます。\n\nusing Random, Plots\nRandom.seed!(0)\nn    = 1000\nx, y = rand(n), rand(n)\n\n([0.4552384158732863, 0.5476424498276177, 0.7733535276924052, 0.9405848223512736, 0.02964765308691042, 0.74694291453392, 0.7468008914093891, 0.9766699015845924, 0.32933536727734813, 0.6720006783993265  …  0.7072449674757433, 0.15432438066942566, 0.3355867684577334, 0.11787146264666937, 0.4326256342755368, 0.3263459955343042, 0.5040915702513394, 0.4363318426010223, 0.06184246643407698, 0.5336768573898811], [0.16014320814891514, 0.5011358617291459, 0.018743665453639813, 0.8601828553599953, 0.6556360448565952, 0.7746656838366666, 0.7817315740767116, 0.5553797706980106, 0.6028345068808697, 0.5690620902865082  …  0.6889826593908546, 0.9148951558240528, 0.1436759291283286, 0.5991633714310699, 0.312059069800222, 0.5199998247362753, 0.7200565636157686, 0.05883652803392858, 0.7601316084452316, 0.7233055822178146])\n\n\n次に、プロットして確かめてみます。\n\nt = range(0, 2π, 1000)\nxc = ((r, θ) -&gt; r*cos(θ)).(1, t)\nyc = ((r, θ) -&gt; r*sin(θ)).(1, t)\nplt = plot(\n    xc, yc, \n    xlims=(0, 1), ylims=(0, 1), \n    linewidth = 3, linecolor=:black, \n    aspect_ratio=1.0\n)\nscatter!(plt, x, y)\n\n\n\n\nパラメータ \\(p\\) は以下のように計算できます。\n\n# p / 4 = n' / n\nn_ = sum(x.^2 + y.^2 .&lt; 1)\np  = 4 * n_ / n\np\n\n3.076\n\n\nよって、予測した円の面積の公式は以下の通りです。本来 \\(p=π=3.141...\\) なので、ちょっと惜しい感じですね。\n\\[\nA = 3.076 r^2\n\\]\n\n\n四角錐（正方形を底面とする錐）\n\n数理モデル\n四角錐の体積 \\(A = p h a^2\\)\n囲う境界内部\n立方体の体積 \\(B = 8 h a^2\\)\nよって、\\(\\frac{A}{B} = p\\)\n境界の判定式\n判定式 \\((x + z &lt; 1) \\wedge (y + z &lt; 1), \\;\\;\\; h=a=1\\)\n\n\nRandom.seed!(0)\nn       = 1000\nx, y, z = rand(n), rand(n), rand(n)\n\nn_ = sum((x + z .&lt; 1) .& (y + z .&lt; 1))\n# p = n' / n\np  =  n_ / n\np\n\n0.354\n\n\nよって、予測した球の体積の公式は以下の通りです。本来は \\(p=\\frac{1}{3}=0.333...\\) です。\n\\[\nA = 0.354 h a^2\n\\]\n\n\n球\n\n数理モデル\n球の体積 \\(A = p r^3\\)\n囲う境界内部\n立方体の体積 \\(B = 8 r^3\\)\nよって、\\(\\frac{A}{B} = \\frac{p}{8}\\)\n境界の判定式\n判定式 \\(x^2 + y^2 &lt; r^2\\)\n\n\nRandom.seed!(0)\nn       = 1000\nx, y, z = rand(n), rand(n), rand(n)\n\nn_ = sum(x.^2 + y.^2 + z.^2 .&lt; 1)\n# p / 8 = n_ / n\np  = 8 * n_ / n\np\n\n4.296\n\n\nよって、予測した球の体積の公式は以下の通りです。本来は \\(p=\\frac{4}{3} \\pi=4.188...\\) です。\n\\[\nA = 4.296 r^3\n\\]\n\n\n\nモンテカルロ法で数値積分\n上記の通り、モンテカルロ法は体積や面積を求めるのに使えます。\nこれは積分ができることと同義です。\n\n自然な手法\n※制作中\n\n\nMISER法\n※制作中\n\n\nVEGAS法\n※制作中"
  },
  {
    "objectID": "page-julia-tech-programgen.html",
    "href": "page-julia-tech-programgen.html",
    "title": "Julia入門「アルゴリズムと数値計算を極める！」",
    "section": "",
    "text": "プログラム生成\n※制作中\n\nプログラム生成の手法\n※制作中\n\n\nDSL（ドメイン固有言語）\n汎用型言語（GPL; General Purpose Language）に対して、ドメイン固有言語（DSL; Domain Specific Language）とは、特定の目的に特化した言語です。\n\n\n\nGPL\nC, C++, Fortran, Java, Python, Julia, Lisp\n\n\nDSL\nSQL, HTML, LaTex, Mathematica, gnuplot, Markdown\n\n\n\nまあ、DSLが言語だと言っても、そこまで格式ばった定義があるわけでもなく、プログラムで呼び出す設定ファイル（ini, xml, jsonとか）やパッケージ（JuliaのRandomとか）みたいなものの拡張になっていると思ってください。\nこの、設定ファイルを使う方針が外部言語的なアプローチへと拡張し、パッケージを使う方針が内部言語的なアプローチへと拡張すると考えてください。\nDSLは前述のとおり、普通のプログラム言語の機能拡張が高じたものに過ぎず、PythonやJuliaなどの優秀な言語では目的のための関数が用意されていたり、やり方が明確で少ない行数で書けることもあります。\n重要なのは問題のドメインを見失わないことでしょう。"
  },
  {
    "objectID": "page-julia-complexanalysis-useful.html",
    "href": "page-julia-complexanalysis-useful.html",
    "title": "Julia入門「アルゴリズムと数値計算を極める！」",
    "section": "",
    "text": "複素解析\n\n複素数の便利さ\nあ、この記事は数学の振りした物理とかそっち系の記事だと思ってください。 厳密さが要求される場合、複素数の世界での準備はかなり大変なので、やりません。\n\n\n三角関数と指数関数\n複素数の世界だと、指数関数は三角関数と同じです。\nこのことが、途轍もなく複素数を便利なものだと実感させてくれます。\nまずは、以下の重要な公式（オイラーの公式）があります。 この公式は要は、２次元の実平面 \\(\\mathbb{R}^{2}\\) で単位円上の点の座標を \\(\\begin{bmatrix}\\cos \\theta \\\\ \\sin \\theta \\end{bmatrix}\\) とするのと同じようにして、複素平面上ではこのように表せるよ……って式なのです。\nちなみに、\\(i\\) は虚数単位です。お忘れなく。\n\\[\ne^{i \\theta} = \\cos \\theta + i \\sin \\theta\n\\]\nこれを覚えておけば（当然、指数の知識は要りますが）、面倒くさいサインコサインの公式、微分の公式、積分の公式、全部一瞬で導出できるようになります。\n\n微分\n三角関数の微分は、指数関数の微分から求められます。 幾何学的解釈として、位相を90度ずらすのが微分だと言うこともできます。\n\\[\n\\frac{d}{d \\theta} e^{i \\theta} = i e^{i \\theta} = i (\\cos \\theta + i \\sin \\theta)\n=  - \\sin \\theta + i \\cos \\theta\n\\]\n変形すると、以下のようになります。\n\\[\n\\frac{d}{d \\theta} \\cos \\theta + i \\frac{d}{d \\theta} \\sin \\theta\n=\n- \\sin \\theta + i \\cos \\theta\n\\]\n係数比較すると、以下のようになります。 \\[\n\\frac{d}{d \\theta} \\cos \\theta = - \\sin \\theta, \\;\\;\\;\n\\frac{d}{d \\theta} \\sin \\theta = \\cos \\theta\n\\]\n\n\n積分\n積分はその逆です。\n\\[\n\\int e^{i \\theta} d \\theta= \\frac{1}{i} e^{i \\theta} = - i e^{i \\theta} = - i (\\cos \\theta + i \\sin \\theta)\n=  \\sin \\theta - i \\cos \\theta\n\\]\n変形すると、以下のようになります。\n\\[\n\\int \\cos \\theta d \\theta  + i \\int \\sin \\theta d \\theta\n=\n\\sin \\theta - i \\cos \\theta\n\\]\n比較すると、以下のようになります。 \\[\n\\int \\cos \\theta d \\theta = \\sin \\theta, \\;\\;\\;\n\\int \\sin \\theta d \\theta = -\\cos \\theta\n\\]\n\n\n加法定理\n\\[\ne^{i (\\theta + \\phi)}  = \\cos (\\theta+\\phi) + i \\sin (\\theta + \\phi)\n\\]\n\\[\ne^{i (\\theta + \\phi)} = e^{i \\theta} e^{i \\phi} =\n(\\cos \\theta + i \\sin \\theta)(\\cos \\phi + i \\sin \\phi)\n= (\\cos \\theta \\cos \\phi - \\sin \\theta \\sin \\phi) +\ni (\\cos \\theta \\sin \\phi + \\sin \\theta \\cos \\phi)\n\\]\n比較すると、以下のようになります。 \\[\n\\cos (\\theta+\\phi) = \\cos \\theta \\cos \\phi - \\sin \\theta \\sin \\phi, \\;\\;\\;\n\\sin (\\theta + \\phi) = \\cos \\theta \\sin \\phi + \\sin \\theta \\cos \\phi\n\\]\n\n\n三角関数の性質の式\n三角関数の周期について、ちゃんと覚えてないと、\\(\\frac{\\pi}{2}\\) だけ位相をずらすとどうなるっけ？……的な疑問が出てくることがあります。\n複素数の式を使えば、すぐに導出できます。\n\\[\ne^{i (\\theta + \\frac{\\pi}{2})} = e^{i \\frac{\\pi}{2}} e^{i \\theta} = i e^{i \\theta} = - \\sin \\theta + i \\cos \\theta\n\\]\nよって、比較すると以下のようになります。\n\\[\n\\cos (\\theta + \\frac{\\pi}{2}) = - \\sin \\theta, \\;\\;\\;\n\\sin (\\theta + \\frac{\\pi}{2}) = \\cos \\theta\n\\]\nここで、\\(i = e^{i\\frac{\\pi}{2}}\\) を使っていますが、これは、複素平面上で、\\(\\frac{\\pi}{2}\\) 角度を曲げると \\(i\\) になるというだけの式です。\n他の角度も以下のように、複素数で書けます。\n\\(e^{i \\frac{\\pi}{2}}=i\\), \\(e^{i \\frac{\\pi}{3}}=\\frac{1 + \\sqrt{3}i}{2}\\), \\(e^{i \\frac{\\pi}{4}}=\\frac{1+i}{\\sqrt{2}}\\) など。"
  },
  {
    "objectID": "page-julia-calculus-2.html",
    "href": "page-julia-calculus-2.html",
    "title": "Julia入門「アルゴリズムと数値計算を極める！」",
    "section": "",
    "text": "微分積分\n数学的な厳密性を無視して説明します。\n\n線積分とは\n凄く単純に言えば線積分とは、『線に沿って』積分を行うことです。\n線積分のパラメータとして、以下に曲線を \\(C\\) 、空間の任意のベクトルを \\(\\mathbb{r} \\in \\mathbb{R}^{n}\\) 、\\(C\\) 上の極小の \\(\\mathbb{r}\\) の変位を \\(d\\mathbb{r} \\in \\mathbb{R}^{n}\\) とします。\n\\(d\\mathbb{r}\\) は、その系での座標の表現方法によって、例えば、以下の3つのケースがあると思います。それぞれのケースで以下のような置換を行うことで、積分を計算しやすい形に変換できる可能性があります。\n\n\n媒介変数 \\(\\mathbb{r}=\\mathbb{r}(t)\\)\n\\[\nd\\mathbb{r} = \\frac{d\\mathbb{r}(t)}{dt} dt\n\\]\n\n\n例(曲線の長さ)\n\n\\(\\mathbb{r} = x(t) \\mathbb{i}_x + y(t) \\mathbb{i}_z + z(t) \\mathbb{i}_z\\) と表される曲線 \\(C\\) がある。この曲線の長さについて \\(t \\in [t_0, t_1]\\) の区間内で積分すると，以下の式が得られる。\n\\[\nL = \\int_C |d\\mathbb{r}| = \\int_{t_0}^{t_1} |\\frac{d\\mathbb{r}}{dt}| dt\n  = \\int_{t_0}^{t_1} \\| \\frac{dx}{dt} \\mathbb{i}_x + \\frac{dy}{dt} \\mathbb{i}_y + \\frac{dz}{dt} \\mathbb{i}_z \\| dt\n  = \\int_{t_0}^{t_1} \\sqrt{(\\frac{dx}{dt})^2 + (\\frac{dy}{dt})^2 + (\\frac{dz}{dt})^2} dt\n\\]\n\n\n\n\n\\(y\\) や \\(x\\) が \\(y=f(x)\\) などと関数で表されるケース \\(r=\\left[\\begin{matrix} x \\\\ f(x) \\end{matrix}\\right]\\)\n\\[\nd\\mathbb{r} = \\frac{d\\mathbb{r}}{dx} dx\n\\]\n\n\n例(曲線の長さ)\n\n\\(\\mathbb{r} = \\left[\\begin{matrix} x \\\\ y(x) \\end{matrix}\\right]\\) と表される曲線 \\(C\\) がある。この曲線の長さについて \\(x \\in [x_0, x_1]\\) の区間内で積分すると，以下の式が得られる。\n(これは実質媒介変数と同じ)\n\\[\nL = \\int_C |d\\mathbb{r}| = \\int_{x_0}^{x_1} |\\frac{d\\mathbb{r}}{dx}| dx\n  = \\int_{x_0}^{x_1} |\\left[\\begin{matrix} d(x)/dx \\\\ d(y(x))/dx \\end{matrix}\\right]| dx\n  = \\int_{x_0}^{x_1} \\sqrt{1 + (\\frac{dy(x)}{dx})^2} dx\n\\]\n\n\n\n\n極形式 \\(\\mathbb{r}=Polar(r, \\theta)\\)\n\\[\nd\\mathbb{r}= dr \\mathbb{i}_r + r d\\theta \\mathbb{i}_{\\theta}\n\\]\nなお、\\(\\mathbb{i}_r\\), \\(\\mathbb{i}_{\\theta}\\) はそれぞれ \\(\\mathbb{r}\\) と \\(\\mathbb{r}\\) に直交する接戦方向のベクトルです。\n\n\n例(曲線の長さ)\n\n\\(\\mathbb{r} = r \\mathbb{i}_r + r\\theta \\mathbb{i}_{\\theta}\\) と表される曲線 \\(C\\) がある。この曲線の長さについて \\(x \\in [x_0, x_1]\\) の区間内で積分すると，以下の式が得られる。\n\\[\nL = \\int_C |d\\mathbb{r}| = \\int_{\\theta_0}^{\\theta_1} |dr \\mathbb{i}_r + r d\\theta \\mathbb{i}_{\\theta}|\n  = \\int_{\\theta_0}^{\\theta_1} \\sqrt{dr^2 + (r d\\theta)^2}\n  = \\int_{\\theta_0}^{\\theta_1} \\sqrt{(\\frac{dr}{d\\theta})^2 + r^2} d\\theta\n\\]\n※この導出は数学的には微妙ですが、実際この式で解けます。\n\n\n\n\n\n線積分の公式\n線積分は、ベクトル場やスカラー場を沿って積分する方法です。\n主に物理学や数学で使用され、曲線や経路上のベクトル量やスカラー量を解析するのに役立ちます。 以下では、線積分の基本的な考え方と計算方法について説明します。\n線積分は、スカラー場かベクトル場かの２つの問題形式があります。 また、線分の長さを求める方法についても説明します。\n\nスカラー場の積分\n空間の至る所に値が紐づけされているようなものだと思ってください。 例えば、温度は僕らの生きるこの3次元空間においてそれぞれ違う値をとっています。\nスカラー場の積分は以下の式で表されます。 線の長さが正であることから、 \\(dr\\) には通常絶対値を付けていることに気を付けてください。 \\[\nw = \\int_{C} f(\\mathbb{r}) |d \\mathbb{r}|\n\\]\n\n\nベクトル場の積分\nベクトル場とは、空間の至る所にベクトル値が紐づけされているようなものだと思ってください。 例えば、クーロン力は電荷の位置などで異なる方向に働く力です。\nベクトル場の積分は以下の式で表されます。 \\(d \\mathbb{r}\\) や \\(\\mathbb{F}(\\mathbb{r})\\) はベクトルであることに気を付けてください。(ちなみに、\\(\\cdot\\) は内積です) \\[\n\\mathbb{w} = \\int_{C} \\mathbb{F}(\\mathbb{r}) \\cdot d \\mathbb{r}\n\\]\n\n\n曲線の長さ\n曲線の長さは以下の式で表されます。 \\[\nL = \\int_{C} |d \\mathbb{r}|\n\\]\n\n\n\n線積分の実装\nベクトル場の線積分を自然に実装すると、以下のようになります。\n\nusing LinearAlgebra, ForwardDiff\n\nF(x, y, z) = [z, x, y]\nF(r) = F(r[1], r[2], r[3])\n\nr(t) = [cos(t), sin(t), 3*t]\n\nr (generic function with 1 method)\n\n\n参考"
  },
  {
    "objectID": "page-julia-packages-Gen.html",
    "href": "page-julia-packages-Gen.html",
    "title": "Julia入門「アルゴリズムと数値計算を極める！」",
    "section": "",
    "text": "Juliaのパッケージ\n※Genについては他のサイトを作ってそこで説明します。\nインストールするには、JuliaのREPLでusing Pkg; Pkg.add(\"Gen\")を実行してください。 使いたいタイミングでusing Genと指定して読み込んでください。\n\nusing Gen\n\n\nGenとは？\nMITのグループが開発した、オープンソースの生成モデルと確率的推論のためのパッケージです。 一部、DSL的な記述があります。 できることが多いので、何から手を付けたらいいやら……。\n\nGenは確率的推論アルゴリズムの細かい実装を自動化する。\nトリッキーな数学や低レベルの実装を自動化しながら、ユーザのモデルに併せた効率的な確率的推論アルゴリズムを書くためのブロックを提供します。\nGenはパフォーマンスのトレードオフを柔軟に操作することを可能としています。\nアルゴリズムの一部はユーザの指定する言語やアルゴリズムに置き換えることができます。\nGenはカスタムハイブリッド推論アルゴリズムをサポートします。\nニューラルネットワークによる計算（低コスト）とモデルベースの計算（高コスト）の両方の長所を生かしたアルゴリズムをサポートしています。\nコンパイラを拡張することなく、カスタム推論アルゴリズムを書くことができる。\n確率的構造を持つモデルにおける効率的な推論\n\nWhy Gen\nTutorial\n\n\n生成関数\nGenの@genマクロはDSL（ドメイン固有言語）的な特殊な記述を可能とします。 導入される記述として、以下のような式があります。\n\n{addr} ~ distribution(parameters)\nこの式は、addrというアドレスに対して、ランダムチョイスを生成する確率分布を割り当てることを表しています。\nここで言うアドレスとは、何らかの名前として使う値であり、任意で構いません（多くのサンプルでは、アドレスにSymbolやTupleを使っています）。\n\n生成関数（関数を生成する関数）は以下のように@genマクロを用いて記述できます。 {addr} ~ distribution(parameters)と記述した部分は、値を生成してあとで使用されます。\nここで作る関数は単体ではほとんど意味がなく、変数やパラメータの分布について示しただけのものです。\n\nusing Plots, Random; Random.seed!(0)\n\n@gen function line_model(xs)\n  # 傾き(slope)と切片(intercept)の生成\n  slope     = {:slope}     ~ normal(0, 1) # slope    : mean=0 v=1 の正規分布\n  intercept = {:intercept} ~ normal(0, 2) # intercept: mean=0 v=2 の正規分布\n  # 生成する関数: y(x) = a x + b\n  y(x)      = intercept + slope * x\n  # y: mean=y(xs) v=0.1 の正規分布\n  for (i, x) = enumerate(xs)\n    {(:y, i)} ~ normal(y(x), 0.1)\n  end\n  return y\nend\n\nDynamicDSLFunction{Any}(Dict{Symbol, Any}(), Dict{Symbol, Any}(), Type[Any], false, Union{Nothing, Some{Any}}[nothing], var\"##line_model#312\", Bool[0], false)\n\n\n\n\n関数生成\n点列を与えると、以下のように関数が生成されます。\n\nxs = [-5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5.0]\ny  = line_model(xs)\n\ny (generic function with 1 method)\n\n\n\n\n関数生成のトレース\n関数を生成する際に、トレースという機能を用いると良いです。 この方法では、生成された関数の生成途中で作られた値を参照できます。\n\ntrace = Gen.simulate(line_model, (xs,))\n\nGen.DynamicDSLTrace{DynamicDSLFunction{Any}}(DynamicDSLFunction{Any}(Dict{Symbol, Any}(), Dict{Symbol, Any}(), Type[Any], false, Union{Nothing, Some{Any}}[nothing], var\"##line_model#312\", Bool[0], false), Trie{Any, Gen.ChoiceOrCallRecord}(Dict{Any, Gen.ChoiceOrCallRecord}((:y, 11) =&gt; Gen.ChoiceOrCallRecord{Float64}(-4.388263900849594, 0.8600312321254504, NaN, true), (:y, 3) =&gt; Gen.ChoiceOrCallRecord{Float64}(-0.42127061450108316, 1.3409663803365661, NaN, true), :intercept =&gt; Gen.ChoiceOrCallRecord{Float64}(-1.888778048255967, -2.0580210282113205, NaN, true), (:y, 1) =&gt; Gen.ChoiceOrCallRecord{Float64}(0.6908058367474368, -0.2804310214227761, NaN, true), (:y, 8) =&gt; Gen.ChoiceOrCallRecord{Float64}(-2.9054845706142807, 1.216339171977207, NaN, true), (:y, 7) =&gt; Gen.ChoiceOrCallRecord{Float64}(-2.4893136480645293, 0.6503220335309043, NaN, true), (:y, 5) =&gt; Gen.ChoiceOrCallRecord{Float64}(-1.4522752751776742, 1.2915078761733116, NaN, true), (:y, 6) =&gt; Gen.ChoiceOrCallRecord{Float64}(-1.8912893049811799, 1.3833312392723764, NaN, true), (:y, 10) =&gt; Gen.ChoiceOrCallRecord{Float64}(-3.9060757563192117, 0.8878730243908639, NaN, true), :slope =&gt; Gen.ChoiceOrCallRecord{Float64}(-0.4794303128671186, -1.0338652456526043, NaN, true)…), Dict{Any, Trie{Any, Gen.ChoiceOrCallRecord}}()), false, 7.0686482238402295, 0.0, ([-5.0, -4.0, -3.0, -2.0, -1.0, 0.0, 1.0, 2.0, 3.0, 4.0, 5.0],), var\"#y#11\"{Float64, Float64}(-1.888778048255967, -0.4794303128671186))\n\n\n\n\n関数生成（トレースから）\n以下のいずれかの方法でトレースから関数を生成できます。\n\ny = Gen.get_retval(trace)\n\ny (generic function with 1 method)\n\n\n\ny = trace[]\n\ny (generic function with 1 method)\n\n\n\n\n値の参照（トレースから）\n関数の生成に用いた引数は以下のように取得できます。\n\nxs_get = Gen.get_args(trace)\n\n([-5.0, -4.0, -3.0, -2.0, -1.0, 0.0, 1.0, 2.0, 3.0, 4.0, 5.0],)\n\n\n\n\n乱数の取り出し（トレースから）\n生成の途中で作成したランダムチョイスの値も取り出すことができます。\n\nchoices = Gen.get_choices(trace)\n\n│\n├── (:y, 11) : -4.388263900849594\n│\n├── (:y, 3) : -0.42127061450108316\n│\n├── :intercept : -1.888778048255967\n│\n├── (:y, 1) : 0.6908058367474368\n│\n├── (:y, 8) : -2.9054845706142807\n│\n├── (:y, 7) : -2.4893136480645293\n│\n├── (:y, 5) : -1.4522752751776742\n│\n├── (:y, 6) : -1.8912893049811799\n│\n├── (:y, 10) : -3.9060757563192117\n│\n├── :slope : -0.4794303128671186\n│\n├── (:y, 4) : -0.8052261983375637\n│\n├── (:y, 2) : -0.07688651860452052\n│\n└── (:y, 9) : -3.3193832238801115\n\n\n以下のようにして、一部を参照することも可能です。\n\nchoices[(:y, 2)], choices[:slope]\n\n(-0.07688651860452052, -0.4794303128671186)\n\n\n\n\n事後推論\n※制作中\n\nfunction do_inference(model, xs, ys, amount_of_computation)\n  # ysによりyのとる乱数の値（ランダムチョイス）を観測値に固定する\n  observations = Gen.choicemap()\n  for (i, y) = enumerate(ys)\n    observations[(:y, i)] = y\n  end\n  # 観測値を用いてtraceっぽいものを作成\n  trace, _ = Gen.importance_resampling(\n    model, (xs,), observations, amount_of_computation\n  )\n  return trace\nend\n\ndo_inference (generic function with 1 method)\n\n\n\nxs = [-5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5.0]\nys = [6.75003, 6.1568, 4.26414, 1.84894, 3.09686, \n      1.94026, 1.36411, -0.83959, -0.976, -1.93363, -2.91303];\ntrace = do_inference(line_model, xs, ys, 100)\n\nGen.DynamicDSLTrace{DynamicDSLFunction{Any}}(DynamicDSLFunction{Any}(Dict{Symbol, Any}(), Dict{Symbol, Any}(), Type[Any], false, Union{Nothing, Some{Any}}[nothing], var\"##line_model#312\", Bool[0], false), Trie{Any, Gen.ChoiceOrCallRecord}(Dict{Any, Gen.ChoiceOrCallRecord}((:y, 11) =&gt; Gen.ChoiceOrCallRecord{Float64}(-2.91303, -5.609132072052121, NaN, true), (:y, 3) =&gt; Gen.ChoiceOrCallRecord{Float64}(4.26414, -2.925988887054952, NaN, true), :intercept =&gt; Gen.ChoiceOrCallRecord{Float64}(1.2489702737862338, -1.8070765568648253, NaN, true), (:y, 1) =&gt; Gen.ChoiceOrCallRecord{Float64}(6.75003, -45.18597642040253, NaN, true), (:y, 8) =&gt; Gen.ChoiceOrCallRecord{Float64}(-0.83959, -2.3748427257739793, NaN, true), (:y, 7) =&gt; Gen.ChoiceOrCallRecord{Float64}(1.36411, -50.87472642124648, NaN, true), (:y, 5) =&gt; Gen.ChoiceOrCallRecord{Float64}(3.09686, -42.861720151410005, NaN, true), (:y, 6) =&gt; Gen.ChoiceOrCallRecord{Float64}(1.94026, -22.510427718645825, NaN, true), (:y, 10) =&gt; Gen.ChoiceOrCallRecord{Float64}(-1.93363, -8.570098152239924, NaN, true), :slope =&gt; Gen.ChoiceOrCallRecord{Float64}(-0.9071945926960107, -1.330439547713113, NaN, true)…), Dict{Any, Trie{Any, Gen.ChoiceOrCallRecord}}()), false, -347.77008723965207, 0.0, ([-5.0, -4.0, -3.0, -2.0, -1.0, 0.0, 1.0, 2.0, 3.0, 4.0, 5.0],), var\"#y#11\"{Float64, Float64}(1.2489702737862338, -0.9071945926960107))"
  },
  {
    "objectID": "page-julia-packages-Gen-2.html",
    "href": "page-julia-packages-Gen-2.html",
    "title": "Julia入門「アルゴリズムと数値計算を極める！」",
    "section": "",
    "text": "Juliaのパッケージ\n\nusing Gen, Plots, Random; Random.seed!(0)\n\n\nWriting a probabilistic model as a generative function\n※制作中\nBayesian linear regression\n平面上の点のデータセットがあり、それらの関係を説明するモデルを作成したい。\n僕らはまず「このデータセットはどういう風に作られたんだろうか」と、モデルを推定する必要があります。\nここでは、平面（つまり２次元ユークリッド空間）上で \\(x\\) 軸上の点が \\(y\\) 軸上の点に移るような線形の関係（直線）であると推測しました。\n以下は、与えられた点列xsに対して、適当な設定で作成した線形モデル（生成関数）です。 このモデルは、線を確率的に与えるという以上の意味はないです。\n\n@gen function line_model(xs)\n  # 傾き(slope)と切片(intercept)は精々0から1, 2以上離れないくらいで生成\n  slope     = {:slope} ~ normal(0, 1)\n  intercept = {:intercept} ~ normal(0, 2)\n  # モデルとする式を「y(x) = a x + b」とする。\n  y(x) = slope * x + intercept\n  # y(x)の値を 平均 y(x) 分散 0.1 とした正規分布から生成\n  for (i, x) = enumerate(xs)\n    # addrはiとのタプルで個別に与える\n    {(:y, i)} ~ normal(y(x), 0.1)\n  end\n  return y\nend\n;\n\n例えば、以下ようにの点列xsを与えます。\n\nxs = [-5., -4., -3., -2., -1., 0., 1., 2., 3., 4., 5.];\ny = line_model(xs)\n\ny (generic function with 1 method)\n\n\nline_modelのトレースを見たい場合、simulateによって表示することができます。\n\ntrace = Gen.simulate(line_model, (xs,))\n;\n\ntraceからyを得たい場合、以下のように得ることができます（trace[]でも可能）。\n\nGen.get_retval(trace)\n\ny (generic function with 1 method)\n\n\n関数の実行に用いた引数は以下のように取り出せます。\n\nGen.get_args(trace)\n\n([-5.0, -4.0, -3.0, -2.0, -1.0, 0.0, 1.0, 2.0, 3.0, 4.0, 5.0],)\n\n\nランダムチョイスの値も取り出すことができます。trace[:slope]でも同じように取り出すことができます。\n\nchoices = Gen.get_choices(trace)\nchoices[(:y, 2)], choices[:slope]\n\n(-0.07688651860452052, -0.4794303128671186)\n\n\n\nfunction render_trace(trace; show_data=true)\n  # traceからxsを取り出す\n  xs, = get_args(trace)\n  \n  # traceから生成関数yを取り出す。1\n  y = get_retval(trace)\n  \n  # 生成関数yのグラフの生成\n  test_xs = collect(range(-5, stop=5, length=1000))\n  test_y  = y.(test_xs)\n\n  plt = plot(\n    test_xs, test_y,\n    color=\"black\", alpha=0.5, label=nothing,\n    xlim=(minimum(xs), maximum(xs)), \n    ylim=(minimum(xs), maximum(xs))\n  )\n  \n  # 生成時したデータセットを追加\n  if show_data\n    ys = [trace[(:y, i)] for i=1:length(xs)]\n    scatter!(xs, ys, c=\"black\", label=nothing)\n  end\n  \n  return plt\nend\n\nrender_trace(trace)\n\n\n\n\n\nfunction grid(renderer, traces)\n    Plots.plot(map(renderer, traces)...)\nend\n\n\ntraces = [Gen.simulate(line_model, (xs,)) for _=1:12]\ngrid(render_trace, traces)\n\n\n\n\n\n波のモデル\n※制作中\n\n@gen function sine_model(xs::Vector{Float64})\n  # &lt; your code here, for sampling a phase, period, and amplitude &gt;\n  \n  amplitude = {:amplitude} ~ gamma(1, 1)\n  period    = {:period} ~ gamma(1, 1)\n  phase     = {:phase} ~ uniform(0, 2π)\n  \n  function y(x)\n    #return 1 # &lt; Edit this line to compute y for a given x &gt;\n    return amplitude * sin((2*π/period)*x + phase)\n  end\n    \n  for (i, x) in enumerate(xs)\n    {(:y, i)} ~ normal(y(x), 0.1)\n  end\n    \n  return y # We return the y function so it can be used for plotting, below. \nend;\ntraces = [Gen.simulate(sine_model, (xs,)) for _=1:12];\ngrid(render_trace, traces)\n\n\n\n\n\n\n\nPosterior inference\n※制作中\nここまではある種、前進的な推論をしました。 しかし、ここからは後退的に推論をしたいと思います。\n\\(y\\) 座標のデータセットを用意し、そのデータを生成したプロセスについて推論したいと思います。 まず、次のようなデータセットを用意します。\n\nxs = [-5., -4., -3., -2., -1., 0., 1., 2., 3., 4., 5.]\nys = [6.75003, 6.1568, 4.26414, 1.84894, 3.09686, 1.94026, 1.36411, -0.83959, -0.976, -1.93363, -2.91303];\nscatter(\n  xs, ys, \n  color=\"black\", label=nothing, title=\"Observed data (linear)\", \n  xlabel=\"X\", ylabel=\"Y\"\n)\n\n\n\n\n\nfunction do_inference(model, xs, ys, amount_of_computation)\n    \n    # Create a choice map that maps model addresses (:y, i)\n    # to observed values ys[i]. We leave :slope and :intercept\n    # unconstrained, because we want them to be inferred.\n    observations = Gen.choicemap()\n    for (i, y) in enumerate(ys)\n        observations[(:y, i)] = y\n    end\n    \n    # Call importance_resampling to obtain a likely trace consistent\n    # with our observations.\n    (trace, _) = Gen.importance_resampling(model, (xs,), observations, amount_of_computation);\n    return trace\nend;\n\n\ntrace = do_inference(line_model, xs, ys, 100)\nrender_trace(trace)\n\n\n\n\n\ntraces = [do_inference(line_model, xs, ys, 100) for _=1:10];\ngrid(render_trace, traces)\n\n\n\n\n\nfunction overlay(renderer, traces; same_data=true, args...)\n    fig = renderer(traces[1], show_data=true, args...)\n    \n    xs, = get_args(traces[1])\n    xmin = minimum(xs)\n    xmax = maximum(xs)\n\n    for i=2:length(traces)\n        y = get_retval(traces[i])\n        test_xs = collect(range(-5, stop=5, length=1000))\n        fig = plot!(test_xs, map(y, test_xs), color=\"black\", alpha=0.5, label=nothing,\n                    xlim=(xmin, xmax), ylim=(xmin, xmax))\n    end\n    return fig\nend;\n\ntraces = [do_inference(line_model, xs, ys, 100) for _=1:10];\noverlay(render_trace, traces)\n\n\n\n\n※制作中\nsine_curve model\n\nxs = [-5., -4., -3., -2., -1., 0., 1., 2., 3., 4., 5.]\nys_sine = [2.89, 2.22, -0.612, -0.522, -2.65, -0.133, 2.70, 2.77, 0.425, -2.11, -2.76];\n\nscatter(xs, ys_sine, color=\"black\", label=nothing)\n\n\n\n\n\n\nPredicting new data\n\nconstraints = Gen.choicemap()\nconstraints[:slope] = 0.\nconstraints[:intercept] = 0.\n(trace, _) = Gen.generate(line_model, (xs,), constraints)\nrender_trace(trace)\n\n\n\n\n\nfunction predict_new_data(model, trace, new_xs::Vector{Float64}, param_addrs)\n    \n    # Copy parameter values from the inferred trace (`trace`)\n    # into a fresh set of constraints.\n    constraints = Gen.choicemap()\n    for addr in param_addrs\n        constraints[addr] = trace[addr]\n    end\n    \n    # Run the model with new x coordinates, and with parameters \n    # fixed to be the inferred values.\n    (new_trace, _) = Gen.generate(model, (new_xs,), constraints)\n    \n    # Pull out the y-values and return them.\n    ys = [new_trace[(:y, i)] for i=1:length(new_xs)]\n    return ys\nend;\n\n\npredict_new_data(line_model, trace, [1., 2., 3.], [:slope, :intercept])\n\n3-element Vector{Float64}:\n -0.0953169867456073\n -0.012902515577909127\n  0.1663836598227303\n\n\n\nfunction infer_and_predict(model, xs, ys, new_xs, param_addrs, num_traces, amount_of_computation)\n    pred_ys = []\n    for i=1:num_traces\n        trace = do_inference(model, xs, ys, amount_of_computation)\n        push!(pred_ys, predict_new_data(model, trace, new_xs, param_addrs))\n    end\n    pred_ys\nend;\n\npred_ys = infer_and_predict(line_model, xs, ys, [1., 2., 3.], [:slope, :intercept], 1, 1000)\n\n1-element Vector{Any}:\n [0.7401782081256223, -0.08464311815010521, -1.24765482154271]\n\n\n\nfunction plot_predictions(xs, ys, new_xs, pred_ys; title=\"predictions\")\n    fig = scatter(xs, ys, color=\"red\", label=\"observed data\", title=title)\n    for (i, pred_ys_single) in enumerate(pred_ys)\n        scatter!(new_xs, pred_ys_single, color=\"black\", alpha=0.1, label=i == 1 ? \"predictions\" : nothing)\n    end\n    return fig\nend;\n\nscatter(xs, ys, color=\"red\", label=\"observed data\")\n\n\n\n\n\nnew_xs = collect(range(-5, stop=10, length=100));\n\npred_ys = infer_and_predict(line_model, xs, ys, new_xs, [:slope, :intercept], 20, 1000)\nplot_predictions(xs, ys, new_xs, pred_ys)\n\n\n\n\n\nys_noisy = [5.092, 4.781, 2.46815, 1.23047, 0.903318, 1.11819, 2.10808, 1.09198, 0.0203789, -2.05068, 2.66031];\n\npred_ys = infer_and_predict(line_model, xs, ys_noisy, new_xs, [:slope, :intercept], 20, 1000)\nplot_predictions(xs, ys_noisy, new_xs, pred_ys)\n\n\n\n\n\n@gen function line_model_fancy(xs::Vector{Float64})\n    slope = ({:slope} ~ normal(0, 1))\n    intercept = ({:intercept} ~ normal(0, 2))\n    \n    function y(x)\n        return slope * x + intercept\n    end\n    \n    noise = ({:noise} ~ gamma(1, 1))\n    for (i, x) in enumerate(xs)\n        {(:y, i)} ~ normal(slope * x + intercept, noise)\n    end\n    return y\nend;\n\n\npred_ys = infer_and_predict(line_model, xs, ys, new_xs, [:slope, :intercept], 20, 1000)\nfixed_noise_plot = plot_predictions(xs, ys, new_xs, pred_ys; title=\"fixed noise\")\n\npred_ys = infer_and_predict(line_model_fancy, xs, ys, new_xs, [:slope, :intercept, :noise], 20, 10000)\ninferred_noise_plot = plot_predictions(xs, ys, new_xs, pred_ys; title=\"inferred noise\")\n\nplot(fixed_noise_plot, inferred_noise_plot)\n\n\n\n\n\npred_ys = infer_and_predict(line_model, xs, ys_noisy, new_xs, [:slope, :intercept], 20, 1000)\nfixed_noise_plot = plot_predictions(xs, ys_noisy, new_xs, pred_ys; title=\"fixed noise\")\n\n\npred_ys = infer_and_predict(line_model_fancy, xs, ys_noisy, new_xs, [:slope, :intercept, :noise], 20, 10000)\ninferred_noise_plot = plot_predictions(xs, ys_noisy, new_xs, pred_ys; title=\"inferred noise\")\n\nplot(fixed_noise_plot, inferred_noise_plot)\n\n\n\n\n\nExcersise\n\n@gen function sine_model_fancy(xs::Vector{Float64})\n\n    # &lt; your code here &gt;\n\n    for (i, x) in enumerate(xs)\n        {(:y, i)} ~ normal(0., 0.1) # &lt; edit this line &gt;\n    end\n    return nothing\nend;\n\n\n\n\nCalling other generative functions\n\n@gen function foo()\n    {:y} ~ normal(0, 1)\nend\n\n@gen function bar()\n    {:x} ~ bernoulli(0.5)\n    # Call `foo` with a wildcard address.\n    # Its choices (:y) will appear directly\n    # within the trace of `bar`.\n    {*} ~ foo()\nend\n\n@gen function bar_using_namespace()\n    {:x} ~ bernoulli(0.5)\n    # Call `foo` with the address `:z`.\n    # The internal choice `:y` of `foo`\n    # will appear in our trace at the\n    # hierarchical address `:z =&gt; :y`.\n    {:z} ~ foo()\nend;\n\ntrace = Gen.simulate(bar, ())\nGen.get_choices(trace)\n\n│\n├── :y : 0.17844307899338174\n│\n└── :x : false\n\n\n\ntrace = Gen.simulate(bar_using_namespace, ())\nGen.get_choices(trace)\n\n│\n├── :x : true\n│\n└── :z\n    │\n    └── :y : 1.643956709981543\n\n\n\ntrace[Pair(:z, :y)], trace[:z =&gt; :y]\n\n(1.643956709981543, 1.643956709981543)\n\n\n\n@gen function baz()\n    {:a} ~ bar_using_namespace()\nend\n\ntrace = simulate(baz, ())\n\ntrace[:a =&gt; :z =&gt; :y]\n\n0.12385163525827489\n\n\n\ntrace[Pair(:a, Pair(:z, :y))]\n\n0.12385163525827489\n\n\n\n@gen function combined_model(xs::Vector{Float64})\n    if ({:is_line} ~ bernoulli(0.5))\n        # Call line_model_fancy on xs, and import\n        # its random choices directly into our trace.\n        return ({*} ~ line_model_fancy(xs))\n    else\n        # Call sine_model_fancy on xs, and import\n        # its random choices directly into our trace\n        return ({*} ~ sine_model_fancy(xs))\n    end\nend;\n\n\n#=\ntraces = [Gen.simulate(combined_model, (xs,)) for _=1:12];\ngrid(render_trace, traces)\n=#\n\n\n#=\ntraces = [do_inference(combined_model, xs, ys, 10000) for _=1:10];\nlinear_dataset_plot = overlay(render_trace, traces)\ntraces = [do_inference(combined_model, xs, ys_sine, 10000) for _=1:10];\nsine_dataset_plot = overlay(render_trace, traces)\nPlots.plot(linear_dataset_plot, sine_dataset_plot)\n=#\n\n\n\nModeling with an unbounded number of parameters\nTutorial"
  },
  {
    "objectID": "page-julia-packages-Gen-1.html",
    "href": "page-julia-packages-Gen-1.html",
    "title": "Julia入門「アルゴリズムと数値計算を極める！」",
    "section": "",
    "text": "Juliaのパッケージ\nインストールするには、JuliaのREPLでusing Pkg; Pkg.add(\"Gen\")を実行してください。 使いたいタイミングでusing Genと指定して読み込んでください。\n\nusing Gen\n\n\nGenとは？\nMITが開発した、オープンソースの生成モデルと確率的推論のためのパッケージです。 一部、DSL的な記述があります。 できることが多いので、何から手を付けたらいいやら……。\n\nGenは確率的推論アルゴリズムの細かい実装を自動化する。\nトリッキーな数学や低レベルの実装を自動化しながら、ユーザのモデルに併せた効率的な確率的推論アルゴリズムを書くためのブロックを提供します。\nGenはパフォーマンスのトレードオフを柔軟に操作することを可能としています。\nアルゴリズムの一部はユーザの指定する言語やアルゴリズムに置き換えることができます。\nGenはカスタムハイブリッド推論アルゴリズムをサポートします。\nニューラルネットワークによる計算（低コスト）とモデルベースの計算（高コスト）の両方の長所を生かしたアルゴリズムをサポートしています。\nコンパイラを拡張することなく、カスタム推論アルゴリズムを書くことができる。\n確率的構造を持つモデルにおける効率的な推論\n\nWhy Gen\nTutorial\n\n\n生成関数\nGenの@genマクロはDSL（ドメイン固有言語）的な特殊な記述を可能とします。 導入される記述として、以下のような式があります。\n\n{addr} ~ distribution(parameters)\nこの式は、addrというアドレスに対して、ランダムチョイスを生成する確率分布を割り当てることを表しています。\nここで言うアドレスとは、何らかの名前として使う値であり、任意で構いません（多くのサンプルでは、アドレスにSymbolやTupleを使っています）。\n\n生成関数（関数を生成する関数）は以下のように@genマクロを用いて記述できます。 {addr} ~ distribution(parameters)と記述した部分は、値を生成してあとで使用されます。\nここで作る関数は単体ではほとんど意味がなく、変数やパラメータの分布について示しただけのものです。\n\nusing Plots, Random; Random.seed!(0)\n\n@gen function line_model(xs)\n  # 傾き(slope)と切片(intercept)の生成\n  slope     = {:slope}     ~ normal(0, 1) # slope    : mean=0 v=1 の正規分布\n  intercept = {:intercept} ~ normal(0, 2) # intercept: mean=0 v=2 の正規分布\n  # 生成する関数: y(x) = a x + b\n  y(x)      = intercept + slope * x\n  # y: mean=y(xs) v=0.1 の正規分布\n  for (i, x) = enumerate(xs)\n    {(:y, i)} ~ normal(y(x), 0.1)\n  end\n  return y\nend\n\nDynamicDSLFunction{Any}(Dict{Symbol, Any}(), Dict{Symbol, Any}(), Type[Any], false, Union{Nothing, Some{Any}}[nothing], var\"##line_model#316\", Bool[0], false)\n\n\n\n\n関数生成\n点列を与えると、以下のように関数が生成されます。\n\nxs = [-5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5.0]\ny = line_model(xs)\n\ny (generic function with 1 method)\n\n\n\n\n関数生成のトレース\n関数を生成する際に、トレースという機能を用いると良いです。 この方法では、生成された関数の生成途中で作られた値を参照できます。\n\ntrace = Gen.simulate(line_model, (xs,))\n\nGen.DynamicDSLTrace{DynamicDSLFunction{Any}}(DynamicDSLFunction{Any}(Dict{Symbol, Any}(), Dict{Symbol, Any}(), Type[Any], false, Union{Nothing, Some{Any}}[nothing], var\"##line_model#316\", Bool[0], false), Trie{Any, Gen.ChoiceOrCallRecord}(Dict{Any, Gen.ChoiceOrCallRecord}((:y, 11) =&gt; Gen.ChoiceOrCallRecord{Float64}(-4.388263900849594, 0.8600312321254504, NaN, true), (:y, 3) =&gt; Gen.ChoiceOrCallRecord{Float64}(-0.42127061450108316, 1.3409663803365661, NaN, true), :intercept =&gt; Gen.ChoiceOrCallRecord{Float64}(-1.888778048255967, -2.0580210282113205, NaN, true), (:y, 1) =&gt; Gen.ChoiceOrCallRecord{Float64}(0.6908058367474368, -0.2804310214227761, NaN, true), (:y, 8) =&gt; Gen.ChoiceOrCallRecord{Float64}(-2.9054845706142807, 1.216339171977207, NaN, true), (:y, 7) =&gt; Gen.ChoiceOrCallRecord{Float64}(-2.4893136480645293, 0.6503220335309043, NaN, true), (:y, 5) =&gt; Gen.ChoiceOrCallRecord{Float64}(-1.4522752751776742, 1.2915078761733116, NaN, true), (:y, 6) =&gt; Gen.ChoiceOrCallRecord{Float64}(-1.8912893049811799, 1.3833312392723764, NaN, true), (:y, 10) =&gt; Gen.ChoiceOrCallRecord{Float64}(-3.9060757563192117, 0.8878730243908639, NaN, true), :slope =&gt; Gen.ChoiceOrCallRecord{Float64}(-0.4794303128671186, -1.0338652456526043, NaN, true)…), Dict{Any, Trie{Any, Gen.ChoiceOrCallRecord}}()), false, 7.0686482238402295, 0.0, ([-5.0, -4.0, -3.0, -2.0, -1.0, 0.0, 1.0, 2.0, 3.0, 4.0, 5.0],), var\"#y#55\"{Float64, Float64}(-1.888778048255967, -0.4794303128671186))\n\n\n\n\n関数生成（トレースから）\n以下のいずれかの方法でトレースから関数を生成できます。\n\ny = Gen.get_retval(trace)\n\ny (generic function with 1 method)\n\n\n\ny = trace[]\n\ny (generic function with 1 method)\n\n\n\n\n値の参照（トレースから）\n関数の生成に用いた引数は以下のように取得できます。\n\nxs_get = Gen.get_args(trace)\n\n([-5.0, -4.0, -3.0, -2.0, -1.0, 0.0, 1.0, 2.0, 3.0, 4.0, 5.0],)\n\n\n\n\n乱数の取り出し（トレースから）\n生成の途中で作成したランダムチョイスの値も取り出すことができます。\n\nchoices = Gen.get_choices(trace)\n\n│\n├── (:y, 11) : -4.388263900849594\n│\n├── (:y, 3) : -0.42127061450108316\n│\n├── :intercept : -1.888778048255967\n│\n├── (:y, 1) : 0.6908058367474368\n│\n├── (:y, 8) : -2.9054845706142807\n│\n├── (:y, 7) : -2.4893136480645293\n│\n├── (:y, 5) : -1.4522752751776742\n│\n├── (:y, 6) : -1.8912893049811799\n│\n├── (:y, 10) : -3.9060757563192117\n│\n├── :slope : -0.4794303128671186\n│\n├── (:y, 4) : -0.8052261983375637\n│\n├── (:y, 2) : -0.07688651860452052\n│\n└── (:y, 9) : -3.3193832238801115\n\n\n以下のようにして、一部を参照することも可能です。\n\nchoices[(:y, 2)], choices[:slope]\n\n(-0.07688651860452052, -0.4794303128671186)\n\n\n\n\n\n※制作中"
  },
  {
    "objectID": "page-julia-packages-Gen-3.html",
    "href": "page-julia-packages-Gen-3.html",
    "title": "Julia入門「アルゴリズムと数値計算を極める！」",
    "section": "",
    "text": "Juliaのパッケージ\n\nusing Gen, Plots, Random; Random.seed!(0)\n\nTutorial"
  },
  {
    "objectID": "page-julia-packages-LibSDL.html",
    "href": "page-julia-packages-LibSDL.html",
    "title": "Julia入門「アルゴリズムと数値計算を極める！」",
    "section": "",
    "text": "Juliaのパッケージ\nインストールするには、JuliaのREPLでusing Pkg; Pkg.add(\"LibSDL\")を実行してください。 使いたいタイミングでusing LibSDLと指定して読み込んでください。\n\nLibSDLとは？"
  },
  {
    "objectID": "page-julia-numericalanalysis-Bunchkaufman.html",
    "href": "page-julia-numericalanalysis-Bunchkaufman.html",
    "title": "Julia入門「アルゴリズムと数値計算を極める！」",
    "section": "",
    "text": "数値解析の基礎\n\nBunchkaufmanの方法\nBunchkaufman分解とは、対称行列 \\(A\\) に対する分解の手法です。\nCholesky分解を一般化したもので、以下のように分解する手法です。なお、\\(P\\) は置換行列、\\(L\\) は単位下三角行列（対角成分が1の下三角行列）であり、\\(D\\) はブロック対角行列（行列の対角線上に配置される行列全てが、\\(M_i \\in \\mathbb{R}^n, n=1,2\\) となり他の成分全てが0の行列）です。\n\\[\nA = P L D L^\\mathrm{T} P^\\mathrm{T}\n\\]\n\n\n具体的な手法\n※制作中"
  },
  {
    "objectID": "page-julia-lang-na-1.html",
    "href": "page-julia-lang-na-1.html",
    "title": "Julia入門「アルゴリズムと数値計算を極める！」",
    "section": "",
    "text": "Juliaによる数値計算\n\n行列の分解手法\n\nusing LinearAlgebra, SparseArrays, BenchmarkTools\nn = 100\nm = 30\n\n30\n\n\n\n\n密対称行列( \\(\\frac{\\text{nnz}(A)}{n^2} \\approx 1\\))\n密対称行列に対しては、cholesky, ldltは使用不可能であり、bunchkaufmanが推奨されています。\n\n@time F_factor = factorize(Symmetric(rand(n, n)))\nprintln(typeof(F_factor))\n;\n\n  0.354304 seconds (277.93 k allocations: 14.203 MiB, 8.92% gc time, 94.82% compilation time)\nBunchKaufman{Float64, Matrix{Float64}, Vector{Int64}}\n\n\nこれは、bunchkaufmanを使うと都合が良いと、factorize関数は判断したということです。 実際に高速である保証はありませんので、他のアルゴリズムを使ってみます。\n\nF_lu = lu(Symmetric(rand(n, n)))\nbm1 = @benchmark lu(A) setup = (A = Symmetric(rand(n, n), :L))\nbm2 = @benchmark F_lu \\ b setup = (b = rand(n, m))\ndisplay.([bm1, bm2]);\n\n\nBenchmarkTools.Trial: 3155 samples with 1 evaluation.\n Range (min … max):  798.600 μs …  13.062 ms  ┊ GC (min … max): 0.00% … 82.67%\n Time  (median):       1.450 ms               ┊ GC (median):    0.00%\n Time  (mean ± σ):     1.515 ms ± 470.272 μs  ┊ GC (mean ± σ):  0.41% ±  2.13%\n          ▃▄▅▄▄▆█▇▇▅█▇▇▇▅▅▇▄▃▅▃ ▂                                \n  ▁▁▂▅▄▅▇█████████████████████████▇█▇▆▆▅▄▄▄▅▃▄▃▃▃▂▂▂▂▂▂▂▂▁▂▁▂▂▁ ▅\n  799 μs           Histogram: frequency by time          2.7 ms &lt;\n Memory estimate: 79.08 KiB, allocs estimate: 4.\n\n\n\n\nBenchmarkTools.Trial: 10000 samples with 1 evaluation.\n Range (min … max):   47.700 μs …  15.462 ms  ┊ GC (min … max): 0.00% … 98.16%\n Time  (median):     136.900 μs               ┊ GC (median):    0.00%\n Time  (mean ± σ):   147.712 μs ± 213.602 μs  ┊ GC (mean ± σ):  1.97% ±  1.39%\n          ▁▁▁▃▅▄▆▇▇██▇▆▅▅▅▄▁▂▁                                   \n  ▁▁▁▃▃▄▆▇██████████████████████▆▆▆▅▄▄▄▃▃▃▃▃▂▂▂▂▂▂▁▁▁▁▁▁▁▁▁▁▁▁▁ ▄\n  47.7 μs          Histogram: frequency by time          326 μs &lt;\n Memory estimate: 23.48 KiB, allocs estimate: 2.\n\n\n\n\nF_qr = qr(Symmetric(rand(n, n)))\nbm1 = @benchmark qr(A) setup = (A = Symmetric(rand(n, n), :L))\nbm2 = @benchmark F_qr \\ b setup = (b = rand(n, m))\ndisplay.([bm1, bm2]);\n\n\nBenchmarkTools.Trial: 5795 samples with 1 evaluation.\n Range (min … max):  298.300 μs …  15.637 ms  ┊ GC (min … max): 0.00% … 94.05%\n Time  (median):     741.300 μs               ┊ GC (median):    0.00%\n Time  (mean ± σ):   786.204 μs ± 449.205 μs  ┊ GC (mean ± σ):  1.70% ±  3.41%\n          ▁▃▅▆▆▅▅▇▅█▆▇▅▆▇▅▅▄▆▄▃▃ ▂▁▁                             \n  ▂▃▃▅▅▅████████████████████████████▇█▇▆▆▆▅▅▄▄▄▃▃▃▂▂▂▂▁▂▂▂▂▁▁▁▁ ▅\n  298 μs           Histogram: frequency by time         1.54 ms &lt;\n Memory estimate: 134.55 KiB, allocs estimate: 7.\n\n\n\n\nBenchmarkTools.Trial: 6603 samples with 1 evaluation.\n Range (min … max):  308.100 μs …  19.643 ms  ┊ GC (min … max): 0.00% … 95.61%\n Time  (median):     680.300 μs               ┊ GC (median):    0.00%\n Time  (mean ± σ):   709.771 μs ± 393.219 μs  ┊ GC (mean ± σ):  1.01% ±  2.02%\n             ▁▁▃▅▅▄▆▇▆█▆▇█▇▇▆▆▅▃▂▁▂                              \n  ▁▂▂▁▂▂▃▄▅▇▇██████████████████████▇█▇▆▆▄▅▅▄▃▃▃▃▂▂▂▂▂▂▂▂▂▂▁▁▁▁▁ ▅\n  308 μs           Histogram: frequency by time         1.28 ms &lt;\n Memory estimate: 46.97 KiB, allocs estimate: 4.\n\n\n\n\nF_bunchkaufman = bunchkaufman(Symmetric(rand(n, n)))\nbm1 = @benchmark bunchkaufman(A) setup = (A = Symmetric(rand(n, n), :L))\nbm2 = @benchmark F_bunchkaufman \\ b setup = (b = rand(n, m))\ndisplay.([bm1, bm2]);\n\n\nBenchmarkTools.Trial: 10000 samples with 1 evaluation.\n Range (min … max):   57.600 μs …  17.285 ms  ┊ GC (min … max): 0.00% … 98.88%\n Time  (median):     189.150 μs               ┊ GC (median):    0.00%\n Time  (mean ± σ):   216.802 μs ± 368.886 μs  ┊ GC (mean ± σ):  5.62% ±  3.51%\n       ▂▃▃▃▄▄▇█▆██▇▅▄▅▄▄▅▄▃▂▃▁▁                                  \n  ▂▃▄▅▇████████████████████████▇█▇▆▅▅▅▄▄▄▃▃▃▃▃▃▂▂▂▂▂▂▂▂▁▁▂▂▁▁▁▁ ▅\n  57.6 μs          Histogram: frequency by time          490 μs &lt;\n Memory estimate: 129.22 KiB, allocs estimate: 6.\n\n\n\n\nBenchmarkTools.Trial: 10000 samples with 1 evaluation.\n Range (min … max):   47.600 μs …  18.383 ms  ┊ GC (min … max): 0.00% … 98.86%\n Time  (median):     112.700 μs               ┊ GC (median):    0.00%\n Time  (mean ± σ):   126.967 μs ± 219.633 μs  ┊ GC (mean ± σ):  2.30% ±  1.40%\n      ▅▁▆▅▆▆▆▇▇█▇▅▄▇▃▄▂▂ ▂                                       \n  ▁▂▆█████████████████████▇▇▇▆▆▅▅▄▄▄▃▄▃▃▃▂▂▂▂▂▂▂▂▂▂▂▂▂▂▁▁▁▂▁▂▁▁ ▄\n  47.6 μs          Histogram: frequency by time          304 μs &lt;\n Memory estimate: 23.48 KiB, allocs estimate: 2."
  },
  {
    "objectID": "page-julia-numericalanalysis-MINRES.html",
    "href": "page-julia-numericalanalysis-MINRES.html",
    "title": "Julia入門「アルゴリズムと数値計算を極める！」",
    "section": "",
    "text": "数値解析の基礎\n\nMINRES法（最小残差法）\nMINRES法とは、krylov部分空間法と言われる手法の一つです。\n以下のように、正方対称行列の正規方程式を扱う計算です。\n\\[\nAx = b,\\;\\; A \\in \\mathbb{R}^{n \\times n} :: \\text{Symmetric}\n\\]\n\n\nMINRESの実装\n\nusing LinearAlgebra\n\nシンプルなMINRES法の実装は以下の通りです。 この実装はちゃんと収束しますが、かなりNaiveです。\nまた、実際には、k_maxまでで収束しない場合に解の改善を行うようにすべきですが、この実装は短いコードで作りたかったので削減しています。\n参考\n\nfunction simple_minres(\n      A::AbstractMatrix\n    , b::AbstractMatrix\n    ; k_max = 10\n    , tol   = 1e-7\n    , n     = size(A, 2)\n)\n    pprev, prev, cur, next = 1, 2, 3, 4\n\n    #    k-2           k-1           k             k+1\n    #    -1            0             1             2           (k=1)\n    x = [zeros(n, 1) , rand(n, 1)  , zeros(n, 1) , zeros(n, 1) ]\n    v = [zeros(n, 1) , zeros(n, 1) , b-A*x[prev] , zeros(n, 1) ]\n    β = [0.0         , 0           , norm(v[cur]), 0           ]\n    γ = [0.0         , 1           , 1           , 0           ]\n    σ = [0.0         , 0           , 0           , 0           ]\n    ω = [zeros(n, 1) , zeros(n, 1) , zeros(n, 1) , zeros(n, 1) ]\n    α = [0.0         , 0           , 0           , 0           ]\n\n    rknorm = η = β[cur]\n    \n    for k = 1:k_max\n        v[cur]  = (1 / β[cur])*v[cur]\n        Av      = A*v[cur]\n        α[cur]  = ((v[cur]')*Av)[]\n        v[next] = Av - α[cur]*v[cur] - β[cur]*v[prev]\n        β[next] = norm(v[next])\n        δ       = γ[cur]*α[cur] - γ[prev]*σ[cur]*β[cur]\n        ρ1      = √(δ^2 + β[next]^2)\n        ρ2      = σ[cur]*α[cur] + γ[prev]*γ[cur]*β[cur]\n        ρ3      = σ[prev]*β[cur]\n        γ[next] = δ / ρ1\n        σ[next] = β[next] / ρ1\n        ω[cur]  = (v[cur] - ρ2*ω[prev] - ρ3*ω[pprev]) / ρ1\n        x[cur]  = x[prev] + γ[next]*η*ω[cur]\n        rknorm  = abs(σ[next])*rknorm\n        η       = - σ[next]*η\n\n        if (rknorm &lt; tol) println(\"n_ittr = $k\"); break; end\n\n        pprev, prev, cur, next = prev, cur, next, pprev\n    end\n    return x[prev]\nend\n;\n\n実際，以下のように計算が収束してます．\n\nusing SparseArrays\n\nA = Symmetric(sprand(300, 300, 0.1), :L); \nb = rand(300, 1)\nx = simple_minres(A, b, k_max=1000)\nnorm(b - A * x)\n\nn_ittr = 522\n\n\n1.1240332512060629e-7"
  },
  {
    "objectID": "page-julia-numericalanalysis-Lanczos.html",
    "href": "page-julia-numericalanalysis-Lanczos.html",
    "title": "Julia入門「アルゴリズムと数値計算を極める！」",
    "section": "",
    "text": "数値解析の基礎\n\nLanczos法（Lanczos algorithm）\nLanczos法とは，クリロフ部分空間法の一種です。 対称行列を以下のように三重対角化します。\n\\[\nA = P D P^\\mathrm{T}, \\;\\; AP = PD\n\\]\nなお、固有値の計算などで一般的に３重対角化に用いられる手法はLanczos法ではなく、Householder法です。したがって、Lanczos法はHouseholderが不安定な場合の代替手段などに用いられています。\n\n\nLanczos法のアルゴリズム\n\\(P = [p_1, p_2, \\dots, p_n]\\) とすると、以下のように示されます。\n\\[\nA[p_1, p_2, \\dots, p_n]\n=\n[p_1, p_2, \\dots, p_n]\n\\begin{bmatrix}\n  \\alpha_1 & \\beta_1  &         & & & O \\\\\n  \\beta_1  & \\alpha_2 & \\beta_2 & & & \\\\\n           & \\beta_2  & \\alpha_3& & & \\\\\n           &          &         & \\dots & & \\\\\n           &          &         & & \\alpha_{n-1} & \\beta_{n-1} \\\\\n  O        &          &         & & \\beta_{n-1}  & \\alpha_{n}  \n\\end{bmatrix}\n\\]\nこれらの両辺を比較すると、以下の式が導かれます。\n\\[\n\\begin{matrix}\n  A p_1 = \\alpha_1 p_1 + \\beta_1 p_2 \\\\\n  A p_2 = \\beta_1 p_1 + \\alpha_2 p_2 + \\beta_2 p_3 \\\\\n  A p_3 = \\beta_2 p_2 + \\alpha_3 p_3 + \\beta_3 p_4 \\\\\n  \\dots \\\\\n  A p_{n-1} = \\beta_{n-2} p_{n-2} + \\alpha_{n-1} p_{n-1} + \\beta_{n-1} p_n \\\\\n  A p_n = \\beta_{n-1} p_{n-1} + \\alpha_n p_n\n\\end{matrix}\n\\]\nこれらの式に、 \\(p_1, p_2, p_3, \\dots, p_{n-1}, p_n\\) を左から転置して作用すると、以下の式が得られる。\n\\[\np_k^* A p_k = \\alpha_k\n\\]\nここで、\\(u_1\\) を適当な大きさ \\(1\\) のベクトルとして、初期値として計算していくと、以下の式によって順次 \\(p_k\\) が求められる。\n\\[\np_{k+1} = A p_k - \\beta_{k-1} p_{k-1} - \\alpha_k p_k\n\\]\n直交条件 \\(p_k^* p_k = 1\\) を満たすように、 \\(\\beta_k = \\| v_{k+1} \\|\\) とする。\n\n\nLanczos法の実装\nLanczos法の実装は以下の通りです。※ωとwの違いに気を付けてください。\n\nusing LinearAlgebra\n\nfunction simple_lanczos(\n      A::AbstractMatrix\n    ; n = size(A, 2)\n    , m = n\n)\n    P = zeros(n, n)\n    α = zeros(n)   # diag\n    β = zeros(n) # under diag\n    P[:, 1] .= (x -&gt; x / norm(x))(rand(n, 1))\n\n    w    = A * P[:, 1]\n    α[1] = w' * P[:, 1]\n    ω    = w - α[1] * P[:, 1]\n\n    for k = 2:m\n        β[k] = norm(ω)\n        if β[k] != 0 \n            P[:,k] = ω / β[k]\n        end\n        w = A * P[:, k]\n        α[k] = w' * P[:, k]\n        ω = w - α[k] * P[:, k] - β[k] * P[:, k-1]\n    end\n    D = Tridiagonal(β[begin+1:end], α, β[begin+1:end])\n    return P, D\nend\n;\n\n以下のように、分解がちゃんとできていることが分かります。\n\nA = Symmetric(rand(10, 10))\nP, D = simple_lanczos(A)\n\nnorm(A*P - P*D)\n\n2.7958685463865108e-8"
  },
  {
    "objectID": "page-julia-numericalanalysis-BlockLanczosProcedure.html",
    "href": "page-julia-numericalanalysis-BlockLanczosProcedure.html",
    "title": "Julia入門「アルゴリズムと数値計算を極める！」",
    "section": "",
    "text": "数値解析の基礎\n※制作中ページ\n\nBlock-Lanczos法\nBlock-Lanczosとは、Krylov部分空間法の一種で、\n参考\n\n\nBlock-Lanczos法のアルゴリズム\n\n\nBlock-Lanczos法の実装"
  }
]