[
  {
    "objectID": "page-julia-langbasic-1.html",
    "href": "page-julia-langbasic-1.html",
    "title": "mysite",
    "section": "",
    "text": "Juliaの文法基礎\nプログラミングの構成要素となる型や値、変数などの扱いについてざっくりと列挙しています。 コピーしてREPLで実行してみてください。\n\n値と型\n\n整数(Int64)\n\n8\n\n8\n\n\n\n\n浮動小数点(Float64)\n\n2.0\n\n2.0\n\n\n\n\n文字(Char)\n\n'a'\n\n'a': ASCII/Unicode U+0061 (category Ll: Letter, lowercase)\n\n\n\n\n文字列(String)\n\n\"abc\"\n\n\"abc\"\n\n\n\n\nベクトル(Vector{TYPE})\n\n[1, 2, 5] # [1.0, 2, 5]とすればVector{Float64}型になる\n\n3-element Vector{Int64}:\n 1\n 2\n 5\n\n\n\n\n行列(Matrix{TYPE})\n\n[1 2 3; 2 6 5; 9 3 1; 1 5 1] # どれかの要素をFloat64型にすればMatrix{Float64}型になります。\n\n4×3 Matrix{Int64}:\n 1  2  3\n 2  6  5\n 9  3  1\n 1  5  1\n\n\n\n[1 2 3]\n\n1×3 Matrix{Int64}:\n 1  2  3\n\n\n\n[1; 2; 3]\n\n3-element Vector{Int64}:\n 1\n 2\n 3\n\n\n\n\nタプルNTuple{n, TYPE}\n\n(1, 2, 4, 6)\n\n(1, 2, 4, 6)\n\n\n\n\n辞書型Dict{TYPEA, TYPEB}\n\nDict(\n    \"var1\" => \"hello\",\n    \"var2\" => rand(3, 3)\n)\n\nDict{String, Any} with 2 entries:\n  \"var1\" => \"hello\"\n  \"var2\" => [0.194473 0.483224 0.306724; 0.478429 0.164741 0.723343; 0.384097 0…\n\n\n\n\n\n代入\n\n値1の変数aへの代入\n\na = 1\n\n1\n\n\n\n\n値(\"\", \"2\", 3)を変数(b, c, d)に同時に代入\n\nb, c, d = \"\", \"2\", 3\n\n(\"\", \"2\", 3)\n\n\n\n\n値のスワップ(交換)\n\nx, y = 1, 100\nprintln(\"before: $x $y\")\nx, y = y, x\nprintln(\"after : $x $y\")\n\nbefore: 1 100\nafter : 100 1\n\n\n\n\n\n出力\n\n値の標準出力println\n\ns = \"aaaa\"\nprintln(s)\nprintln(s, \"b\", s) # , で区切ると繋げて表示される\nv = [1, 2, 4]\nprintln(v)\nV = [1 1 2; 5 4 5]\nprintln(V)\n\naaaa\naaaabaaaa\n[1, 2, 4]\n[1 1 2; 5 4 5]\n\n\n\n\n値を整形して表示display\n\ns = \"aaaa\"\ndisplay(s)\nv = [1, 2, 4]\ndisplay(v)\nV = [1 1 2; 5 4 5]\ndisplay(V)\n\n\"aaaa\"\n\n\n3-element Vector{Int64}:\n 1\n 2\n 4\n\n\n2×3 Matrix{Int64}:\n 1  1  2\n 5  4  5\n\n\n\n\n\n四則演算+α\n\n足し算+\n\n1 + 2 + 4\n\n7\n\n\n\n\n引き算-\n\n132 - 451\n\n-319\n\n\n\n\n掛け算*\n\n111 * 222\n\n24642\n\n\n\n\n割り算/\n\n10 / 3.0 # 3.0を3としても動作する\n\n3.3333333333333335\n\n\n\n\n商÷と剰余%\n\n10 ÷ 3, 10 % 3\n\n(3, 1)\n\n\n\n\n累乗^\n\n5 ^ 3\n\n125\n\n\n\n\n平方根sqrt, √\n\nsqrt(13)\n\n3.605551275463989\n\n\n\n\n\n論理演算子\n\nAND演算&, and\n\ntrue & false\n\nfalse\n\n\n\n\nOR演算|\n\ntrue | false\n\ntrue\n\n\n\n\nXOR⊻\n\ntrue ⊻ false\n\ntrue\n\n\n\n\nNOT!\n\n! true\n\nfalse\n\n\n\n\n\n比較演算子\n\n同値==\n\n1 == 1.0 # 型が違う\n\ntrue\n\n\n\n\n～より大きい>=\n\n9.1 >= 0.0\n\ntrue\n\n\n\n\n～より小さい>=\n\n1 <= -1\n\nfalse\n\n\n\n\n～と異なる!=\n\n10 != 10\n\nfalse\n\n\n\n\n\n文字列の演算\n\n結合\n\nx, y = 3, 5\ns1, s2 = \"times\", \"equalsto\"\ns1 = \"$(x) $(s1) $(y) $(s2) $(x*y) !\" \n\n\"3 times 5 equalsto 15 !\"\n\n\n\n\n\n関数の定義\n\n関数の作り方1function ~ end\n\nfunction f1(x, y)\n  println(\"calc: $x ^ $y\")\n  return x ^ y\nend\nf1(5, 3)\n\ncalc: 5 ^ 3\n\n\n125\n\n\n\n\n関数の作り方2f(...)=...\n\nf2(x, y) = x ^ y\nf2(5, 3)\n\n125\n\n\n\n\n関数の作り方3f = (...) -> (...)\n\nf3 = (x, y) -> x ^ y\nf3(5, 3)\n\n125\n\n\n\n\nキーワード変数function f(...;...)\n※文字列を生成した後に表示しているため、表示の順序に注意\n\nfunction f4(x, y; c=1)\n  println(\"calc: $c * $x ^ $y\")\n  return c * x ^ y\nend\nprintln(\"$(f4(5, 3)) $(f4(5, 3, c=2))\")\n\ncalc: 1 * 5 ^ 3\ncalc: 2 * 5 ^ 3\n125 250\n\n\n\n\n\nブロードキャスト\n\nベクトルと定数の間の四則演算\n他の計算も大抵同じことができます\n\nv, a = [1.0, 2, 3], 3\n\nv1   = v .+ a # それぞれの要素に足し算\nv2   = v .- a # 　　　　　　　　引き算\nv3   = v .* a # 　　　　　　　　掛け算\nv4   = v ./ a # 　　　　　　　　割り算\n\nprintln(v1, v2, v3, v4)\n\n[4.0, 5.0, 6.0][-2.0, -1.0, 0.0][3.0, 6.0, 9.0][0.3333333333333333, 0.6666666666666666, 1.0]\n\n\n\n\n関数に対しても……\n\n# f(x) = x^2\nfunction f(x)\n  return x ^ 2\nend\nprintln(f.([1, 2, 3, 5]))\n\n[1, 4, 9, 25]\n\n\n\n\n2変数関数に対しても……\n\nf(x, y) = x^y\n\nl1 = f.([1, 2, 3, 4], 2)\nl2 = f.(2, [1, 2, 3, 4])\n\ndisplay.([l1', l2']);\n\n1×4 adjoint(::Vector{Int64}) with eltype Int64:\n 1  4  9  16\n\n\n1×4 adjoint(::Vector{Int64}) with eltype Int64:\n 2  4  8  16\n\n\n\n\n多次元データのブロードキャスト\n\nf(x) = 3*x + 1\nf.([1 2 3; 4 5 6])\n\n2×3 Matrix{Int64}:\n  4   7  10\n 13  16  19"
  },
  {
    "objectID": "page-julia-langbasic-2.html",
    "href": "page-julia-langbasic-2.html",
    "title": "mysite",
    "section": "",
    "text": "Juliaの文法基礎\n\nif文\nif文は真理値(以下の(x == 0):: Bool)がtrueのとき内部のコードを実行します。\nif 真理値\n  コード\nend\n実際の例は以下の通りです：\n\n# x が 0 と等しい場合にそれを出力します。\nx = 0\nif x == 0 # x == 0 は比較演算子の返り値＝真理値型\n  println(\"$(x)と0は同じ値です\")\nend\n\n0と0は同じ値です\n\n\nif ~ else文は真理値がtrueのとき内部のコード1を実行し、それ以外の場合にelseの内部のコード2を実行します。\nif 真理値\n  コード1\nelse\n  コード2\nend\n実際の例は以下の通りです：\n\nx = 0\nif x == 0\n  println(\"$(x)と0は同じ値です\")\nelse\n  println(\"$(x)と0は異なります\")\nend\n\n0と0は同じ値です\n\n\n\nx = 1\nif x == 0\n  println(\"$(x)と0は同じ値です\")\nelse\n  println(\"$(x)と0は異なります\")\nend\n\n1と0は異なります\n\n\nif ~ elseif ~ else文は真理値1がtrueのときコード1を実行し、真理値k-1までがfalseのとき、真理値kがtrueならばコードkを実行します。また、真理値nまで実行してコードが全部実行できなかったとき、elseの内部のコードn+1を実行します。\nまあ要するに、上から順番にどの条件が真になるかを確かめて、実行していく感じです。\nif     真理値1\n  コード1\nelseif 真理値2\n  コード2\n...\nelseif 真理値k-1\n  コードk-1\nelseif 真理値k\n  コードk\n...\nelseif 真理値n\n  コードn\nelse \n  コードn+1\nend\n実際の例は以下の通りです：\n\nx = -3\nif x == 0\n  println(\"$(x)と0は同じ値です\")\nelseif -3 < x <= 3\n  println(\"$(x)は、集合(-3,+3]に含まれます\")\nelse\n  println(\"$(x)は集合(-∞, -3]と(+3, ∞)の和集合に含まれます\")\nend\n\n-3は集合(-∞, -3]と(+3, ∞)の和集合に含まれます\n\n\n\n\nfor文\nfor文は、n回連続で『似た』処理を実行したいときに使います。 何かの順番を持つオブジェクト（イテレーティブオブジェクト）に応じて、順次、内部のコード(i)を実行します。\nfor i = イテレーティブオブジェクト\n  コード(i)\nend\n\n# iとi^2をnまで足し合わせるプログラム\nn = 0\nk = 0\nfor i = 1:10 # UnitRange型オブジェクト\n  k = k + i\n  n = n + i^2\nend\nprintln(\"$n, $k\")\n\n385, 55\n\n\nベクトルでもできます。勿論、タプルでも……。\n\nn = 0\nk = 0\nfor i = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n  k = k + i\n  n = n + i^2\nend\nprintln(\"$n, $k\")\n\n385, 55\n\n\nベクトルとか行列を作りたいとき、for文を使った内包表記という書き方ができます。\n\n# 1から10まで、2乗の和を計算する\n[i^2 for i = 1:10]\n\n10-element Vector{Int64}:\n   1\n   4\n   9\n  16\n  25\n  36\n  49\n  64\n  81\n 100\n\n\n\n\nwhile文\nwhile文は真理値がtrueの間に限り内部のコードが実行されるループです。\nwhile 真理値\n  コード\nend\n\n# n^2の和を合計が1000を越えるまで足していく。\nn = 0\nN = 0\nwhile N < 1000\n  N = N + n^2\n  n = n + 1\nend\nprintln(\"0 から $(n-1) までの値の2乗の和は $N となる\")\n\n0 から 14 までの値の2乗の和は 1015 となる\n\n\n\n\ncontinue文\ncontinueはループfor, whileの内部のコードをその回の終了までスキップします。\n\n# １～１０までの間で偶数だけを出力する\nfor i = 1:10\n  if i % 2 == 1 \n    continue\n  end\n  println(\"$i は偶数です\")\nend\n\n2 は偶数です\n4 は偶数です\n6 は偶数です\n8 は偶数です\n10 は偶数です\n\n\n\n\nbreak文\nbreakはループfor, whileをその場で抜けます。\n\nfor i = 1:10\n  if i == 7\n    break\n  end\n  println(\"$i は 7 未満です\")\nend\n\n1 は 7 未満です\n2 は 7 未満です\n3 は 7 未満です\n4 は 7 未満です\n5 は 7 未満です\n6 は 7 未満です"
  },
  {
    "objectID": "page-julia-langbasic-3.html",
    "href": "page-julia-langbasic-3.html",
    "title": "mysite",
    "section": "",
    "text": "Juliaの文法基礎\n\n行列の使い方\n\n行列（自分で値を決めて）\n値を自分で決めて行列を作る場合、以下のようにしてください。\n\nA = [\n  1 2 4;\n  6 7 3;\n  2 2 9;\n  0 5 0.0\n]\n\n4×3 Matrix{Float64}:\n 1.0  2.0  4.0\n 6.0  7.0  3.0\n 2.0  2.0  9.0\n 0.0  5.0  0.0\n\n\n\n\n初期化された行列\n0で初期化された行列を作るには、以下のようにしてください。\n\nA = zeros(2, 2)\n\n2×2 Matrix{Float64}:\n 0.0  0.0\n 0.0  0.0\n\n\n\n\n任意行列\n中身が何でも良い適当な行列を作りたい場合は、以下のようにしてください。\n\nA = rand(3, 5)\n\n3×5 Matrix{Float64}:\n 0.220238  0.957616  0.974877  0.385393  0.891681\n 0.334465  0.987858  0.130555  0.583025  0.943827\n 0.915218  0.908973  0.409851  0.423888  0.721225\n\n\n\n\n単位行列\n単位行列を作りたい場合は、以下のようにしてください。 型を指定しない場合、Boolの行列になってしまいます。\n\nusing LinearAlgebra\nE = Matrix{Float64}(I, 3, 3)\n\n3×3 Matrix{Float64}:\n 1.0  0.0  0.0\n 0.0  1.0  0.0\n 0.0  0.0  1.0\n\n\n\n\n行列の表示\nprintlnよりもdisplayで表示した方が見やすいので、小さい行列はそうやって表示しましょう。\n\nA = rand(3, 3)\ndisplay(A)\n\n3×3 Matrix{Float64}:\n 0.579375  0.072156  0.930005\n 0.381244  0.312008  0.0840836\n 0.637532  0.503068  0.539931\n\n\n\n\n行列の型\n行列に限らず……ですが、typeof関数でどういう型になっているかを調べることができます。\n\nA = rand(ComplexF64, 10, 10)\ntypeof(A)\n\n\nMatrix{ComplexF64} (alias for Array{Complex{Float64}, 2})\n\n\n\n\n\n\n行列の参照\n説明のため、\\(9 \\times 9\\) サイズの行列を作りました。 この行列は九九の表を表してます。 効率的に覚えるため(？)、下半分を削りました。\n※なんでこうなるかは取り敢えず無視してください。\n\na = [1, 2, 3, 4, 5, 6, 7, 8, 9]\nA = (M -> M - tril(M, -1))(a * a')\n\n9×9 Matrix{Int64}:\n 1  2  3   4   5   6   7   8   9\n 0  4  6   8  10  12  14  16  18\n 0  0  9  12  15  18  21  24  27\n 0  0  0  16  20  24  28  32  36\n 0  0  0   0  25  30  35  40  45\n 0  0  0   0   0  36  42  48  54\n 0  0  0   0   0   0  49  56  63\n 0  0  0   0   0   0   0  64  72\n 0  0  0   0   0   0   0   0  81\n\n\n\n特定の行（列）のベクトルとしての参照\n特定の行だけ取り出し、ベクトルとして参照したいときは、以下のようにしてください。\n\nx = A[1, :]\n\n9-element Vector{Int64}:\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n\n\n特定の列だけ取り出し、ベクトルとして参照したいときは、以下のようにしてください。\n\nx = A[:, 2]\n\n9-element Vector{Int64}:\n 2\n 4\n 0\n 0\n 0\n 0\n 0\n 0\n 0\n\n\n\n\n特定の行（列）の参照\n特定の行だけ取り出したいときは、以下のようにしてください。（行列として参照されます）\n\nx = A[1:1, :]\n\n1×9 Matrix{Int64}:\n 1  2  3  4  5  6  7  8  9\n\n\n特定の列だけ取り出したいときは、以下のようにしてください。\n\nx = A[:, 2:2]\n\n9×1 Matrix{Int64}:\n 2\n 4\n 0\n 0\n 0\n 0\n 0\n 0\n 0\n\n\n\n\n複数行（列）をまとめて取り出したい\n特定の連続する数行だけ取り出したいときは、以下のようにしてください。\n\nx = A[5:8, :]\n\n4×9 Matrix{Int64}:\n 0  0  0  0  25  30  35  40  45\n 0  0  0  0   0  36  42  48  54\n 0  0  0  0   0   0  49  56  63\n 0  0  0  0   0   0   0  64  72\n\n\n特定の連続する数列だけ取り出したいときは、以下のようにしてください。\n\nx = A[:, 2:5]\n\n9×4 Matrix{Int64}:\n 2  3   4   5\n 4  6   8  10\n 0  9  12  15\n 0  0  16  20\n 0  0   0  25\n 0  0   0   0\n 0  0   0   0\n 0  0   0   0\n 0  0   0   0\n\n\n\n\n小行列の参照\n\nx = A[5:8, 2:5]\n\n4×4 Matrix{Int64}:\n 0  0  0  25\n 0  0  0   0\n 0  0  0   0\n 0  0  0   0\n\n\n\n\n行と列を複数個指定して参照\n\nx = A[[1, 5, 6], [1, 3, 4, 9]]\n\n3×4 Matrix{Int64}:\n 1  3  4   9\n 0  0  0  45\n 0  0  0  54\n\n\n\n\n\n行列への代入\n参照した行列に代入することができます。 .=でなくて=でも代入できますが、メモリを気にするときは.=を使ってください。\n例えば、以下のようにしてください。\n\nA[[1, 5, 6], [1, 3, 4, 9]] .= zeros(3, 4)\nA\n\n9×9 Matrix{Int64}:\n 0  2  0   0   5   6   7   8   0\n 0  4  6   8  10  12  14  16  18\n 0  0  9  12  15  18  21  24  27\n 0  0  0  16  20  24  28  32  36\n 0  0  0   0  25  30  35  40   0\n 0  0  0   0   0  36  42  48   0\n 0  0  0   0   0   0  49  56  63\n 0  0  0   0   0   0   0  64  72\n 0  0  0   0   0   0   0   0  81"
  },
  {
    "objectID": "page-julia-langwiredpart.html",
    "href": "page-julia-langwiredpart.html",
    "title": "mysite",
    "section": "",
    "text": "Juliaの文法基礎\n\nJuliaの変なところ\nJuliaは非常に便利な言語です。 それを支えている部分ではあるのですが、他のプログラム言語と比較して、少し変な部分もあります。\nいくつかご紹介します。\n\n\nUnicodeのサポート（ひらがなも使える）\nJuliaでは大抵のUnicode文字が使えます。 便利か不便かは人によると思いますが、奇妙なのは間違いないと思います。\n英語を使うのに慣れていない人（超初心者や小学生など）にプログラミングを説明するのに向いてるかも？\n例えば、ひらがなや漢字を使って変数を定義する以下のようなプログラムも動いてしまいます。\n\n# おまじない（関数に別名を付ける）\n表示して = println\n足す,引く,掛ける,割る = +,-,*,/\n\n# やってみる（実際に動くコードの例）\nこれは２かな = 足す(1, 1)\n表示して( これは２かな )\n言いたいこと = \"ハローワールド!\"\n表示して( 言いたいこと )\n\n2\nハローワールド!\n\n\nα, βなども含め、他のUnicode文字も使えます。\nそのため、表現力の面ではJuliaは相当強いです。\n\n\n柔軟な型システム\nJuliaは強力な型システムを持っていますが、静的な型宣言が必須ではありません。 関数や変数に明示的な型注釈を付けることもできますが、Juliaは型推論によって自動的に型を推測することもできます。\nこれにより、動的なタイピングと静的なタイピングのメリットを組み合わせた柔軟なプログラミングが可能になります。\n※Integer型の行列にFloat型の値を入れたり演算をすることはできません。pythonより少しだけ型にうるさい言語だと思っておきましょう。\n\nx::Integer = 1; println(x)\ny::Float64 = 1; println(y)\nz = 1\n\n1\n1.0\n\n\n1\n\n\n\n\n配列のインデックス\nJuliaの配列のインデックスは、一般的なプログラミング言語とは異なり、1から始まります。 多くの言語では0から始まるインデックスが一般的ですが、Juliaでは数学的な表記に近い1から始まるインデックスが採用されています。\n同じような言語として、Fortranがあります。 JuliaはFortran技術者にとっては良い言語かもしれません。\nこれは好みの問題ですが、数学的に自然なプログガムが書けるので個人的には気に入ってます。\n\na = [1, 2, 3, 4]\na[1]\n\n1\n\n\n\n\nブロードキャスト\nJuliaは、要素ごとの演算をベクトル化して高速化することが得意です。 これにより、ループを使わずにコードを記述し、高速な計算を行うことができます。 また、Juliaのブロードキャスト機能を使用すると、異なるサイズや形状の配列の間で要素ごとの演算を行うことができます。\nループを平坦化する（ネストを減らす）ことは、可読性向上の為に重要な意味があります。 余計なループは排除しましょう。\n\n# 1:10までの数字の逆数を計算する。\n1.0 ./ (1:10)\n\n10-element Vector{Float64}:\n 1.0\n 0.5\n 0.3333333333333333\n 0.25\n 0.2\n 0.16666666666666666\n 0.14285714285714285\n 0.125\n 0.1111111111111111\n 0.1\n\n\n\n# 1:10までの数字の3乗を計算する。\nf(x) = x^3\nf.(1:10)\n\n10-element Vector{Int64}:\n    1\n    8\n   27\n   64\n  125\n  216\n  343\n  512\n  729\n 1000\n\n\n\n\n多重ディスパッチ\nJuliaの型システムには多重ディスパッチと呼ばれる機能があります。 これにより、関数が引数の型に基づいて自動的に異なる実装を選択することができます。\nこの機能は、同じ操作を異なる型に対して一貫して適用する場合に特に有用です。\n\n# 同じ数字を並べて大きな数字を作る\nfunction concat(x::Int, n::Int)\n    if n == 0\n        return 0\n    end\n    return x + 10 * concat(x, n-1)\nend\n\n# 同じ文字を並べて大きな文字列を作る\nfunction concat(x::Union{AbstractChar, AbstractString}, n::Int)\n    if n == 0\n        return \"\"\n    end\n    return x*concat(x, n-1)\nend\n\ndisplay.(\n    [concat(1, 5), concat(\"a\", 4)]\n)\n;\n\n11111\n\n\n\"aaaa\""
  },
  {
    "objectID": "page-julia-linearalgebra-1.html",
    "href": "page-julia-linearalgebra-1.html",
    "title": "mysite",
    "section": "",
    "text": "線形代数\n\n行列とは？\n行列は、数値や変数を配列したものです。 行と列からなる2次元のデータ構造で、さまざまな分野で広く使用されています。\n一般的な行列は、以下のように表現されます: \\[\n\\begin{bmatrix}\na_{11} & a_{12} & \\ldots & a_{1n} \\\\\na_{21} & a_{22} & \\ldots & a_{2n} \\\\\n\\vdots & \\vdots & \\ddots & \\vdots \\\\\na_{m1} & a_{m2} & \\ldots & a_{mn} \\\\\n\\end{bmatrix}\n\\]\n行列における加減乗除は、以下のように計算できます。\n\nA = [\n    1 2  1;\n    4 5 -2;\n    3 2 1.0\n]\nB = [\n    -1 5  6;\n     4 3 -7;\n     2 4 9.0\n]\n;\n\n行列の和\n\nA + B\n\n3×3 Matrix{Float64}:\n 0.0  7.0   7.0\n 8.0  8.0  -9.0\n 5.0  6.0  10.0\n\n\n行列の差\n\nA - B\n\n3×3 Matrix{Float64}:\n 2.0  -3.0  -5.0\n 0.0   2.0   5.0\n 1.0  -2.0  -8.0\n\n\n行列の積\n\nA * B\n\n3×3 Matrix{Float64}:\n  9.0  15.0    1.0\n 12.0  27.0  -29.0\n  7.0  25.0   13.0\n\n\n行列の除算(逆行列の作用)\n\nA \\ B\n\n3×3 Matrix{Float64}:\n  1.5       -0.5       1.5\n -0.777778   1.77778  -0.444444\n -0.944444   1.94444   5.38889\n\n\n行列の転置\n\nA'\n\n3×3 adjoint(::Matrix{Float64}) with eltype Float64:\n 1.0   4.0  3.0\n 2.0   5.0  2.0\n 1.0  -2.0  1.0\n\n\n\n\n行列の便利さ\n線形代数における行列は非常に重要です。 行列は、数値の集合を整理し、ベクトルや線形写像の表現や解析に利用されます。 以下に、行列の重要性をいくつか説明します。\n※内容について詳しく理解する必要はありません。\n\n線形写像の表現\n行列は線形写像を表現するための重要な道具です。 線形写像はベクトル空間から別のベクトル空間への線形な変換を表すものであり、例えば、以下のような表現ができます。 \\[ f(x) = Ax \\] \\[g \\bullet f(x) = BAx \\]\n線形方程式の解法\n行列は線形方程式の解法にも使用されます。 線形方程式は未知の変数に関する線形な等式の集合です。 \\[ Ax = b \\]\n固有値と固有ベクトル\n行列の固有値と固有ベクトルは、線形写像の特性を表す重要な概念です。 固有値とは、線形写像がベクトルに対して与える変換のスケールを表し、固有ベクトルはそのスケールが現れる方向を表します。行列の固有値と固有ベクトルを求めることで、線形写像の性質や変換の効果を理解することができます。固有値分解や特異値分解などの手法も、行列の固有値と固有ベクトルを利用しています。 \\[ Ax=\\lambda x \\]\nデータ解析と機械学習\n行列はデータ解析や機械学習の分野でも広く利用されます。例えば、多次元データを行列の形で表現することで、特徴ベクトルや特徴行列を得ることができます。これにより、データの類似性や相関関係を解析したり、機械学習アルゴリズムによるパターン識別や予測を行うための入力として利用することができます。また、行列の演算や変換を用いて、データの次元削減や特徴抽出などの処理も行われます。\n線形独立性と行列のランク\n行列の線形独立性と行列のランクは、ベクトルや行列の性質を理解する上で重要な概念です。行列の線形独立性は、ベクトルや行列の組が線形的に独立しているかどうかを示し、行列のランクはその独立な列または行の最大の数を表します。線形独立性とランクは、行列の性質や特徴を解析する際に役立ちます。\n\n\n\n有名な行列\n一般的な名前のついた行列について、可能な限り網羅します。 また、その性質についても説明します。\n\nゼロ行列（Zero Matrix）：すべての要素が0の行列です。\nゼロ行列は行列演算の加法単位元(「……？」って人はとりあえず無視)です。\nJuliaでのゼロ行列の作成方法は次の通りです。\n\nusing LinearAlgebra\n# 3x3のゼロ行列\nO = zeros(3, 3)\nO\n\n3×3 Matrix{Float64}:\n 0.0  0.0  0.0\n 0.0  0.0  0.0\n 0.0  0.0  0.0\n\n\n\n任意の行列Aとゼロ行列Oの和は元の行列Aと等しくなります。 \\[ A+O = O+A \\]\n任意の行列Aとゼロ行列Oの積はゼロ行列となります。 \\[ AO = OA = O \\]\nゼロ行列は任意のスカラー倍によってゼロ行列となります。 \\[ cO = Oc = O, c \\in \\mathbb{R} \\]\n\n\n\n単位行列（Identity Matrix）：主対角線上の要素がすべて1で、それ以外の要素が0の行列です。\n単位行列はは行列演算の乗法単位元です。\nJuliaでの単位行列の作成方法は次の通りです。\n\n# 3x3の単位行列\nE = Matrix{Float64}(I, 3, 3)\nE\n\n3×3 Matrix{Float64}:\n 1.0  0.0  0.0\n 0.0  1.0  0.0\n 0.0  0.0  1.0\n\n\n\n任意の行列Aと単位行列Iの積は元の行列Aと等しくなります。 \\[ A * I = I * A = A \\]\n単位行列を任意の非負定数乗すると、同じ単位行列が得られます。 \\[ I^n = I \\]\n逆行列は単位行列となる。 \\[ II^{-1} = I^{-1}I = I \\]\n単位行列は、対称行列である。\n\n\n\n対角行列（Diagonal Matrix）：主対角線上以外の要素がすべて0で、主対角線上の要素が非ゼロの行列です。\nJuliaでの対角行列の作成方法は次の通りです。\n\n# 3x3の対角行列（対角要素：1, 2, 3）\nD = Diagonal([1, 2, 3])\nD\n\n3×3 Diagonal{Int64, Vector{Int64}}:\n 1  ⋅  ⋅\n ⋅  2  ⋅\n ⋅  ⋅  3\n\n\n\n\n対称行列（Symmetric Matrix）：転置しても元の行列と等しい行列です。主対角線を中心に対称な要素を持ちます。\nJuliaでの対称行列の作成方法は次の通りです。\n\n# 3x3の対称行列\nSym = Symmetric(\n    [1 2 3;\n     2 4 5;\n     3 5 6]\n)\nSym\n\n3×3 Symmetric{Int64, Matrix{Int64}}:\n 1  2  3\n 2  4  5\n 3  5  6\n\n\n\n転置した行列と等しい。 \\[ D^\\mathrm{T} = D \\]\n対称行列の和は対称行列になる。 \\[ (D_1 + D_2)D_1^\\mathrm{T} = D_1 + D_2 \\]\n要素全てが実数のエルミート行列である。\n\n\n\n上三角行列（Upper Triangular Matrix）：主対角線より下の要素がすべて0である行列です。\nJuliaでの上三角行列の作成方法は次の通りです。\n\n# 3x3の上三角行列（対角要素：1, 2, 3）\nUT = UpperTriangular(\n    [1 2 3; \n     0 4 5; \n     0 0 6]\n)\nUT\n\n3×3 UpperTriangular{Int64, Matrix{Int64}}:\n 1  2  3\n ⋅  4  5\n ⋅  ⋅  6\n\n\n\n\n下三角行列（Lower Triangular Matrix）：主対角線より上の要素がすべて0である行列です。\nJuliaでの下三角行列の作成方法は次の通りです。\n\n# 3x3の下三角行列（対角要素：1, 2, 3）\nLT = LowerTriangular(\n    [1 0 0;\n     2 3 0;\n     4 5 6]\n)\nLT\n\n3×3 LowerTriangular{Int64, Matrix{Int64}}:\n 1  ⋅  ⋅\n 2  3  ⋅\n 4  5  6\n\n\n\n\nエルミート行列（Hermitian Matrix）：転置共役しても元の行列と等しい行列です。主対角線を中心にエルミート（共役転置）な要素を持ちます。\nJuliaでのエルミート行列の作成方法は次の通りです。\n\n# 3x3のエルミート行列\nHermit = Hermitian(\n    [1     2+3im 4-1im;\n     2-3im 5     6+2im;\n     4+1im 6-2im 7     ]\n)\nHermit\n\n3×3 Hermitian{Complex{Int64}, Matrix{Complex{Int64}}}:\n 1+0im  2+3im  4-1im\n 2-3im  5+0im  6+2im\n 4+1im  6-2im  7+0im\n\n\n\n\nフロベニウス行列（Frobenius Matrix）：非負整数の正方行列で、各行の要素が行番号と列番号の積と等しい行列です。\nJuliaでのフロベニウス行列の作成方法は次の通りです。\n\nusing SpecialMatrices\n# 3x3のフロベニウス行列\nFrobenius(3, [1, 2, 3])\n\n6×6 Frobenius{Int64}:\n 1  0  0  0  0  0\n 0  1  0  0  0  0\n 0  0  1  0  0  0\n 0  0  1  1  0  0\n 0  0  2  0  1  0\n 0  0  3  0  0  1\n\n\n\n\n巡回行列（Circulant Matrix）：行列の各行が循環的にシフトされた結果得られる行列です。\nJuliaでの巡回行列の作成方法は次の通りです。\n\nusing ToeplitzMatrices\n# 3x3の巡回行列\nCirculant([1, 2, 3])\n\n3×3 Circulant{Int64, Vector{Int64}}:\n 1  3  2\n 2  1  3\n 3  2  1\n\n\n\n\nハンケル行列（Hankel Matrix）：対角線から左上方向と右下方向に同じ要素が並ぶ行列です。\nJuliaでのハンケル行列の作成方法は次の通りです。\n\n# 3x3のハンケル行列\nHankel([1,2,3,4,5,6], (3,4))\n\n3×4 Hankel{Int64, Vector{Int64}, Tuple{Int64, Int64}}:\n 1  2  3  4\n 2  3  4  5\n 3  4  5  6"
  },
  {
    "objectID": "page-julia-linearalgebra-2.html",
    "href": "page-julia-linearalgebra-2.html",
    "title": "mysite",
    "section": "",
    "text": "線形代数\n行列の分解手法は沢山ありますが、固有値分解は最も汎用的に役立つ例の一つです。\n\n固有値と固有ベクトル\n固有値（Eigenvalues）と固有ベクトル（Eigenvectors）は、線形代数において重要な概念です。 これらの対（組）を固有対（eigenpair）と呼ぶことがあります。 固有値と固有ベクトルは、行列に対して特定の性質を持つベクトルとスカラー値です。\n行列Aが与えられたとき、ベクトル \\(v\\) とスカラー \\(\\lambda\\) に対して以下の式が成り立つとき、\\(v\\) を \\(A\\) の固有ベクトル、\\(\\lambda\\) を \\(A\\) の固有値と呼びます。\n\\[ A v = \\lambda v \\]\nこの式は、行列 \\(A\\) によってベクトル \\(v\\) が \\(\\lambda\\) 倍に変換されることを表しています。 固有ベクトルは方向が変化せずにスケールされるため、行列の変換の中で特別な役割を果たします。\n固有ベクトルは、行列を関数として扱いたいときに効力を発揮します。 超便利！\n行列が異なる固有値を持つ \\(n\\) 個の線形独立な固有ベクトルを持つ場合、その行列は対角化可能だと言えます。 この『対角化』とは、行列 \\(A\\) を以下の形式で表せるということです。 実際、式をいじってみるとこうなります。 \\[ A = PDP^{-1} \\]\nJuliaで固有値、固有ベクトルを求める方法は以下の通りです：\n\nusing LinearAlgebra\nA = rand(3, 3)\nF = eigen(A) # F.valuesが固有値, F.vectorsが固有ベクトル\nF\n\nEigen{ComplexF64, ComplexF64, Matrix{ComplexF64}, Vector{ComplexF64}}\nvalues:\n3-element Vector{ComplexF64}:\n -0.17368081196005505 - 0.3039770069012261im\n -0.17368081196005505 + 0.3039770069012261im\n   1.5431914300861154 + 0.0im\nvectors:\n3×3 Matrix{ComplexF64}:\n  0.526931+0.302582im   0.526931-0.302582im  0.532166+0.0im\n -0.251746-0.400011im  -0.251746+0.400011im  0.644524+0.0im\n -0.638281-0.0im       -0.638281+0.0im       0.548988+0.0im\n\n\nF.valuesを見ると内部が昇順にソートされてるのが分かると思います。 固有値は大きさで挙動が変わるので確かめておくと便利です。\nちなみに、固有値の定義から以下のように計算すると、実際に値が正しいか確認できます。\n\nP, D = F.vectors, diagm(F.values)\nA - P * D * inv(P)\n\n3×3 Matrix{ComplexF64}:\n -2.22045e-16-0.0im  -1.11022e-15+3.04406e-17im   7.21645e-16-2.61836e-17im\n -2.22045e-16-0.0im   3.33067e-16+3.68676e-17im  -1.11022e-16-4.55896e-17im\n -3.33067e-16-0.0im  -1.11022e-16+3.14028e-17im   1.11022e-16-8.25225e-17im\n\n\n誤差が十分小さいので、\\(A\\) を表現できたと確認できましたね。\nもし、使いたい行列が \\(A=PDP^{-1}\\) となったとしたら、そのことは凄く重要な意味を持ちます。\n\n\n固有値の性質\n\nトレースが全ての固有値の和になる\n\n\ntr(A) - sum(F.values)\n\n2.220446049250313e-16 - 0.0im\n\n\n\n行列式が全ての固有値の積になる。\n\n\ndet(A) - prod(F.values)\n\n-3.885780586188048e-16 - 0.0im\n\n\n\n逆行列が固有値の逆数で簡単に求められる（後述する行列関数の特殊ケース）\n\n\ninv_D = diagm(F.values .^ -1)\ninv(A) - (P * inv_D * inv(P))\n\n3×3 Matrix{ComplexF64}:\n 1.44329e-15-0.0im  -8.88178e-16+1.27824e-17im  8.88178e-16-1.22017e-16im\n 8.88178e-16-0.0im  -1.77636e-15+1.54812e-17im  6.66134e-16-1.33162e-17im\n  -2.498e-15-0.0im   1.77636e-15+1.31865e-17im          0.0+9.96799e-17im\n\n\n\n行列関数の高速計算に使える。 \\(A^n\\) みたいな計算を特に考えずに \\(AAA...AA\\) と行列の積で計算しようとする相当なコストがかかります。 なぜなら、\\(A\\) が \\(m\\times m\\) 行列だとすれば、単純な掛け算が \\(O(nm^3)\\) も行われるからです。 しかし、固有値を使うと、\\(A=PDP^{-1}\\) より、\\(A^n = A=P D^n P^{-1}\\) になります。 計算量は（固有値分解に係るコストを無視すれば）相当に抑えることができます。\n\n\nn = 10\nA^n - P * (D^n) * inv(P)\n\n3×3 Matrix{ComplexF64}:\n -7.81597e-14-0.0im   -7.4607e-14+1.51088e-15im  -2.13163e-14-1.29959e-15im\n -8.52651e-14-0.0im  -7.81597e-14+1.82988e-15im  -1.77636e-14-1.57398e-15im\n -8.52651e-14-0.0im  -7.81597e-14+1.55864e-15im   -2.4869e-14-1.34068e-15im\n\n\n\n\n行列関数\n行列関数（Matrix function）は、行列を入力として受け取り、行列を出力する関数です。 通常の数値関数がスカラーを操作するのに対して、行列関数は行列を操作するための特殊な関数です。 行列関数は線形代数や数値計算、物理学、統計学などの分野で広く使用されます。\nJuliaでは行列関数が標準で実装されているものが多く、固有値分解は勝手にやってくれてます。\n行列関数の具体的な例としては、以下のようなものがあります。\n\n行列の \\(n\\) 乗 \\[ A^n = P D^n P^{-1} \\]\n\n\nA ^ 5\n\n3×3 Matrix{Float64}:\n 3.55706  2.68683  1.88119\n 4.31038  3.26062  2.2685\n 3.6689   2.78246  1.92869\n\n\n\n行列の指数関数 行列指数関数は指数関数を行列に適用したもので、指数級数を用いて定義されます。 行列指数関数は、物理学や制御工学などで連立微分方程式の解を求める際に使用されます。 内部の詳細な仕様は知りませんが、固有値を使うと以下のように書けます。 \\[ e^{A} = P e^{D} P^{-1} \\]\n\n\nexp(A)\n\n3×3 Matrix{Float64}:\n 2.31989  1.47959   0.55023\n 1.89464  2.07686   1.21898\n 1.75728  0.927806  1.88681\n\n\n\n行列の対数関数 行列対数関数は対数関数を行列に適用したもので、行列指数関数の逆操作となります。 行列対数関数は、行列の対角化や行列の対称性を利用するなどの目的で使用されます。 \\[ \\log A = P \\log D P^{-1} \\]\n\n\nlog(A)\n\n3×3 Matrix{Float64}:\n -0.931117   2.84258  -2.01411\n  0.611082  -1.90257   2.15066\n  1.7123    -2.03951   1.16845\n\n\n\n行列の三角関数 行列の三角関数には行列のサイン、コサイン、タンジェントなどがあります。これらの関数は行列の固有値や固有ベクトルの計算、回転行列の操作などで使用されます。 \\[ \\sin A = P \\sin D P^{-1} \\]\n\n\nsin(A)\n\n3×3 Matrix{Float64}:\n 0.228515  0.710166    -0.0862748\n 0.563834  0.0543052    0.563262\n 0.653641  0.00929941   0.355089\n\n\n\n一般の関数 関数 \\(f(x)\\) のフーリエ級数が収束するなど、ある程度良い条件のもとでは、一般の関数 \\(f(x)\\) に対しても行列関数を適用できます。 \\[ f(x) = P f(D) P^{-1} \\]\n\n\nfunction f_MatrixFunction(f, A)\n  F    = eigen(A)\n  P, D = F.vectors, diagm(F.values)\n  f_D = diagm(f.(F.values))\n  return P * f_D * inv(P)\nend\n\nf_MatrixFunction(x -> tan(x+pi), A)\n\n3×3 Matrix{ComplexF64}:\n 14.5569+0.0im  11.5316-7.14392e-16im  7.45733+5.86732e-16im\n 17.8917+0.0im  13.1833-8.65224e-16im  9.69777+7.58104e-16im\n 15.4125+0.0im  11.1748-7.36975e-16im  8.15657+6.33912e-16im"
  },
  {
    "objectID": "page-julia-numbertheory-1.html",
    "href": "page-julia-numbertheory-1.html",
    "title": "mysite",
    "section": "",
    "text": "整数論\n\n漸化式\n漸化式は僕の分野だと何に役立つか良く分かりません。 同次形の微分方程式にちょっと似てるかなってくらいです。\nただ、再帰的な解法を解くためのツールとして、何かに役立つかもしれないと思います。\nNaiveな方法なら、初期項 \\(a_0\\) から 更新式 \\(a_n = f(a_{n-1}, ..., a_0)\\) で逐次求めていけば良いだけのものです。\n\n\n漸化式の解法\n\nケースA\nA  \\(a_n = a_{n-1} + d\\)   \\(\\Rightarrow\\)  A’  \\(\\Delta a_n = a_n - a_{n-1} = d\\)   \\(\\Rightarrow\\)   \\(a_n = nd + a_0\\) \n\n\nケースB\nB  \\(a_n = r a_{n-1}\\)  \\(\\Rightarrow\\)   \\(a_n = r^n a_0\\) \n\n\nケースC\nC  \\(a_n = a_{n-1} + f(n)\\)   \\(\\Rightarrow\\)  C’  \\(\\Delta a_n = a_n - a_{n-1} = f(n)\\)   \\(\\Rightarrow\\)   \\(a_n= a_0 + \\sum_{k=1}^{n} f(k)\\) \n\n\nケースD\nD  \\(a_n = p a_{n-1} + q\\)   \\(\\Rightarrow\\)  D’  \\(b_n = p b_{n-1}\\)   \\(\\Rightarrow\\)  B\n\n\n式変形\n\n\\(p \\neq 1\\) かつ \\(n \\rightarrow \\infty\\) において \\(a_n \\rightarrow \\alpha\\) とする。 このとき、\\(b_n = a_n - \\alpha\\) と置くと、以下のように変形できます。 \\[\n\\begin{array}{rr}\n           & a_n    = p a_{n-1} + q\\\\\n  +\\big{)} & \\alpha = p \\alpha  + q\\\\\n  \\hline\n           & b_n    = p b_{n-1}\n\\end{array}\n\\]\n\n\n\nケースE\nE  \\(a_n = p a_{n-1} + q r^n\\)   \\(\\Rightarrow\\)  E’  \\(b_n = \\frac{p}{r} b_{n-1} + q\\)   \\(\\Rightarrow\\)  D\n\n\n式変形\n\n\\(b_n=\\frac{a_n}{r^n}\\) と置くと、以下のように変形できます。 \\[\n\\frac{a_n}{r^n} = \\frac{p a_{n-1}}{r^n}               + q \\Rightarrow\n\\frac{a_n}{r^n} = \\frac{p}{r} \\frac{a_{n-1}}{r^{n-1}} + q \\Rightarrow\nb_n             =         b_{n-1}                     + q\n\\]\n\n\n\nケースF\nF  \\(a_n = p a_{n-1} + q n + r\\)   \\(\\Rightarrow\\)  F’  \\(b_n = p b_{n-1} + q\\)   \\(\\Rightarrow\\)  D\n\n\n式変形\n\n\\(b_n=a_n - a_{n-1}\\) と置くと、以下のように変形できます。 \\[\n\\begin{array}{rr}\n           & a_n     = p a_{n-1} + q n     + r\\\\\n  +\\big{)} & a_{n-1} = p a_{n-2} + q (n-1) + r\\\\\n  \\hline\n           & b_n     = p b_{n-1} + q\n\\end{array}\n\\]\n\n\n\nケースG\nG  \\(a_n + p a_{n-1} + q a_{n-2} = 0\\)   \\(\\Rightarrow\\)  特性方程式  \\(\\Rightarrow\\)   \\(t^n + p t^{n-1} + q t^{n-2} = 0, a_n=t^n\\)   \\(\\Rightarrow\\)   \\(t^2 + p t + q = 0, a_n=t^n\\) \n\n\nケースH1\nH1  \\(a_n^k = r a_{n-1}^l\\)   \\(\\Rightarrow\\)  H1’  \\(k b_n = \\log(r) + l b_{n-1}\\)   \\(\\Rightarrow\\)  D\n\n\n式変形\n\n\\(b_n = \\log(a_n)\\)とすると、以下のように書き表せる。 \\[k \\log(a_n) = \\log(r) + l \\log(a_{n-1})\\] \\[k b_n = \\log(r) + l b_{n-1}\\]\n\n\n\nケースH2\nH2  \\(a_n^k = r a_{n-1}^l a_{n-2}^m\\)   \\(\\Rightarrow\\)  対数\n\n\nケースI\nI  \\(a_n = \\frac{p a_{n-1}}{r a_{n-1} + s}\\)   \\(\\Rightarrow\\)  逆数\n\n\nケースJ\nJ  \\(a_n = \\frac{p a_{n-1}}{r a_{n-1} + s}\\)   \\(\\Rightarrow\\)  \\(x=\\frac{p x}{r x + s}\\) で平行移動\n\n\nケースK\nK  \\(a_n=p a_{n-1}+q b_{n-1} , b_n = r a_{n-1} + s b_{n-1}\\)   \\(\\Rightarrow\\)  行列の固有値"
  },
  {
    "objectID": "page-julia-numericalanalysis-MonteCarlo.html",
    "href": "page-julia-numericalanalysis-MonteCarlo.html",
    "title": "mysite",
    "section": "",
    "text": "数値解析の基礎\n\nモンテカルロ法\nモンテカルロ法とは、シミュレーションや数値計算を乱数を用いて行う手法の総称です。 元々は、中性子が物質中を動き回る様子を探るためにスタニスワフ・ウラムが考案しジョン・フォン・ノイマンにより命名された手法です。 カジノで有名な国家モナコ公国の4つの地区（カルティ）の1つであるモンテカルロから名付けられた。ランダム法とも呼ばれます。\n円周率の計算が例として挙げられますが、上記の通りとてもふわふわした定義なので、応用範囲もとても膨大です。\n参考\n\n\nモンテカルロ法で公式を求める\n円周率や四角錐や球などの公式は、数理モデルを上手く予測できれば、モンテカルロ法で簡単に解くことができます。\n\n円の公式を求める\n円の面積の公式を求めたいものとします。 面積は \\(r^2\\) に比例するというモデルを採用し、 \\(A = p r^2\\) という式を予測します。\n円を囲う正方形の面積は、\\(B=4r^2\\) であり、\\(A:B = p:4\\) となることが分かります。\nここで、一様に乱数を \\(B\\) 内部に発生させた場合、その乱数が \\(A\\) に入っている割合は \\(\\frac{A}{B}=\\frac{p}{4}\\) に収束するはずです。\n実際にやってみます。\nまず、乱数を生成します。なお、0~1範囲で考えます。\n\nusing Random, Plots\nRandom.seed!(0)\nn    = 1000\nx, y = rand(n), rand(n)\n\n([0.4552384158732863, 0.5476424498276177, 0.7733535276924052, 0.9405848223512736, 0.02964765308691042, 0.74694291453392, 0.7468008914093891, 0.9766699015845924, 0.32933536727734813, 0.6720006783993265  …  0.7072449674757433, 0.15432438066942566, 0.3355867684577334, 0.11787146264666937, 0.4326256342755368, 0.3263459955343042, 0.5040915702513394, 0.4363318426010223, 0.06184246643407698, 0.5336768573898811], [0.16014320814891514, 0.5011358617291459, 0.018743665453639813, 0.8601828553599953, 0.6556360448565952, 0.7746656838366666, 0.7817315740767116, 0.5553797706980106, 0.6028345068808697, 0.5690620902865082  …  0.6889826593908546, 0.9148951558240528, 0.1436759291283286, 0.5991633714310699, 0.312059069800222, 0.5199998247362753, 0.7200565636157686, 0.05883652803392858, 0.7601316084452316, 0.7233055822178146])\n\n\n次に、プロットして確かめてみます。\n\nt = range(0, 2π, 1000)\nxc = ((r, θ) -> r*cos(θ)).(1, t)\nyc = ((r, θ) -> r*sin(θ)).(1, t)\nplt = plot(\n    xc, yc, \n    xlims=(0, 1), ylims=(0, 1), \n    linewidth = 3, linecolor=:black, \n    aspect_ratio=1.0\n)\nscatter!(plt, x, y)\n\n\n\n\nパラメータ \\(p\\) は以下のように計算できます。\n\n# p / 4 = n' / n\nn_ = sum(x.^2 + y.^2 .< 1)\np  = 4 * n_ / n\np\n\n3.076\n\n\nよって、予測した円の面積の公式は以下の通りです。本来 \\(p=π=3.141...\\) なので、ちょっと惜しい感じですね。\n\\[\nA = 3.076 r^2\n\\]\n\n\n四角錐（正方形を底面とする錐）\n\n数理モデル\n四角錐の体積 \\(A = p h a^2\\)\n囲う境界内部\n立方体の体積 \\(B = 8 h a^2\\)\nよって、\\(\\frac{A}{B} = p\\)\n境界の判定式\n判定式 \\((x + z < 1) \\wedge (y + z < 1), \\;\\;\\; h=a=1\\)\n\n\nRandom.seed!(0)\nn       = 1000\nx, y, z = rand(n), rand(n), rand(n)\n\nn_ = sum((x + z .< 1) .& (y + z .< 1))\n# p = n' / n\np  =  n_ / n\np\n\n0.354\n\n\nよって、予測した球の体積の公式は以下の通りです。本来は \\(p=\\frac{1}{3}=0.333...\\) です。\n\\[\nA = 0.354 h a^2\n\\]\n\n\n球\n\n数理モデル\n球の体積 \\(A = p r^3\\)\n囲う境界内部\n立方体の体積 \\(B = 8 r^3\\)\nよって、\\(\\frac{A}{B} = \\frac{p}{8}\\)\n境界の判定式\n判定式 \\(x^2 + y^2 < r^2\\)\n\n\nRandom.seed!(0)\nn       = 1000\nx, y, z = rand(n), rand(n), rand(n)\n\nn_ = sum(x.^2 + y.^2 + z.^2 .< 1)\n# p / 8 = n_ / n\np  = 8 * n_ / n\np\n\n4.296\n\n\nよって、予測した球の体積の公式は以下の通りです。本来は \\(p=\\frac{4}{3} \\pi=4.188...\\) です。\n\\[\nA = 4.296 r^3\n\\]\n\n\n\nモンテカルロ法で数値積分\n上記の通り、モンテカルロ法は体積や面積を求めるのに使えます。\nこれは積分ができることと同義です。\n\n自然な手法\n\n\nMISER法\n\n\nVEGAS法"
  },
  {
    "objectID": "page-julia-numericalanalysis-QR.html",
    "href": "page-julia-numericalanalysis-QR.html",
    "title": "mysite",
    "section": "",
    "text": "数値解析の基礎\n\nQR分解\nQR分解（QR decomposition）は、行列 \\(A\\) を直交行列 \\(Q\\) と上三角行列 \\(R\\) の積に分解する手法です。\nQR分解は数値解析や線形代数の応用分野で広く使われています。\n\\[\nA = QR\n\\]\nQR分解は正方行列に限らず、 \\(A \\in \\mathbb{R}^{m\\times n}, m \\ge n\\) の行列に適用できます。その時の式は以下の通りです。\nこの場合も \\(Q \\in \\mathbb{R}^{m \\times m}, R \\in \\mathbb{R}^{m \\times n}\\) の形式を使うのが一般的ですが、数値計算上の効率性を考えると \\(Q_1 \\in \\mathbb{R}^{m \\times n}, R_1 \\in \\mathbb{R}^{n \\times n}\\) の形式（エコノミー分解形式）を使う方がより適切です。\n\\[\nA = Q R = \\begin{bmatrix} Q_1 & Q_2 \\end{bmatrix} \\begin{bmatrix} R_1 \\\\ O \\end{bmatrix}\n  = Q_1 R_1\n\\]\n\n\nグラム・シュミットの直交化法\n「グラム・シュミットの直交化法によるQR分解」は、QR分解を分かりやすく説明するうえで重要なアルゴリズムです。\nただし、実際の実装では使いにくいため、このアルゴリズムを用いて数値計算を行うことは稀です。\n\n\n\n\ngraph LR\n  A[A] -- 直交化 --> B[Q]\n  B --> C[R]\n\n\n\n\n\n\n\n\n\n\\(A\\) からグラム・シュミットの直交化により、\\(Q\\) を構築\nグラム・シュミットの直交化は、ベクトル \\(\\{x_j \\in \\mathbb{R}^{m}\\}_{j=1}^{n}\\) を使って直交する \\(n\\) 本のベクトル \\(\\{e_j \\in \\mathbb{R}^{m}\\}_{j=1}^{n}\\) を作るアルゴリズムです。\nこの手法は、次のような漸化式で計算されます(\\(e_j\\) などは縦ベクトルを想定)。\nこれをプログラムで実装することを考える。\n\\[\ne_i = \\frac{u_i}{\\|u_i\\|}, \\;\\;\\; u_i = x_i - \\sum_{j=1}^{i-1} e_j e_j^\\mathrm{T} x_i, \\;\\;\\; e_1 = \\frac{x_1}{\\|x_1\\|}\n\\]\n\\(n\\) についての漸化式によって、\\(e_i\\) を求めるプログラムを実装すると、以下の通りになる。\n\nusing LinearAlgebra\n\nfunction e_orth!(x, E, i)\n    u = x - sum( E[:,j]' * x * E[:,j] for j = 1:i-1 )\n    e = u / norm(u)\n    E[:,i] = e\nend\n;\n\nよって、グラム・シュミットの直交化は以下のように実装される。\n\nfunction orth_gram_schmidt(X)\n   E = zeros(size(X))\n   E[:, 1] = X[:,1] / norm(X[:,1])\n   for i = 2:size(X, 2)\n       xi = X[:,i]\n       e_orth!(xi, E, i)\n   end\n   return E\nend\n\nE = orth_gram_schmidt(rand(3, 3))\nE' * E # 単位行列になっている。\n\n3×3 Matrix{Float64}:\n  1.0          -3.60822e-16  -8.88178e-16\n -3.60822e-16   1.0           1.05471e-15\n -8.88178e-16   1.05471e-15   1.0\n\n\n\n\n\\(Q\\) から \\(R\\) を構築\n作成した直交行列を用いると、行列 \\(A=[a_1, a_2, ..., a_n]\\) の各ベクトル \\(a_i\\) は以下のように表現されることになります。\n\\[\na_i = \\sum_{j=1}^{i} e_j e_j' a_i = [e_1, \\dots, e_i, e_{i+1}, \\dots, e_n] \\begin{bmatrix}e_1' a_i \\\\ \\vdots \\\\ e_i' a_i \\\\ 0 \\\\ \\vdots \\\\ 0 \\end{bmatrix}\n\\]\nよって、\\(A\\) は以下のようになります。\n\\[\nA = \\begin{bmatrix}\n  e_1'a_1 & e_1'a_2 & e_1'a_3 & \\dots \\\\\n  0       & e_2'a_2 & e_2'a_3 & \\dots \\\\\n  0       & 0       & e_2'a_3 & \\dots \\\\\n  \\vdots  & \\vdots  & \\vdots  & \\vdots\n\\end{bmatrix}\n\\]\nこれをプログラムで実装すると、以下の通りになります。\n\nfunction Q_to_R(Q, A)\n    n = size(A, 2)\n    R = zeros(n, n)\n    for i = 1:n\n        for j = i:n\n            ei, aj = Q[:,i],  A[:,j]\n            R[i,j] = ei' * aj\n        end\n    end\n    return R\nend\n\nA = rand(5, 4)\nQ = orth_gram_schmidt(A)\nR = Q_to_R(Q, A)\n\n4×4 Matrix{Float64}:\n 1.38986  0.768571  1.55875    0.929791\n 0.0      0.897478  0.647178  -0.127088\n 0.0      0.0       0.844311   0.973667\n 0.0      0.0       0.0        0.393711\n\n\n\n\nQR分解の実装\nグラム・シュミットの直交化法によりQR分解を行う関数myqr_gram_schmidtは以下の通りになります。\n\nfunction myqr_gram_schmidt(A)\n    Q = orth_gram_schmidt(A)\n    R = Q_to_R(Q, A)\n    return Q, R\nend\n\nA = rand(6, 4)\nQ, R = myqr_gram_schmidt(A)\n\nnorm(A - Q*R) \n\n6.562392647709663e-16\n\n\n\n\n\nハウスホルダー法\n「ハウスホルダー法によるQR分解」は、QR分解の実用的なアルゴリズムの１つです。\n\n\n\n\ngraph LR\n  A[A] --> B[A']\n  B -- 変換 --> C[Qi]\n  C -- 小行列化 --> B\n  C --> D[R]\n\n\n\n\n\n\n\n\n\nハウスホルダー変換の意味\nハウスホルダー変換とは、法線ベクトル \\(e\\) の超平面に対して対称に点を写す変換のことです。\n変換を表す以下の行列 \\(H\\) は直交行列かつ対称行列です。\n\\[\nH = I - 2 e e^\\mathrm{T}\n\\]\nハウスホルダー変換は直交変換であるため、どんな超平面を選んでも元のベクトルのノルムを半径とした超球面上にしか変換を行うことはできないことに注意します。\nそうすると、例えば、以下のような変換を行うように \\(e\\) を選んでやることもできます。\n\\[\ny = Hx, \\;\\;\\;  y = \\begin{bmatrix} \\|x\\| \\\\ 0_{m-1} \\end{bmatrix}\n\\]\nこのときの \\(e\\) は以下のベクトルになる。\n\\[\ne =\\frac{x-y}{\\|x-y\\|}\n\\]\n\n\nQR法でのハウスホルダー変換\n以下、全体の変換により得られる行列を \\(A_i\\) 、行列Aを変換していく際の小行列として表れる行列を \\(B_i\\) と定めます。\n\\[\nA_1 = A = B_1\n\\]\n行列 \\(A_1 = A=[a_!, \\dots , a_n]\\) に対して、 \\(x=a_1, \\;\\;\\; y=[\\|x\\|, 0_{m-1}^\\mathrm{T}]^\\mathrm{T}\\) とした時のハウスホルダー変換行列 \\(H_1\\) を作用させると以下のようになります。\n\\[\nA_2 = H_1 A_1 = [H_1 a_1 , \\dots , H_1 a_n] =\n\\begin{bmatrix}\n    \\|a_1\\| & * \\\\\n    0_{m-1} & B_2\n\\end{bmatrix}\n\\]\nここで、小行列を逐次作用させていくことで、\\(k\\) 次上三角行列 \\(R_k\\) と小行列 \\(B_k\\) により、以下のような行列が作れるものとする。\n\\[\nA_k =\n\\begin{bmatrix}\n    R_k & * \\\\\n    O   & B_{k}\n\\end{bmatrix}\n\\]\nここで、\\(B_k\\) という行列に対しても同じようにハウスホルダー変換を施すことができるので、その行列を \\(H_k\\) とすると、以下のように、\\(A_k\\) から \\(A_{k+1}\\) を得る式が求められます。\n\\[\n\\begin{bmatrix}\n    I & O^\\mathrm{T}\\\\\n    O   & H_{k}\n\\end{bmatrix}\nA_k\n=\n\\begin{bmatrix}\n    I & O^\\mathrm{T}\\\\\n    O   & H_{k}\n\\end{bmatrix}\n\\begin{bmatrix}\n    R_k & * \\\\\n    O   & B_{k}\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n    R_k & *\\\\\n    O   & H_{k}B_{k}\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n    R_{k+1} & * \\\\\n    O       & B_{k+1}\n\\end{bmatrix}\n=\nA_{k+1}\n\\]\n\n\nQR法でのハウスホルダー変換の漸化式\nまとめると、\\(Q\\)、\\(R\\) を構築する以下の漸化式が得られます。\n\\[\nR = A_n, \\;\\;\\; Q = Q_1^\\mathrm{T} Q_2^\\mathrm{T} \\dots Q_t^\\mathrm{T}, \\;\\;\\; t=\\text{min}(m-1, n)\n\\]\n\\[\nA_{k+1} = Q_k A_k, \\;\\;\\; A_k=\\begin{bmatrix} R_k & * \\\\ O & B_k \\end{bmatrix} \\;\\;\\; A_1 = A = B_1\n\\]\nここで、直行行列 \\(Q_k\\) は以下の式で表されます。 なお、\\(I\\) は \\(k\\) 次単位行列、\\(O\\) はそれぞれの大きさのゼロ行列です。\n\\[\nQ_k =\n\\begin{bmatrix}\n    I & O^\\mathrm{T}\\\\\n    O   & H_{k}\n\\end{bmatrix}, \\;\\;\\;\nH_k = I - 2 ee', \\;\\;\\;\ne =\\frac{x-y}{\\|x-y\\|}, \\;\\;\\;\nx = b_1, \\;\\;\\;\ny=\\begin{bmatrix} \\|b_1\\| \\\\ 0 \\end{bmatrix}, \\;\\;\\;\nb_1 = B_k[:, 1]\n\\]\n\n\nQR分解の実装\nハウスホルダー変換を行う行列を生成するプログラムは以下の通りです。\n\nusing LinearAlgebra\n\n# e を使って行列 H_k を構築する。\nH(e)    = Matrix{Float64}(I, length(e), length(e)) - 2 * e * e'\n\n# x, y を使って行列 H_k を構築する。\nH(x, y) = H((v -> v / norm(v))(x - y))\n\n# b1 を使って行列 H_k を構築する。\nfunction Bk_to_Hk(Bk)\n    b1 = Bk[:,1]\n    x  = b1\n    y  = zeros(size(b1)); y[1] = norm(b1)\n    return H(x, y)\nend\n\n# 行列 Q_k を構築する。\nfunction Ak_to_Qk!(Qk, Ak, k)\n    Qk[:, :] .= 0\n    Qk[1:k, 1:k]     = Matrix{Float64}(I, k, k)\n    Qk[k:end, k:end] = Bk_to_Hk(Ak[k:end, k:end])\nend\n;\n\n以下のように、本来計算上0になるべき部分にごく小さい値が入っているため、効率はやや悪いですが、細かい部分なのでそこを気にするのは取り敢えず止めておきます。\n\nA = rand(5, 5)\nQ = zeros(size(A))\nAk_to_Qk!(Q, A, 1)\nQ * A\n\n5×5 Matrix{Float64}:\n  0.510881      0.918488   0.649733     0.63135     0.601804\n -3.15588e-17   0.221955   0.334637     0.149022    0.00241317\n -1.10957e-16  -0.343959  -0.402003    -0.0759852   0.119281\n -3.27052e-18   0.17631    0.603643     0.124452   -0.0380358\n -6.22882e-18   0.496062  -0.00917068   0.254652    0.877774\n\n\n漸化式を適用していく部分を実装すると以下の通りになります。\n\nfunction A_next!(Q, Qk, Ak, k)\n    Ak_to_Qk!(Qk, Ak, k)\n    Ak .= Qk*Ak \n    Q  .= Q*Qk'\nend\n;\n\nQR分解の実装は以下の通りになります。\n\nfunction myqr_house(AA)\n    m, n  = size(AA)\n    Ak = copy(AA)\n    Qk = zeros(m, m)\n    Q  = Matrix{Float64}(I, m, m)\n    t = min(m-1, n)\n    for k = 1:t\n        A_next!(Q, Qk, Ak, k)\n    end\n    R = Ak\n    return Q, R\nend\n\nA = rand(4, 4)\nQ, R = myqr_house(A)\n\nnorm(A - Q*R)\n\n6.959765930514777e-16\n\n\n参考\n\n\n\nギブンス回転\n「ギブンス回転」を用いる方法は、QR分解の実用的なアルゴリズムの１つです。 並列化に向いている手法です。\n説明は暇があったら書きます。\n\n# 行列の下三角の部分だけを返す\nfunction tril_indices(m, n)\n    idx = []\n    for i = 1:m\n        for j = 1:i-1\n            if j > n\n                break\n            end\n            push!(idx, (i,j))\n        end\n    end\n    return idx\nend\n;\n\n\nfunction cos_givens_rotation(a, b)\n    r = √(a^2 + b^2)\n    rot = [\n        a/r -b/r; #  cos sin\n        b/r  a/r  # -sin cos\n    ]\n    return rot\nend\n\n\nfunction myqr_givens_rotation(A)\n    m, n = size(A)\n    Q = Matrix{Float64}(I, m, m)\n    R = copy(A)\n    for ij = tril_indices(m, n)\n        i, j = ij\n        if R[i, j] == 0\n            continue\n        end\n        G = Matrix{Float64}(I, m, m)\n        G[[j, i], [j, i]] = cos_givens_rotation(R[j, j], R[i, j])\n\n        R = G * R\n        Q = Q * G'\n    end\n    return Q, R\nend\n;\n\n\nA = rand(6, 4)\nQ, R = myqr_givens_rotation(A)\n\nnorm(A - Q*R)\n\n4.965068306494546e-16\n\n\n参考"
  },
  {
    "objectID": "page-julia-packages-Base.html",
    "href": "page-julia-packages-Base.html",
    "title": "mysite",
    "section": "",
    "text": "Juliaのパッケージ\nインストールしなくても最初から用意されている機能のパッケージです。\n\nBaseとは？\nJuliaでは、built-inの関数が大抵はこの名前空間にあります。\n例えば、rand関数はBase.rand関数と同じ関数を表しています。\nJuliaでは多重ディスパッチが許されているため、定義の違うBase.randを定義したりすることもできます。"
  },
  {
    "objectID": "page-julia-packages-LinearAlgebra.html",
    "href": "page-julia-packages-LinearAlgebra.html",
    "title": "mysite",
    "section": "",
    "text": "Juliaのパッケージ\nインストールしなくても最初から用意されているパッケージです。 プログラムの最初の方でusing LinearAlgebraと指定して読み込んでください。\n\nLinearAlgebraとは？\n行列の計算などをするのに適したパッケージです。 ただし、疎行列などの問題に適したアルゴリズムではないので注意してください。\n数値計算で使われる機能は大半このパッケージに含まれます。 また、BLASやLAPACKの機能が含まれます。\nここで述べる学問領域は僕の得意分野ですが、このセクションでは簡単な使い方の例を紹介するに留めます。\n参考\n\n\n基本的な機能\n\nノルム\nベクトルのノルムを求められます。 デフォルトはユークリッド空間における通常のノルム(２ノルム)になります。\n\nusing LinearAlgebra\nnorm([1, 2, 1])\n\n2.449489742783178\n\n\n\n\n内積\nベクトル同士のドット積（内積）を求められます。\n\ndot([1,3,2], [4,1,6])\n\n19\n\n\n\n\n外積\nベクトル同士のクロス積（外積）を求められます。\n\ncross([1,3,2], [4,1,6])\n\n3-element Vector{Int64}:\n  16\n   2\n -11\n\n\n\n\n行列式\n行列の行列式を求められます。\n\nA = [\n    1 2 4;\n    5 4 1;\n    9 2 6.0\n]\ndet(A)\n\n-124.0\n\n\n\n\nトレース\n行列のトレースを求められます。\n\nA = [\n    1 2 4;\n    5 4 1;\n    9 2 6.0\n]\ntr(A)\n\n11.0\n\n\n\n\n\n固有値問題\n固有値問題を解きます。\n\nA = rand(10, 10)\n\nF = eigen(A) # Λ, V = eigen(A)でもOK\nΛ, V = F.values, F.vectors\n\nnorm(\n    A*V - V*diagm(Λ)\n)\n\n1.3988919810697231e-14\n\n\n\n\n特異値分解\n特異値分解を解きます。(エコノミーサイズです)\n\nA = rand(10, 8)\n\nF = svd(A) # U, S, V = svd(A)でもOK\nU, S, V = F.U, F.S, F.V\n\nnorm(\n    A - U*diagm(S)*V'\n)\n\n3.2209424127120038e-15\n\n\n\n\nLU分解\nLU分解を解きます。\n\nA = rand(10, 8)\n\nF = lu(A) # L, U = lu(A)\nL, U, p = F.L, F.U, F.p\n\nnorm(\n   A[p,:] - L*U\n)\n\n3.9852227955858445e-16\n\n\n\n\nQR分解\nQR分解を解きます。\n\nA = rand(10, 8)\n\nF = qr(A)\nQ, R = F.Q, F.R\n\nnorm(\n    A - Q*R\n)\n\n1.3076087352977526e-15"
  },
  {
    "objectID": "page-julia-packages-MAT.html",
    "href": "page-julia-packages-MAT.html",
    "title": "mysite",
    "section": "",
    "text": "Juliaのパッケージ\nインストールするには、JuliaのREPLでusing Pkg; Pkg.add(\"MAT\")を実行してください。\n\nMATとは？\n数値計算や機械学習の分野では、計算途中のデータを保存することで、事故の発生を防ぎたいことがあります。 多くの場合、.csvや.txtや.jsonといったファイル形式で保存するのですが、その他の方法として、Matlabの変数を格納する.mat形式のファイルを使いたい場合があります。\nこんなとき、MATパッケージを使用すれば、変数を辞書型にまとめて保存することができ、その辞書をファイルからそのまま取り出すこともできます。\nまた、このファイルは「MATLAB v7.3 format.」によって書き込まれるため、matlabでも読み込み可能です。\n参考文献\n\n\nMATの使い方\n\n書き込み\n書き込みは以下のように、ファイルのパスを与えて辞書型のデータを関数に渡すことで行います。\n\nusing MAT\n\nd = Dict(\n    \"var1\" => \"hello\",\n    \"var2\" => rand(3, 3)\n)\n\nmatwrite(\"tmp/__matfile.mat\", d)\n\n\n\n読み込み\n読み込みは以下のように、ファイルのパスを与えて辞書型のデータを受け取ることで行います。\n\ne = matread(\"tmp/__matfile.mat\")\ne\n\nDict{String, Any} with 2 entries:\n  \"var1\" => \"hello\"\n  \"var2\" => [0.747694 0.818366 0.44244; 0.123226 0.816386 0.0572965; 0.603717 0…"
  },
  {
    "objectID": "page-julia-packages-Pkg.html",
    "href": "page-julia-packages-Pkg.html",
    "title": "mysite",
    "section": "",
    "text": "Juliaのパッケージ\nインストールしなくても最初から用意されているパッケージです。 主にPEPLで、使いたいタイミングでusing Pkgと指定して読み込んでください。\n\nPkgとは？\nJuliaのパッケージインストーラです。\n主に、パッケージのインストールを行う際に使うものです。 プログラム中で使うことはあまり想定されてないため、JuliaのREPL上で実行してください。\n\nパッケージのインストール\nインストール方法は２つあります（やり方が違うだけで両方同じです）。\n\nPkgパッケージの関数addを使ってインストールする。\nusing Pkg; Pkg.add(\"パッケージ名\")というコマンドによって、インストールできます。\n]add パッケージ名でパッケージインストーラを起動する。\nREPL上でjulia> ]として、(***) pkg>と出た時点で、add パッケージ名としてください。\n\n\n\nプロジェクトの操作\n\nパッケージの作成\n以下のコマンドを実行して、新しいパッケージを作成します。 これにより、パッケージのskeltonが生成されます。\n] generate パッケージのパス\nパッケージのアクティベート\nJuliaのREPL（対話型環境）で以下のコマンドを実行します。このコマンドは、作成したプロジェクトのディレクトリをアクティブな環境として設定します。\n] activate パッケージのパス\nJuliaで開発を行う際には、Revise.jlというパッケージを使うと便利です。 Reviseは、外部から与えられる変更を監視してREPL上で扱われるパッケージの内容が自動で更新されるので便利です。"
  },
  {
    "objectID": "page-julia-packages-Plots.html",
    "href": "page-julia-packages-Plots.html",
    "title": "mysite",
    "section": "",
    "text": "Juliaのパッケージ\nインストールするには、JuliaのREPLでusing Pkg; Pkg.add(\"Plots\")を実行してください。\n実行時には、以下のように読み込んでください。\n\nusing Plots\n\n\nPlotsとは？\n数字だけ見てもデータの意味が分かりにくいことが多いので、グラフの利用は数値計算の分野では重要です。\n例えば、乱数を生成するrand関数で作った３次元の点群がどのようになっているかを数字とグラフでそれぞれ表示してみます。\n\nusing Random\nRandom.seed!(0)\n\nn = 100\nx, y, z = rand(n), rand(n), rand(n)\ndisplay.([x', y', x'])\n;\n\n1×100 adjoint(::Vector{Float64}) with eltype Float64:\n 0.455238  0.547642  0.773354  0.940585  …  0.351491  0.193291  0.116989\n\n\n1×100 adjoint(::Vector{Float64}) with eltype Float64:\n 0.655636  0.774666  0.781732  0.55538  …  0.355375  0.524008  0.279907\n\n\n1×100 adjoint(::Vector{Float64}) with eltype Float64:\n 0.455238  0.547642  0.773354  0.940585  …  0.351491  0.193291  0.116989\n\n\n\nusing Plots \nscatter(x, y, z)\n\n\n\n\n勿論、グラフの方が分かりやすいと思います。\nこのように、Plotsでは、数値を可視化する機能が複数用意されています。\n\n\n折れ線グラフplot, plot!\nplotは連続的なデータや関数の表示が得意な関数です。 基本的には、折れ線グラフの表示を行いますが、他のプロットにも使える多機能な関数です。\n\n関数のプロット\n以下のように、関数をプロットできます。\n\nplt = plot(sin)\nplot!(plt, cos) # 重ねて描く\n\ndisplay(plt)\n;\n\n\n\n\n\n\nデータのプロット\nデータの点群を与えると、直線で結んで表示してくれます。\n\nx = 0:0.1:1\ny = (n -> n^2).(x)\nplt1 = plot(x, y)\n\n\n\n\n\n\n\n\n\n\n\n散布図scatter, scatter!\nscatterは散布図を作成する関数です。 散布図とは、データを散らしたグラフのことです。\n\nデータのプロット\n以下のようにして使えます。\n\n# 2dimプロット\nx = 0:0.1:1\ny = (n -> n^2).(x)\nscatter(x, y)\n# 3dimプロット\nx = 0:0.1:1\ny = sin.(x)\nz = exp.(x)\nplt2 = scatter(x, y, z)\n\ndisplay.([plt1, plt2])\n;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n円グラフpie\n円グラフを作成できます。\n\nデータの表示\n\nx = [\"nitrogen\", \"oxygen\", \"argon\", \"carbon dioxide gas\"]\ny = [78.11, 20.96, 0.9343, 0.03]\nplt = pie(x, y, title=\"Volume ratio of atmospheric composition on the ground\",l = 0.5)\ndisplay(plt)\n;\n\n\n\n\n\n\n\n\n参考\n\n\n\n棒グラフbar\n棒グラフを作成できます。\n\nx = [\"A\", \"B\", \"C\", \"D\"]  # x軸のラベル\ny = [3, 5, 2, 7]  # 各バーの高さ\n\nbar(x, y)\n\n\n\n\n\n\nプロットやグラフの整形方法\nグラフにタイトルを付けたいとき、描画範囲を指定したいとき、方対数グラフを作りたいときなど、参考にしてください。\n\nそのプロット全体に適用\n\nグラフのタイトルをつける\ntitle = \"Title\"\nグラフの範囲を決める\nxlims = (1.0^-5. 1)\nylims = (0, 1)\nグラフのフォントサイズを設定する\ntickfontsize = 20\nグラフの軸を対数にする\nxaxis = :log\nyaxis = :log\nグラフを箱で囲む\nframestyle = :box\nグラフに指定の目盛りを付ける\nyticks = [0, 10, 20, 30, 40, 50]\nグラフのアスペクト比を制御する。\naspect_ratio = 1.0\n\n\n\nそのグラフに適用\n\nグラフの凡例ラベルをつける\nlabel = \"func\"\n線の色を変更する\nlinecolor = :red\nグラフの線の長さを決める\nlinewidth = 3\nマーカーを設定する。\nmarkershape = :x\n\n\n\n\nプロットテクニック\n\nテンプレート\n適当に全部詰めたテンプレートが以下の通りです。 要らないものは消してください。\n\nplt = plot(\n    title = \"ThisIsTitle\",    # タイトル\n    xlims = (-10, 10),        # xの範囲\n    ylims = (1e-1, 1e10),     # yの範囲\n    tickfontsize = 5,         # フォントサイズ\n    yaxis = :log,             # y軸方対数グラフ\n    framestyle   = :box,      # 枠で囲む\n    yticks= exp.((0:10) .^ 2) # 目盛り\n)\nplot!(plt, x -> exp(x^2), \n    label = \"exp(x^2)\",       # 凡例のラベル\n    linecolor   = :red,       # 赤い線\n    linewidth   = 2,          # 線の太さ\n    markershape = :x          # マーカーの設定\n)\n\n\n\n\n\n\n対数の下駄履かせ\nイテレーションの回数などのパラメータを変化させていった時の相対誤差をプロットしたいときなど、対数プロットをしたいときがあると思います。\nコンピュータの計算では、誤差の計算結果が0になることはよくあるため、結果に下駄を履かせないとプロットが正確に行われない場合があります。\nこのとき、計算結果が0のデータは正常に表示できないため、以下のようにepsを足して下駄を履かせることで、プロットを正常に行えます。\n例えば、以下はsin関数を \\(n3\\) 次のマクローリン展開で近似した関数sin_macとの相対誤差のグラフです。\n\nfunction sin_mac(n, x)\n    q = p = x; k  = round(n/2) - 1\n    for i = 1:k\n        q = q * ((- 1) / ( (2*i) * (2*i + 1))) * x^2; p = p  + q\n    end\n  return p\nend\n\nx   = range(-10π, 10π, 1000)\ny   = sin_mac.(10, x)\ny_t = sin.(x)\n\neps = 1e-19\n\nrelerr_y = abs.((y_t - y) ./ y) .+ eps\n\nplot(x, relerr_y, yaxis=:log, ylims=(1e-10, 1e1))"
  },
  {
    "objectID": "page-julia-packages-Random.html",
    "href": "page-julia-packages-Random.html",
    "title": "mysite",
    "section": "",
    "text": "Juliaのパッケージ\nインストールするには、JuliaのREPLでusing Pkg; Pkg.add(\"Random\")を実行してください。\n\nRandomとは？\n乱数生成はありとあらゆる場所で使われています。 特に、確率的に起こる事象を扱う場合に使われます。\n参考文献\n\n\nRandomの使い方\nRandomの使い方で大切なのは、randとRandom.seed!くらいです。 他は余り使わないと思います。\n\n0~1間の乱数\nなお、rand関数はusing Randomを宣言する前からBaseに含まれています。\n\n乱数生成\n以下のように、乱数を生成できます。\n\nrand()\n\n0.2895098423219379\n\n\n\n\n５次元の配列（ベクトル）\n以下のように、ベクトルを作ることもできます。\n\nrand(5)\n\n5-element Vector{Float64}:\n 0.028549977665983994\n 0.538639413965653\n 0.8969897902567084\n 0.25847781536337067\n 0.3389490517221738\n\n\n\n\n\\(2 \\times 4\\) の行列\n以下のように、行列も作れます。\n\nrand(2,4)\n\n2×4 Matrix{Float64}:\n 0.374877  0.768433  0.876292  0.934366\n 0.444003  0.178543  0.55      0.532499\n\n\n\n\n\\(3 \\times 4\\) の複素行列\n以下のように、型に沿った行列を作るみたいなこともできます。\n\nrand(ComplexF64, 3, 4)\n\n3×4 Matrix{ComplexF64}:\n 0.043883+0.325227im   0.63344+0.21631im   …  0.913038+0.409758im\n 0.494975+0.856017im  0.414769+0.702561im     0.624384+0.0565774im\n 0.164786+0.685904im  0.870925+0.757711im     0.871887+0.355375im\n\n\n\n\nランダム選択\n以下のように、さいころの出目みたいなものを扱うこともできます。\n\nchoise = [\"A\", \"B\", \"C\", 1, 2, 3]\nn      = 10\nrand(choise, n)\n\n10-element Vector{Any}:\n 1\n  \"B\"\n  \"B\"\n  \"C\"\n 1\n  \"B\"\n 3\n  \"A\"\n  \"B\"\n 1\n\n\n\n\n\n乱数のシードの設定\n乱数は「シード」と言われるパラメータを用いて生成しています。 シードは現在時刻などを参照して決められます。\nこのシードの値を用いて、非常に周期の長い（同じパターンが起こりにくい）疑似乱数を生成しています。\nプログラムに乱数を使っている場合、シードを設定していないと「再現性」の面で問題が起きる場合があり、シードをプログラム内で設定してやることが求められる事があります。数値計算のプログラムなどではシードを設定しておくことをお勧めします。\n\nusing Random\nRandom.seed!(0)\n;\n\n\n\nランダムな置換\n\nx = [1,2,3,4,5]\nx[randperm(length(x))]\n\n5-element Vector{Int64}:\n 4\n 5\n 3\n 2\n 1\n\n\n\n\n置換によるシャッフル\n\nx = [\"a\", \"b\", \"c\", \"d\"]\nshuffle(x)\n\n4-element Vector{String}:\n \"a\"\n \"d\"\n \"b\"\n \"c\""
  },
  {
    "objectID": "page-julia-packages-Revise.html",
    "href": "page-julia-packages-Revise.html",
    "title": "mysite",
    "section": "",
    "text": "Juliaのパッケージ\nインストールするには、JuliaのREPLでusing Pkg; Pkg.add(\"Revise\")を実行してください。\n\nReviseとは？\nJuliaのReviseパッケージは、Juliaのソースコードを変更した際に、自動的に変更を検知して再評価するためのツールです。\nReviseパッケージを使用すると、開発者はREPL環境でソースコードの変更をリアルタイムに反映させることができます。\n参考\n\n\nReviseの使い方\n以下のような使用感になります。 以下は、vscodeで書き換えてREPLで評価してみた実行結果です。\n\npkg  > activate プロジェクト\njulia> using Revise        # `using プロジェクト`の前に実行してください\njulia> using プロジェクト\njulia> \njulia> プロジェクト.f(2)\nUndefVarError: f not defined\n...\njulia> # 外部ファイルで関数f(x)=x^2を追加\njulia> プロジェクト.f(2)\n4\njulia> # 外部ファイルで関数f(x)=x^3に変更\njulia> プロジェクト.f(2)\n8\njulia>"
  },
  {
    "objectID": "page-julia-howtoinstall.html",
    "href": "page-julia-howtoinstall.html",
    "title": "mysite",
    "section": "",
    "text": "Juliaを使ってみよう\n\nJuliaとは？\n世の中には多くのプログラミング言語があります。 そして、それぞれのプログラム言語には適した使い方があります。\nCやC++ならOSプログラム、FortranやMatlabなら数値計算、Pythonは汎用、JavaはWebアプリ、MathematicaやMaximaなら数学の計算、Hadoopなら分散処理……などです。\n特にJuliaはPythonの代替言語として、機械学習や数値計算領域で使用例が増加してきています。\n僕も数値計算の為にJuliaを勉強しました。\nしかし、Juliaが応用できる分野は、Pythonのそれとは違います。\nなぜなら、Juliaの設計思考は、貪欲に汎用性を求め、あらゆる要求を一手に満たすことだからです。\n\n\n[引用]Juliaの考え\n\n\n簡単に言うと、我々は欲張りなのです。\n我々はMatlabのパワフルなユーザーです。中にはLispのハッカーもいます。PythonistaやRubyist、Perlのハッカーもいます。私たちの中には、まだひげを生やせない人もいますし、顔にひげが生える前からMathematicaを使っていた人もいます。私たちは、正気の範囲を超えるほど多くのRのプロットを生成してきました。Cは私たちにとって、無人島でのプログラミング言語です。\nこれらの言語を全て愛しています。それぞれが素晴らしくパワフルです。私たちが行う仕事、科学的な計算、機械学習、データマイニング、大規模な線形代数、分散および並列計算のために、それぞれが仕事の一部には完璧であり、他の部分にはひどいものです。それぞれはトレードオフです。\n私たちは欲張りです：もっと欲しいのです。\n私たちは、オープンソースの言語を望みます。Cの速度とRubyのダイナミズムを持つ言語が欲しいのです。Lispのような真のマクロを備えたホモアイコニックな言語が欲しいのですが、Matlabのような明白で馴染みのある数学表記も欲しいのです。一般的なプログラミングに使用できるPythonのようなもの、統計処理にはRのように簡単なもの、文字列処理にはPerlのように自然なもの、線形代数にはMatlabのように強力なもの、プログラムをつなぐのにはシェルのように優れたものが欲しいのです。学習が簡単でありながら、真剣なハッカーたちも満足できるものです。インタラクティブであり、コンパイルされたものが欲しいのです。\n（Cと同じくらい速いことを言いましたか？）\n要求が多い中で、私たちはHadoopの分散パワーを提供するものを望みます。ただし、JavaとXMLの冗長な記述なしで。バグを見つけるために数百台のマシン上のギガバイトのログファイルをひとつずつ見る必要はありません。複雑なレイヤーがなくても、パワーを求めます。単一のCPUのレジスタを使って、タイトなマシンコードにコンパイルされるシンプルなスカラーループを書きたいのです。A*Bと書き、数千の計算を数千のマシンで行い、巨大な行列の積を一緒に計算したいのです。\n私たちは、自分の気分に合わせて型を指定することはしたくありません。しかし、ポリモーフィックな関数が必要な場合には、ジェネリックプログラミングを使用してアルゴリズムを一度だけ書き、無限のタイプの格子に適用したいのです。さまざまなメソッド定義から関数の引数に最適なメソッドを効率的に選択するために、多重ディスパッチを使用したいのです。全く異なる型間で共通の機能を提供します。これだけのパワーにもかかわらず、言語はシンプルで清潔であることを望んでいます。\nこれらすべてを求めるのは、欲深いでしょうか？\n私たちは自分たちが非常に欲張りであることを認識していますが、それでも全てを手に入れたいと思っています。約2年半前、私たちは自分たちの欲望の言語を作るために取り組み始めました。まだ完全ではありませんが、初期のリリースの時が来ました。私たちが作った言語はJuliaと呼ばれています。それは私たちの無礼な要求の90%を既に実現しており、今は他の無礼な要求によってさらに形作られる必要があります。ですので、もしもあなたも欲張りで理不尽で要求の多いプログラマーなら、ぜひ試してみてください。\n\n\nなぜJuliaを創ったか？\n\n\nJuliaの強みと弱み\n\nプログラマ人口\nプログラマの人口は、その言語の支持率です。 どれだけ多くのライブラリがあるか、どれだけ多くのドキュメントがあるかは、人口の少ない言語では太刀打ちできません。\nJuliaのプログラマ人口は0.1%に満たないです。\nGitHut 2.0\nパフォーマンス\nJuliaについて説明するとき最も重要なのは、パフォーマンスの話です。\nPythonやJavaなどの言語と比較し、Juliaは十分なチューニングをしなくとも高速動作します。\nPython+NumPy VS Julia\nJulia VS Python 3\nJulia VS C\n\n\n\nJuliaのインストール方法\n\nインストール方法（Windows）\n2023年現在のインストール方法を説明します。 ベーシックな方法だけ紹介するので、パッケージインストーラやポータブル版を使いたい人はそれぞれ調べてください。\n\nJuliaのダウンロード\nまず、ダウンロードにアクセスし、お使いのオペレーティングシステムに基づいてダウンロードしたいJuliaのバージョンをクリックします。\n例えば、「64-bit (installer)」というリンクをクリックすると、インストーラという実行ファイルがダウンロードされます。\nexeファイルを実行する\n次に、ダウンロードした.exeファイルを実行し、Juliaのインストールを進めてください。 「Add Julia To PATH」といったチェックボックスがあれば、チェックすることを推奨します。\nこのチェックをした場合、cmd（コマンドプロンプト）から直接juliaが実行できるようになります。\nJuliaの実行\nJuliaのインストールが完了したら、Juliaを起動します。 すると、REPL（read-eval-print-loop）としても知られるJuliaのコマンドラインが表示されます：\n簡単なコードを実行する\n最後に、コードの入力/実行を開始することができます。 例えば、“Hello World”を表示する簡単なコードを以下に示します：\nprintln(\"Hello World\")\nENTERを押すと、“Hello World” の結果が得られます。\n\n\n\n\nJupyterでの動作\nREPLにてusing Pkg; Pkg.add(\"IJulia\")を実行すると、jupyter-notebookで使えるようになります。"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "mysite",
    "section": "",
    "text": "鋭意制作中"
  },
  {
    "objectID": "page-julia-packages-TaylorSeries.html",
    "href": "page-julia-packages-TaylorSeries.html",
    "title": "mysite",
    "section": "",
    "text": "Juliaのパッケージ\nインストールするには、JuliaのREPLでusing Pkg; Pkg.add(\"TaylorSeries\")を実行してください。 使いたいタイミングでusing TaylorSeriesと指定して読み込んでください。\n\nusing TaylorSeries\n\n\nTaylorSeriesとは？\nマクローリン展開やテイラー展開を扱うライブラリです。\n\n\nTaylorSeriesの使い方\n以下のように、テイラー展開のモデルと変数を定義できます。\n※Taylor1とかTaylorNという関数で変数を定義する方法もありますが、あまり有用性が分かりませんでした。\n\ntaylor_vars = set_variables(\n  \"x\",      # 変数の組\n  order = 5 # テイラー展開で計算する次数\n)\n\nx = taylor_vars[1]\ntaylor_expr = sin(x)\n\ntaylor_expr\n\n 1.0 x - 0.16666666666666666 x³ + 0.008333333333333333 x⁵ + 𝒪(‖x‖⁶)\n\n\n変数が２つの場合は以下のようになります。\n\ntaylor_vars = set_variables(\n  \"x y\",    # 変数の組\n  order = 7 # テイラー展開で計算する次数\n)\n\nx, y = taylor_vars\ntaylor_expr = exp(x + y)\n\ntaylor_expr\n\n 1.0 + 1.0 x + 1.0 y + 0.5 x² + 1.0 x y + 0.5 y² + 0.16666666666666666 x³ + 0.5 x² y + 0.5 x y² + 0.16666666666666666 y³ + 0.041666666666666664 x⁴ + 0.16666666666666666 x³ y + 0.25 x² y² + 0.16666666666666666 x y³ + 0.041666666666666664 y⁴ + 0.008333333333333333 x⁵ + 0.041666666666666664 x⁴ y + 0.08333333333333333 x³ y² + 0.08333333333333333 x² y³ + 0.041666666666666664 x y⁴ + 0.008333333333333333 y⁵ + 0.001388888888888889 x⁶ + 0.008333333333333333 x⁵ y + 0.020833333333333332 x⁴ y² + 0.027777777777777776 x³ y³ + 0.020833333333333332 x² y⁴ + 0.008333333333333333 x y⁵ + 0.001388888888888889 y⁶ + 0.0001984126984126984 x⁷ + 0.001388888888888889 x⁶ y + 0.004166666666666667 x⁵ y² + 0.006944444444444443 x⁴ y³ + 0.006944444444444443 x³ y⁴ + 0.004166666666666667 x² y⁵ + 0.001388888888888889 x y⁶ + 0.0001984126984126984 y⁷ + 𝒪(‖x‖⁸)"
  },
  {
    "objectID": "page-julia-packages-Images.html",
    "href": "page-julia-packages-Images.html",
    "title": "mysite",
    "section": "",
    "text": "Juliaのパッケージ\nインストールするには、JuliaのREPLでusing Pkg; Pkg.add(\"Images\")を実行してください。 使いたいタイミングでusing Imagesと指定して読み込んでください。\n\nusing Images\n\n\nImagesとは？\nImagesはjuliaの画像処理を扱うパッケージです。\n画像データの読み込み、保存、変換、操作など、さまざまな画像処理タスクをサポートしています（ゲームなどで画像を扱いたいときは別のライブラリを使ってください）。\n高速な画像処理を実現するために、Juliaの高性能な数値計算機能や並列処理機能を活用しています。\nImages.jlは、画像データを表現するためのImage型や、画像処理関数の集合などの主要な要素から構成されています。以下に、Images.jlの主な機能と使用例をいくつか示します。\nImageViewやImageShowというパッケージを併せて使えば、imshowなどの関数によって画像の表示ができますが、保存やnotebookでの表示は成功するので気にしないでください（このパッケージ、なぜか重いので私の環境では使っていません）。\n画像の確認はdisplayで行ってください。\n参考\n\n\nImagesの使い方\n\n画像の読み込み\n画像はload関数で読み込めます。\n\nimg1 = load(\"tmp/__imagesample1.bmp\")\ndisplay(img1)\n\n\n\n\n\n\n画像の書き込み（保存）\n書き込みはsave関数です。\n\nx = collect(1.0:-0.1:0)\nimg2 = Gray.(x * x')\ndisplay(img2)\nsave(\"tmp/__imagesample2.png\", img2)\n\n\n\n\n\n\n画像の操作\nグレイスケールにする。\n\nimg1_gray = Gray.(img1)\n\n\n\n\nサイズを変更する。\n\nsiz = (10, 10)\nimg1_resized = imresize(img1, siz)\n\n\n\n\n回転する。\n\nimg1_rotated = imrotate(img1, 45)\n\n\n\n\n切り取る。\n\nss = size(img1)\nimg1_cropped = img1[1:ss[1] ÷ 2, 1:ss[2]  ÷ 2]"
  }
]