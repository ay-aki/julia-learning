[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "このサイトの目的\n\n数学と情報と物理の知識データベース\n数学と情報と物理の3つの分野を雑多にカバーすることが、このサイトの目的です。 分かりにくい部分をできるだけわかりやすく説明していきたいと思います。\nプログラミングを学問を学ぶ基礎として取り入れており、プログラム言語のJuliaを用いて説明しています。"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "mysite",
    "section": "",
    "text": "鋭意制作中"
  },
  {
    "objectID": "page-julia-crypto-1.html",
    "href": "page-julia-crypto-1.html",
    "title": "mysite",
    "section": "",
    "text": "暗号理論\n\nAとB = Alice と Bob\n暗号の人たちは、AとかBとかにアリスとかボブとかいう名前を付けたがります。 大体、以下のような感じになっていると考えて下さい。\n\n\n\n\n\n\n\n\n名前\nname\n詳細\n\n\n\n\nアリス\nAlice\n一般人\n\n\nボブ\nBob\n一般人\n\n\nキャサリン\nCathy\n一般人\n\n\nデイブ\nDave\n一般人\n\n\nイブ\nEve\n盗聴者(eavesdropper?)。通信を盗聴する。\n\n\n\\(\\vdots\\)\n\\(\\vdots\\)\n\\(\\vdots\\)\n\n\nマロリー\nMallory\n能動的攻撃者(malicious？)。通信妨害やメッセージの偽装をする。\n\n\n\\(\\vdots\\)\n\\(\\vdots\\)\n\\(\\vdots\\)\n\n\nヴィクター\nVictor\n検証者(validator?)。\n\n\n\\(\\vdots\\)\n\\(\\vdots\\)\n\\(\\vdots\\)\n\n\n\n例えば、アリスがボブにメールを送るとき、悪意のある盗聴者イブがメールを盗み見ようとしたりします。 暗号理論では悪意のある第三者の存在を前提にすることが多いです。\n\n\n暗号化(encrypt)と復号化(decrypt)\n暗号化とは、平文(plaintext)を、意味の分からない文、つまり暗号文(ciphertext)に変換することです。 復号化はその逆で、暗号文から平文に変換することです。\n普通、平文よりも暗号文の方がサイズの大きいデータになります。\n\n\n\n\nflowchart LR\n  a[\"平文=Hello World!\"] -- 暗号化 -->b[\"暗号文=0avjmgc,qn7%xa#mx\"]\n  b -- 復号化 --> a\n\n\n\n\n\n\n\n\n\n\n送信者、受信者、盗聴者\nインターネット上でやり取りされるデータは、通信路の間でコピーすることが容易です。 そのため、以下の図におけるEveのような盗聴者が存在するものとして考える必要があります。\n\n\n\n\nflowchart LR\n  a2 --> b2\n  a2 --> c2\n  subgraph Alice_送信者\n    a1[平文] -- 暗号化 --> a2[暗号文]\n  end\n  subgraph Bob_受信者\n    b2[暗号文] -- 復号 --> b1[平文]\n  end\n  subgraph Eve_盗聴者\n    c2[暗号文]\n  end"
  },
  {
    "objectID": "page-julia-langbasic-1.html",
    "href": "page-julia-langbasic-1.html",
    "title": "mysite",
    "section": "",
    "text": "Juliaの文法基礎\nプログラミングの構成要素となる型や値、変数などの扱いについてざっくりと列挙しています。 コピーしてREPLで実行してみてください。\n\n値と型\n\n整数(Int64)\n\n8\n\n8\n\n\n\n\n浮動小数点(Float64)\n\n2.0\n\n2.0\n\n\n\n\n文字(Char)\n\n'a'\n\n'a': ASCII/Unicode U+0061 (category Ll: Letter, lowercase)\n\n\n\n\n文字列(String)\n\n\"abc\"\n\n\"abc\"\n\n\n\n\nベクトル(Vector{TYPE})\n\n[1, 2, 5] # [1.0, 2, 5]とすればVector{Float64}型になる\n\n3-element Vector{Int64}:\n 1\n 2\n 5\n\n\n\n\n行列(Matrix{TYPE})\n\n[1 2 3; 2 6 5; 9 3 1; 1 5 1] # どれかの要素をFloat64型にすればMatrix{Float64}型になります。\n\n4×3 Matrix{Int64}:\n 1  2  3\n 2  6  5\n 9  3  1\n 1  5  1\n\n\n\n[1 2 3]\n\n1×3 Matrix{Int64}:\n 1  2  3\n\n\n\n[1; 2; 3]\n\n3-element Vector{Int64}:\n 1\n 2\n 3\n\n\n\n\nタプルNTuple{n, TYPE}\n\n(1, 2, 4, 6)\n\n(1, 2, 4, 6)\n\n\n\n\n辞書型Dict{TYPEA, TYPEB}\n\nDict(\n    \"var1\" => \"hello\",\n    \"var2\" => rand(3, 3)\n)\n\nDict{String, Any} with 2 entries:\n  \"var1\" => \"hello\"\n  \"var2\" => [0.746371 0.659982 0.0830928; 0.218146 0.0443444 0.291347; 0.790336…\n\n\n\n\n\n代入\n\n値1の変数aへの代入\n\na = 1\n\n1\n\n\n\n\n値(\"\", \"2\", 3)を変数(b, c, d)に同時に代入\n\nb, c, d = \"\", \"2\", 3\n\n(\"\", \"2\", 3)\n\n\n\n\n値のスワップ(交換)\n\nx, y = 1, 100\nprintln(\"before: $x $y\")\nx, y = y, x\nprintln(\"after : $x $y\")\n\nbefore: 1 100\nafter : 100 1\n\n\n\n\n\n出力\n\n値の標準出力println\n\ns = \"aaaa\"\nprintln(s)\nprintln(s, \"b\", s) # , で区切ると繋げて表示される\nv = [1, 2, 4]\nprintln(v)\nV = [1 1 2; 5 4 5]\nprintln(V)\n\naaaa\naaaabaaaa\n[1, 2, 4]\n[1 1 2; 5 4 5]\n\n\n\n\n値を整形して表示display\n\ns = \"aaaa\"\ndisplay(s)\nv = [1, 2, 4]\ndisplay(v)\nV = [1 1 2; 5 4 5]\ndisplay(V)\n\n\"aaaa\"\n\n\n3-element Vector{Int64}:\n 1\n 2\n 4\n\n\n2×3 Matrix{Int64}:\n 1  1  2\n 5  4  5\n\n\n\n\n\n四則演算+α\n\n足し算+\n\n1 + 2 + 4\n\n7\n\n\n\n\n引き算-\n\n132 - 451\n\n-319\n\n\n\n\n掛け算*\n\n111 * 222\n\n24642\n\n\n\n\n割り算/\n\n10 / 3.0 # 3.0を3としても動作する\n\n3.3333333333333335\n\n\n\n\n商÷と剰余%\n\n10 ÷ 3, 10 % 3\n\n(3, 1)\n\n\n\n\n累乗^\n\n5 ^ 3\n\n125\n\n\n\n\n平方根sqrt, √\n\nsqrt(13)\n\n3.605551275463989\n\n\n\n\n\n論理演算子\n\nAND演算&, and\n\ntrue & false\n\nfalse\n\n\n\n\nOR演算|\n\ntrue | false\n\ntrue\n\n\n\n\nXOR⊻\n\ntrue ⊻ false\n\ntrue\n\n\n\n\nNOT!\n\n! true\n\nfalse\n\n\n\n\n\n比較演算子\n\n同値==\n\n1 == 1.0 # 型が違う\n\ntrue\n\n\n\n\n～より大きい>=\n\n9.1 >= 0.0\n\ntrue\n\n\n\n\n～より小さい>=\n\n1 <= -1\n\nfalse\n\n\n\n\n～と異なる!=\n\n10 != 10\n\nfalse\n\n\n\n\n\n文字列の演算\n\n結合\n\nx, y = 3, 5\ns1, s2 = \"times\", \"equalsto\"\ns1 = \"$(x) $(s1) $(y) $(s2) $(x*y) !\" \n\n\"3 times 5 equalsto 15 !\"\n\n\n\n\n\n関数の定義\n\n関数の作り方1function ~ end\n\nfunction f1(x, y)\n  println(\"calc: $x ^ $y\")\n  return x ^ y\nend\nf1(5, 3)\n\ncalc: 5 ^ 3\n\n\n125\n\n\n\n\n関数の作り方2f(...)=...\n\nf2(x, y) = x ^ y\nf2(5, 3)\n\n125\n\n\n\n\n関数の作り方3f = (...) -> (...)\n\nf3 = (x, y) -> x ^ y\nf3(5, 3)\n\n125\n\n\n\n\nキーワード変数function f(...;...)\n※文字列を生成した後に表示しているため、表示の順序に注意\n\nfunction f4(x, y; c=1)\n  println(\"calc: $c * $x ^ $y\")\n  return c * x ^ y\nend\nprintln(\"$(f4(5, 3)) $(f4(5, 3, c=2))\")\n\ncalc: 1 * 5 ^ 3\ncalc: 2 * 5 ^ 3\n125 250\n\n\n\n\n\nブロードキャスト\n\nベクトルと定数の間の四則演算\n他の計算も大抵同じことができます\n\nv, a = [1.0, 2, 3], 3\n\nv1   = v .+ a # それぞれの要素に足し算\nv2   = v .- a # 　　　　　　　　引き算\nv3   = v .* a # 　　　　　　　　掛け算\nv4   = v ./ a # 　　　　　　　　割り算\n\nprintln(v1, v2, v3, v4)\n\n[4.0, 5.0, 6.0][-2.0, -1.0, 0.0][3.0, 6.0, 9.0][0.3333333333333333, 0.6666666666666666, 1.0]\n\n\n\n\n関数に対しても……\n\n# f(x) = x^2\nfunction f(x)\n  return x ^ 2\nend\nprintln(f.([1, 2, 3, 5]))\n\n[1, 4, 9, 25]"
  },
  {
    "objectID": "page-julia-langbasic-2.html",
    "href": "page-julia-langbasic-2.html",
    "title": "mysite",
    "section": "",
    "text": "Juliaの文法基礎\n\nif文\nif文は真理値(以下の(x == 0):: Bool)がtrueのとき内部のコードを実行します。\nif 真理値\n  コード\nend\n実際の例は以下の通りです：\n\n# x が 0 と等しい場合にそれを出力します。\nx = 0\nif x == 0 # x == 0 は比較演算子の返り値＝真理値型\n  println(\"$(x)と0は同じ値です\")\nend\n\n0と0は同じ値です\n\n\nif ~ else文は真理値がtrueのとき内部のコード1を実行し、それ以外の場合にelseの内部のコード2を実行します。\nif 真理値\n  コード1\nelse\n  コード2\nend\n実際の例は以下の通りです：\n\nx = 0\nif x == 0\n  println(\"$(x)と0は同じ値です\")\nelse\n  println(\"$(x)と0は異なります\")\nend\n\n0と0は同じ値です\n\n\n\nx = 1\nif x == 0\n  println(\"$(x)と0は同じ値です\")\nelse\n  println(\"$(x)と0は異なります\")\nend\n\n1と0は異なります\n\n\nif ~ elseif ~ else文は真理値1がtrueのときコード1を実行し、真理値k-1までがfalseのとき、真理値kがtrueならばコードkを実行します。また、真理値nまで実行してコードが全部実行できなかったとき、elseの内部のコードn+1を実行します。\nまあ要するに、上から順番にどの条件が真になるかを確かめて、実行していく感じです。\nif     真理値1\n  コード1\nelseif 真理値2\n  コード2\n...\nelseif 真理値k-1\n  コードk-1\nelseif 真理値k\n  コードk\n...\nelseif 真理値n\n  コードn\nelse \n  コードn+1\nend\n実際の例は以下の通りです：\n\nx = -3\nif x == 0\n  println(\"$(x)と0は同じ値です\")\nelseif -3 < x <= 3\n  println(\"$(x)は、集合(-3,+3]に含まれます\")\nelse\n  println(\"$(x)は集合(-∞, -3]と(+3, ∞)の和集合に含まれます\")\nend\n\n-3は集合(-∞, -3]と(+3, ∞)の和集合に含まれます\n\n\n\n\nfor文\nfor文は、n回連続で『似た』処理を実行したいときに使います。 何かの順番を持つオブジェクト（イテレーティブオブジェクト）に応じて、順次、内部のコード(i)を実行します。\nfor i = イテレーティブオブジェクト\n  コード(i)\nend\n\n# iとi^2をnまで足し合わせるプログラム\nn = 0\nk = 0\nfor i = 1:10 # UnitRange型オブジェクト\n  k = k + i\n  n = n + i^2\nend\nprintln(\"$n, $k\")\n\n385, 55\n\n\nベクトルでもできます。勿論、タプルでも……。\n\nn = 0\nk = 0\nfor i = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n  k = k + i\n  n = n + i^2\nend\nprintln(\"$n, $k\")\n\n385, 55\n\n\nベクトルとか行列を作りたいとき、for文を使った内包表記という書き方ができます。\n\n# 1から10まで、2乗の和を計算する\n[i^2 for i = 1:10]\n\n10-element Vector{Int64}:\n   1\n   4\n   9\n  16\n  25\n  36\n  49\n  64\n  81\n 100\n\n\n\n\nwhile文\nwhile文は真理値がtrueの間に限り内部のコードが実行されるループです。\nwhile 真理値\n  コード\nend\n\n# n^2の和を合計が1000を越えるまで足していく。\nn = 0\nN = 0\nwhile N < 1000\n  N = N + n^2\n  n = n + 1\nend\nprintln(\"0 から $(n-1) までの値の2乗の和は $N となる\")\n\n0 から 14 までの値の2乗の和は 1015 となる\n\n\n\n\ncontinue文\ncontinueはループfor, whileの内部のコードをその回の終了までスキップします。\n\n# １～１０までの間で偶数だけを出力する\nfor i = 1:10\n  if i % 2 == 1 \n    continue\n  end\n  println(\"$i は偶数です\")\nend\n\n2 は偶数です\n4 は偶数です\n6 は偶数です\n8 は偶数です\n10 は偶数です\n\n\n\n\nbreak文\nbreakはループfor, whileをその場で抜けます。\n\nfor i = 1:10\n  if i == 7\n    break\n  end\n  println(\"$i は 7 未満です\")\nend\n\n1 は 7 未満です\n2 は 7 未満です\n3 は 7 未満です\n4 は 7 未満です\n5 は 7 未満です\n6 は 7 未満です"
  },
  {
    "objectID": "page-julia-numericalanalysis-1.html",
    "href": "page-julia-numericalanalysis-1.html",
    "title": "mysite",
    "section": "",
    "text": "数値解析の基礎\n\nQR分解\nQR分解（QR decomposition）は、行列 \\(A\\) を直交行列 \\(Q\\) と上三角行列 \\(R\\) の積に分解する手法です。\nQR分解は数値解析や線形代数の応用分野で広く使われています。\n\\[\nA = QR\n\\]\nQR分解は正方行列に限らず、 \\(A \\in \\mathbb{R}^{m\\times n}, m \\ge n\\) の行列に適用できます。その時の式は以下の通りです。\nこの場合も \\(Q \\in \\mathbb{R}^{m \\times m}, R \\in \\mathbb{R}^{m \\times n}\\) の形式を使うのが一般的ですが、数値計算上の効率性を考えると \\(Q_1 \\in \\mathbb{R}^{m \\times n}, R_1 \\in \\mathbb{R}^{n \\times n}\\) の形式（エコノミー分解形式）を使う方がより適切です。\n\\[\nA = Q R = \\begin{bmatrix} Q_1 & Q_2 \\end{bmatrix} \\begin{bmatrix} R_1 \\\\ O \\end{bmatrix}\n  = Q_1 R_1\n\\]\n\n\nグラム・シュミットの直交化法\n「グラム・シュミットの直交化法によるQR分解」は、QR分解を分かりやすく説明するうえで重要なアルゴリズムです。\nただし、実際の実装では使いにくいため、このアルゴリズムを用いて数値計算を行うことは稀です。\n\n\n\n\ngraph LR\n  A[A] -- 直交化 --> B[Q]\n  B --> C[R]\n\n\n\n\n\n\n\n\n\n\\(A\\) からグラム・シュミットの直交化により、\\(Q\\) を構築\nグラム・シュミットの直交化は、ベクトル \\(\\{x_j \\in \\mathbb{R}^{m}\\}_{j=1}^{n}\\) を使って直交する \\(n\\) 本のベクトル \\(\\{e_j \\in \\mathbb{R}^{m}\\}_{j=1}^{n}\\) を作るアルゴリズムです。\nこの手法は、次のような漸化式で計算されます(\\(e_j\\) などは縦ベクトルを想定)。\nこれをプログラムで実装することを考える。\n\\[\ne_i = \\frac{u_i}{\\|u_i\\|}, \\;\\;\\; u_i = x_i - \\sum_{j=1}^{i-1} e_j e_j^\\mathrm{T} x_i, \\;\\;\\; e_1 = \\frac{x_1}{\\|x_1\\|}\n\\]\n\\(n\\) についての漸化式によって、\\(e_i\\) を求めるプログラムを実装すると、以下の通りになる。\n\nusing LinearAlgebra\n\nfunction e_orth!(x, E, i)\n    u = x - sum( E[:,j]' * x * E[:,j] for j = 1:i-1 )\n    e = u / norm(u)\n    E[:,i] = e\nend\n;\n\nよって、グラム・シュミットの直交化は以下のように実装される。\n\nfunction orth_gram_schmidt(X)\n   E = zeros(size(X))\n   E[:, 1] = X[:,1] / norm(X[:,1])\n   for i = 2:size(X, 2)\n       xi = X[:,i]\n       e_orth!(xi, E, i)\n   end\n   return E\nend\n\nE = orth_gram_schmidt(rand(3, 3))\nE' * E # 単位行列になっている。\n\n3×3 Matrix{Float64}:\n  1.0          2.25514e-16  -1.02349e-16\n  2.25514e-16  1.0           2.22045e-16\n -1.02349e-16  2.22045e-16   1.0\n\n\n\n\n\\(Q\\) から \\(R\\) を構築\n作成した直交行列を用いると、行列 \\(A=[a_1, a_2, ..., a_n]\\) の各ベクトル \\(a_i\\) は以下のように表現されることになります。\n\\[\na_i = \\sum_{j=1}^{i} e_j e_j' a_i = [e_1, \\dots, e_i, e_{i+1}, \\dots, e_n] \\begin{bmatrix}e_1' a_i \\\\ \\vdots \\\\ e_i' a_i \\\\ 0 \\\\ \\vdots \\\\ 0 \\end{bmatrix}\n\\]\nよって、\\(A\\) は以下のようになります。\n\\[\nA = \\begin{bmatrix}\n  e_1'a_1 & e_1'a_2 & e_1'a_3 & \\dots \\\\\n  0       & e_2'a_2 & e_2'a_3 & \\dots \\\\\n  0       & 0       & e_2'a_3 & \\dots \\\\\n  \\vdots  & \\vdots  & \\vdots  & \\vdots\n\\end{bmatrix}\n\\]\nこれをプログラムで実装すると、以下の通りになります。\n\nfunction Q_to_R(Q, A)\n    n = size(A, 2)\n    R = zeros(n, n)\n    for i = 1:n\n        for j = i:n\n            ei, aj = Q[:,i],  A[:,j]\n            R[i,j] = ei' * aj\n        end\n    end\n    return R\nend\n\nA = rand(5, 4)\nQ = orth_gram_schmidt(A)\nR = Q_to_R(Q, A)\n\n4×4 Matrix{Float64}:\n 1.18889  1.30738   0.609978  1.05868\n 0.0      0.647188  0.401242  0.657774\n 0.0      0.0       0.575256  0.658712\n 0.0      0.0       0.0       0.594718\n\n\n\n\nQR分解の実装\nグラム・シュミットの直交化法によりQR分解を行う関数myqr_gram_schmidtは以下の通りになります。\n\nfunction myqr_gram_schmidt(A)\n    Q = orth_gram_schmidt(A)\n    R = Q_to_R(Q, A)\n    return Q, R\nend\n\nA = rand(6, 4)\nQ, R = myqr_gram_schmidt(A)\n\nnorm(A - Q*R) \n\n4.526797389797801e-16\n\n\n\n\n\nハウスホルダー法\n「ハウスホルダー法によるQR分解」は、QR分解の実用的なアルゴリズムの１つです。\n\n\n\n\ngraph LR\n  A[A] --> B[A']\n  B -- 変換 --> C[Qi]\n  C -- 小行列化 --> B\n  C --> D[R]\n\n\n\n\n\n\n\n\n\nハウスホルダー変換の意味\nハウスホルダー変換とは、法線ベクトル \\(e\\) の超平面に対して対称に点を写す変換のことです。\n変換を表す以下の行列 \\(H\\) は直交行列かつ対称行列です。\n\\[\nH = I - 2 e e^\\mathrm{T}\n\\]\nハウスホルダー変換は直交変換であるため、どんな超平面を選んでも元のベクトルのノルムを半径とした超球面上にしか変換を行うことはできないことに注意します。\nそうすると、例えば、以下のような変換を行うように \\(e\\) を選んでやることもできます。\n\\[\ny = Hx, \\;\\;\\;  y = \\begin{bmatrix} \\|x\\| \\\\ 0_{m-1} \\end{bmatrix}\n\\]\nこのときの \\(e\\) は以下のベクトルになる。\n\\[\ne =\\frac{x-y}{\\|x-y\\|}\n\\]\n\n\nQR法でのハウスホルダー変換\n以下、全体の変換により得られる行列を \\(A_i\\) 、行列Aを変換していく際の小行列として表れる行列を \\(B_i\\) と定めます。\n\\[\nA_1 = A = B_1\n\\]\n行列 \\(A_1 = A=[a_!, \\dots , a_n]\\) に対して、 \\(x=a_1, \\;\\;\\; y=[\\|x\\|, 0_{m-1}^\\mathrm{T}]^\\mathrm{T}\\) とした時のハウスホルダー変換行列 \\(H_1\\) を作用させると以下のようになります。\n\\[\nA_2 = H_1 A_1 = [H_1 a_1 , \\dots , H_1 a_n] =\n\\begin{bmatrix}\n    \\|a_1\\| & * \\\\\n    0_{m-1} & B_2\n\\end{bmatrix}\n\\]\nここで、小行列を逐次作用させていくことで、\\(k\\) 次上三角行列 \\(R_k\\) と小行列 \\(B_k\\) により、以下のような行列が作れるものとする。\n\\[\nA_k =\n\\begin{bmatrix}\n    R_k & * \\\\\n    O   & B_{k}\n\\end{bmatrix}\n\\]\nここで、\\(B_k\\) という行列に対しても同じようにハウスホルダー変換を施すことができるので、その行列を \\(H_k\\) とすると、以下のように、\\(A_k\\) から \\(A_{k+1}\\) を得る式が求められます。\n\\[\n\\begin{bmatrix}\n    I & O^\\mathrm{T}\\\\\n    O   & H_{k}\n\\end{bmatrix}\nA_k\n=\n\\begin{bmatrix}\n    I & O^\\mathrm{T}\\\\\n    O   & H_{k}\n\\end{bmatrix}\n\\begin{bmatrix}\n    R_k & * \\\\\n    O   & B_{k}\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n    R_k & *\\\\\n    O   & H_{k}B_{k}\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n    R_{k+1} & * \\\\\n    O       & B_{k+1}\n\\end{bmatrix}\n=\nA_{k+1}\n\\]\n\n\nQR法でのハウスホルダー変換の漸化式\nまとめると、\\(Q\\)、\\(R\\) を構築する以下の漸化式が得られます。\n\\[\nR = A_n, \\;\\;\\; Q = Q_1^\\mathrm{T} Q_2^\\mathrm{T} \\dots Q_t^\\mathrm{T}, \\;\\;\\; t=\\text{min}(m-1, n)\n\\]\n\\[\nA_{k+1} = Q_k A_k, \\;\\;\\; A_k=\\begin{bmatrix} R_k & * \\\\ O & B_k \\end{bmatrix} \\;\\;\\; A_1 = A = B_1\n\\]\nここで、直行行列 \\(Q_k\\) は以下の式で表されます。 なお、\\(I\\) は \\(k\\) 次単位行列、\\(O\\) はそれぞれの大きさのゼロ行列です。\n\\[\nQ_k =\n\\begin{bmatrix}\n    I & O^\\mathrm{T}\\\\\n    O   & H_{k}\n\\end{bmatrix}, \\;\\;\\;\nH_k = I - 2 ee', \\;\\;\\;\ne =\\frac{x-y}{\\|x-y\\|}, \\;\\;\\;\nx = b_1, \\;\\;\\;\ny=\\begin{bmatrix} \\|b_1\\| \\\\ 0 \\end{bmatrix}, \\;\\;\\;\nb_1 = B_k[:, 1]\n\\]\n\n\nQR分解の実装\nハウスホルダー変換を行う行列を生成するプログラムは以下の通りです。\n\nusing LinearAlgebra\n\n# e を使って行列 H_k を構築する。\nH(e)    = Matrix{Float64}(I, length(e), length(e)) - 2 * e * e'\n\n# x, y を使って行列 H_k を構築する。\nH(x, y) = H((v -> v / norm(v))(x - y))\n\n# b1 を使って行列 H_k を構築する。\nfunction Bk_to_Hk(Bk)\n    b1 = Bk[:,1]\n    x  = b1\n    y  = zeros(size(b1)); y[1] = norm(b1)\n    return H(x, y)\nend\n\n# 行列 Q_k を構築する。\nfunction Ak_to_Qk!(Qk, Ak, k)\n    Qk[:, :] .= 0\n    Qk[1:k, 1:k]     = Matrix{Float64}(I, k, k)\n    Qk[k:end, k:end] = Bk_to_Hk(Ak[k:end, k:end])\nend\n;\n\n以下のように、本来計算上0になるべき部分にごく小さい値が入っているため、効率はやや悪いですが、細かい部分なのでそこを気にするのは取り敢えず止めておきます。\n\nA = rand(5, 5)\nQ = zeros(size(A))\nAk_to_Qk!(Q, A, 1)\nQ * A\n\n5×5 Matrix{Float64}:\n  1.00313       0.920552   0.768176    0.749072    1.33285\n  1.18378e-17   0.35075    0.441408    0.0692224   0.158048\n -8.65606e-18  -0.104659   0.48109     0.240854    0.724849\n -1.06844e-17  -0.141282  -0.112075   -0.325437    0.23565\n -3.9054e-17   -0.503089   0.0529677  -0.130842   -0.48772\n\n\n漸化式を適用していく部分を実装すると以下の通りになります。\n\nfunction A_next!(Q, Qk, Ak, k)\n    Ak_to_Qk!(Qk, Ak, k)\n    Ak .= Qk*Ak \n    Q  .= Q*Qk'\nend\n;\n\nQR分解の実装は以下の通りになります。\n\nfunction myqr_house(AA)\n    m, n  = size(AA)\n    Ak = copy(AA)\n    Qk = zeros(m, m)\n    Q  = Matrix{Float64}(I, m, m)\n    t = min(m-1, n)\n    for k = 1:t\n        A_next!(Q, Qk, Ak, k)\n    end\n    R = Ak\n    return Q, R\nend\n\nA = rand(4, 4)\nQ, R = myqr_house(A)\n\nnorm(A - Q*R)\n\n6.715136547999446e-16\n\n\n参考\n\n\n\nギブンス回転\n「ギブンス回転」を用いる方法は、QR分解の実用的なアルゴリズムの１つです。 並列化に向いている手法です。\n説明は暇があったら書きます。\n\n# 行列の下三角の部分だけを返す\nfunction tril_indices(m, n)\n    idx = []\n    for i = 1:m\n        for j = 1:i-1\n            if j > n\n                break\n            end\n            push!(idx, (i,j))\n        end\n    end\n    return idx\nend\n;\n\n\nfunction cos_givens_rotation(a, b)\n    r = √(a^2 + b^2)\n    rot = [\n        a/r -b/r; #  cos sin\n        b/r  a/r  # -sin cos\n    ]\n    return rot\nend\n\n\nfunction myqr_givens_rotation(A)\n    m, n = size(A)\n    Q = Matrix{Float64}(I, m, m)\n    R = copy(A)\n    for ij = tril_indices(m, n)\n        i, j = ij\n        if R[i, j] == 0\n            continue\n        end\n        G = Matrix{Float64}(I, m, m)\n        G[[j, i], [j, i]] = cos_givens_rotation(R[j, j], R[i, j])\n\n        R = G * R\n        Q = Q * G'\n    end\n    return Q, R\nend\n;\n\n\nA = rand(6, 4)\nQ, R = myqr_givens_rotation(A)\n\nnorm(A - Q*R)\n\n9.987428430015201e-16\n\n\n参考"
  },
  {
    "objectID": "page-julia-linearalgebra-1.html",
    "href": "page-julia-linearalgebra-1.html",
    "title": "mysite",
    "section": "",
    "text": "線形代数\n\n行列とは？\n行列は、数値や変数を配列したものです。 行と列からなる2次元のデータ構造で、さまざまな分野で広く使用されています。\n一般的な行列は、以下のように表現されます: \\[\n\\begin{bmatrix}\na_{11} & a_{12} & \\ldots & a_{1n} \\\\\na_{21} & a_{22} & \\ldots & a_{2n} \\\\\n\\vdots & \\vdots & \\ddots & \\vdots \\\\\na_{m1} & a_{m2} & \\ldots & a_{mn} \\\\\n\\end{bmatrix}\n\\]\n行列における加減乗除は、以下のように計算できます。\n\nA = [\n    1 2  1;\n    4 5 -2;\n    3 2 1.0\n]\nB = [\n    -1 5  6;\n     4 3 -7;\n     2 4 9.0\n]\n;\n\n行列の和\n\nA + B\n\n3×3 Matrix{Float64}:\n 0.0  7.0   7.0\n 8.0  8.0  -9.0\n 5.0  6.0  10.0\n\n\n行列の差\n\nA - B\n\n3×3 Matrix{Float64}:\n 2.0  -3.0  -5.0\n 0.0   2.0   5.0\n 1.0  -2.0  -8.0\n\n\n行列の積\n\nA * B\n\n3×3 Matrix{Float64}:\n  9.0  15.0    1.0\n 12.0  27.0  -29.0\n  7.0  25.0   13.0\n\n\n行列の除算(逆行列の作用)\n\nA \\ B\n\n3×3 Matrix{Float64}:\n  1.5       -0.5       1.5\n -0.777778   1.77778  -0.444444\n -0.944444   1.94444   5.38889\n\n\n行列の転置\n\nA'\n\n3×3 adjoint(::Matrix{Float64}) with eltype Float64:\n 1.0   4.0  3.0\n 2.0   5.0  2.0\n 1.0  -2.0  1.0\n\n\n\n\n行列の便利さ\n線形代数における行列は非常に重要です。 行列は、数値の集合を整理し、ベクトルや線形写像の表現や解析に利用されます。 以下に、行列の重要性をいくつか説明します。\n※内容について詳しく理解する必要はありません。\n\n線形写像の表現\n行列は線形写像を表現するための重要な道具です。 線形写像はベクトル空間から別のベクトル空間への線形な変換を表すものであり、例えば、以下のような表現ができます。 \\[ f(x) = Ax \\] \\[g \\bullet f(x) = BAx \\]\n線形方程式の解法\n行列は線形方程式の解法にも使用されます。 線形方程式は未知の変数に関する線形な等式の集合です。 \\[ Ax = b \\]\n固有値と固有ベクトル\n行列の固有値と固有ベクトルは、線形写像の特性を表す重要な概念です。 固有値とは、線形写像がベクトルに対して与える変換のスケールを表し、固有ベクトルはそのスケールが現れる方向を表します。行列の固有値と固有ベクトルを求めることで、線形写像の性質や変換の効果を理解することができます。固有値分解や特異値分解などの手法も、行列の固有値と固有ベクトルを利用しています。 \\[ Ax=\\lambda x \\]\nデータ解析と機械学習\n行列はデータ解析や機械学習の分野でも広く利用されます。例えば、多次元データを行列の形で表現することで、特徴ベクトルや特徴行列を得ることができます。これにより、データの類似性や相関関係を解析したり、機械学習アルゴリズムによるパターン識別や予測を行うための入力として利用することができます。また、行列の演算や変換を用いて、データの次元削減や特徴抽出などの処理も行われます。\n線形独立性と行列のランク\n行列の線形独立性と行列のランクは、ベクトルや行列の性質を理解する上で重要な概念です。行列の線形独立性は、ベクトルや行列の組が線形的に独立しているかどうかを示し、行列のランクはその独立な列または行の最大の数を表します。線形独立性とランクは、行列の性質や特徴を解析する際に役立ちます。\n\n\n\n有名な行列\n一般的な名前のついた行列について、可能な限り網羅します。 また、その性質についても説明します。\n\nゼロ行列（Zero Matrix）：すべての要素が0の行列です。\nゼロ行列は行列演算の加法単位元(「……？」って人はとりあえず無視)です。\nJuliaでのゼロ行列の作成方法は次の通りです。\n\nusing LinearAlgebra\n# 3x3のゼロ行列\nO = zeros(3, 3)\nO\n\n3×3 Matrix{Float64}:\n 0.0  0.0  0.0\n 0.0  0.0  0.0\n 0.0  0.0  0.0\n\n\n\n任意の行列Aとゼロ行列Oの和は元の行列Aと等しくなります。 \\[ A+O = O+A \\]\n任意の行列Aとゼロ行列Oの積はゼロ行列となります。 \\[ AO = OA = O \\]\nゼロ行列は任意のスカラー倍によってゼロ行列となります。 \\[ cO = Oc = O, c \\in \\mathbb{R} \\]\n\n\n\n単位行列（Identity Matrix）：主対角線上の要素がすべて1で、それ以外の要素が0の行列です。\n単位行列はは行列演算の乗法単位元です。\nJuliaでの単位行列の作成方法は次の通りです。\n\n# 3x3の単位行列\nE = Matrix{Float64}(I, 3, 3)\nE\n\n3×3 Matrix{Float64}:\n 1.0  0.0  0.0\n 0.0  1.0  0.0\n 0.0  0.0  1.0\n\n\n\n任意の行列Aと単位行列Iの積は元の行列Aと等しくなります。 \\[ A * I = I * A = A \\]\n単位行列を任意の非負定数乗すると、同じ単位行列が得られます。 \\[ I^n = I \\]\n逆行列は単位行列となる。 \\[ II^{-1} = I^{-1}I = I \\]\n単位行列は、対称行列である。\n\n\n\n対角行列（Diagonal Matrix）：主対角線上以外の要素がすべて0で、主対角線上の要素が非ゼロの行列です。\nJuliaでの対角行列の作成方法は次の通りです。\n\n# 3x3の対角行列（対角要素：1, 2, 3）\nD = Diagonal([1, 2, 3])\nD\n\n3×3 Diagonal{Int64, Vector{Int64}}:\n 1  ⋅  ⋅\n ⋅  2  ⋅\n ⋅  ⋅  3\n\n\n\n\n対称行列（Symmetric Matrix）：転置しても元の行列と等しい行列です。主対角線を中心に対称な要素を持ちます。\nJuliaでの対称行列の作成方法は次の通りです。\n\n# 3x3の対称行列\nSym = Symmetric(\n    [1 2 3;\n     2 4 5;\n     3 5 6]\n)\nSym\n\n3×3 Symmetric{Int64, Matrix{Int64}}:\n 1  2  3\n 2  4  5\n 3  5  6\n\n\n\n転置した行列と等しい。 \\[ D^\\mathrm{T} = D \\]\n対称行列の和は対称行列になる。 \\[ (D_1 + D_2)D_1^\\mathrm{T} = D_1 + D_2 \\]\n要素全てが実数のエルミート行列である。\n\n\n\n上三角行列（Upper Triangular Matrix）：主対角線より下の要素がすべて0である行列です。\nJuliaでの上三角行列の作成方法は次の通りです。\n\n# 3x3の上三角行列（対角要素：1, 2, 3）\nUT = UpperTriangular(\n    [1 2 3; \n     0 4 5; \n     0 0 6]\n)\nUT\n\n3×3 UpperTriangular{Int64, Matrix{Int64}}:\n 1  2  3\n ⋅  4  5\n ⋅  ⋅  6\n\n\n\n\n下三角行列（Lower Triangular Matrix）：主対角線より上の要素がすべて0である行列です。\nJuliaでの下三角行列の作成方法は次の通りです。\n\n# 3x3の下三角行列（対角要素：1, 2, 3）\nLT = LowerTriangular(\n    [1 0 0;\n     2 3 0;\n     4 5 6]\n)\nLT\n\n3×3 LowerTriangular{Int64, Matrix{Int64}}:\n 1  ⋅  ⋅\n 2  3  ⋅\n 4  5  6\n\n\n\n\nエルミート行列（Hermitian Matrix）：転置共役しても元の行列と等しい行列です。主対角線を中心にエルミート（共役転置）な要素を持ちます。\nJuliaでのエルミート行列の作成方法は次の通りです。\n\n# 3x3のエルミート行列\nHermit = Hermitian(\n    [1     2+3im 4-1im;\n     2-3im 5     6+2im;\n     4+1im 6-2im 7     ]\n)\nHermit\n\n3×3 Hermitian{Complex{Int64}, Matrix{Complex{Int64}}}:\n 1+0im  2+3im  4-1im\n 2-3im  5+0im  6+2im\n 4+1im  6-2im  7+0im\n\n\n\n\nフロベニウス行列（Frobenius Matrix）：非負整数の正方行列で、各行の要素が行番号と列番号の積と等しい行列です。\nJuliaでのフロベニウス行列の作成方法は次の通りです。\n\nusing SpecialMatrices\n# 3x3のフロベニウス行列\nFrobenius(3, [1, 2, 3])\n\n6×6 Frobenius{Int64}:\n 1  0  0  0  0  0\n 0  1  0  0  0  0\n 0  0  1  0  0  0\n 0  0  1  1  0  0\n 0  0  2  0  1  0\n 0  0  3  0  0  1\n\n\n\n\n巡回行列（Circulant Matrix）：行列の各行が循環的にシフトされた結果得られる行列です。\nJuliaでの巡回行列の作成方法は次の通りです。\n\nusing ToeplitzMatrices\n# 3x3の巡回行列\nCirculant([1, 2, 3])\n\n3×3 Circulant{Int64, Vector{Int64}}:\n 1  3  2\n 2  1  3\n 3  2  1\n\n\n\n\nハンケル行列（Hankel Matrix）：対角線から左上方向と右下方向に同じ要素が並ぶ行列です。\nJuliaでのハンケル行列の作成方法は次の通りです。\n\n# 3x3のハンケル行列\nHankel([1,2,3,4,5,6], (3,4))\n\n3×4 Hankel{Int64, Vector{Int64}, Tuple{Int64, Int64}}:\n 1  2  3  4\n 2  3  4  5\n 3  4  5  6"
  },
  {
    "objectID": "page-julia-linearalgebra-2.html",
    "href": "page-julia-linearalgebra-2.html",
    "title": "mysite",
    "section": "",
    "text": "線形代数\n行列の分解手法は沢山ありますが、固有値分解は最も汎用的に役立つ例の一つです。\n\n固有値と固有ベクトル\n固有値（Eigenvalues）と固有ベクトル（Eigenvectors）は、線形代数において重要な概念です。 これらの対（組）を固有対（eigenpair）と呼ぶことがあります。 固有値と固有ベクトルは、行列に対して特定の性質を持つベクトルとスカラー値です。\n行列Aが与えられたとき、ベクトル \\(v\\) とスカラー \\(\\lambda\\) に対して以下の式が成り立つとき、\\(v\\) を \\(A\\) の固有ベクトル、\\(\\lambda\\) を \\(A\\) の固有値と呼びます。\n\\[ A v = \\lambda v \\]\nこの式は、行列 \\(A\\) によってベクトル \\(v\\) が \\(\\lambda\\) 倍に変換されることを表しています。 固有ベクトルは方向が変化せずにスケールされるため、行列の変換の中で特別な役割を果たします。\n固有ベクトルは、行列を関数として扱いたいときに効力を発揮します。 超便利！\n行列が異なる固有値を持つ \\(n\\) 個の線形独立な固有ベクトルを持つ場合、その行列は対角化可能だと言えます。 この『対角化』とは、行列 \\(A\\) を以下の形式で表せるということです。 実際、式をいじってみるとこうなります。 \\[ A = PDP^{-1} \\]\nJuliaで固有値、固有ベクトルを求める方法は以下の通りです：\n\nusing LinearAlgebra\nA = rand(3, 3)\nF = eigen(A) # F.valuesが固有値, F.vectorsが固有ベクトル\nF\n\nEigen{ComplexF64, ComplexF64, Matrix{ComplexF64}, Vector{ComplexF64}}\nvalues:\n3-element Vector{ComplexF64}:\n -0.17368081196005505 - 0.3039770069012261im\n -0.17368081196005505 + 0.3039770069012261im\n   1.5431914300861154 + 0.0im\nvectors:\n3×3 Matrix{ComplexF64}:\n  0.526931+0.302582im   0.526931-0.302582im  0.532166+0.0im\n -0.251746-0.400011im  -0.251746+0.400011im  0.644524+0.0im\n -0.638281-0.0im       -0.638281+0.0im       0.548988+0.0im\n\n\nF.valuesを見ると内部が昇順にソートされてるのが分かると思います。 固有値は大きさで挙動が変わるので確かめておくと便利です。\nちなみに、固有値の定義から以下のように計算すると、実際に値が正しいか確認できます。\n\nP, D = F.vectors, diagm(F.values)\nA - P * D * inv(P)\n\n3×3 Matrix{ComplexF64}:\n -2.22045e-16-0.0im  -1.11022e-15+3.04406e-17im   7.21645e-16-2.61836e-17im\n -2.22045e-16-0.0im   3.33067e-16+3.68676e-17im  -1.11022e-16-4.55896e-17im\n -3.33067e-16-0.0im  -1.11022e-16+3.14028e-17im   1.11022e-16-8.25225e-17im\n\n\n誤差が十分小さいので、\\(A\\) を表現できたと確認できましたね。\nもし、使いたい行列が \\(A=PDP^{-1}\\) となったとしたら、そのことは凄く重要な意味を持ちます。\n\n\n固有値の性質\n\nトレースが全ての固有値の和になる\n\n\ntr(A) - sum(F.values)\n\n2.220446049250313e-16 - 0.0im\n\n\n\n行列式が全ての固有値の積になる。\n\n\ndet(A) - prod(F.values)\n\n-3.885780586188048e-16 - 0.0im\n\n\n\n逆行列が固有値の逆数で簡単に求められる（後述する行列関数の特殊ケース）\n\n\ninv_D = diagm(F.values .^ -1)\ninv(A) - (P * inv_D * inv(P))\n\n3×3 Matrix{ComplexF64}:\n 1.44329e-15-0.0im  -8.88178e-16+1.27824e-17im  8.88178e-16-1.22017e-16im\n 8.88178e-16-0.0im  -1.77636e-15+1.54812e-17im  6.66134e-16-1.33162e-17im\n  -2.498e-15-0.0im   1.77636e-15+1.31865e-17im          0.0+9.96799e-17im\n\n\n\n行列関数の高速計算に使える。 \\(A^n\\) みたいな計算を特に考えずに \\(AAA...AA\\) と行列の積で計算しようとする相当なコストがかかります。 なぜなら、\\(A\\) が \\(m\\times m\\) 行列だとすれば、単純な掛け算が \\(O(nm^3)\\) も行われるからです。 しかし、固有値を使うと、\\(A=PDP^{-1}\\) より、\\(A^n = A=P D^n P^{-1}\\) になります。 計算量は（固有値分解に係るコストを無視すれば）相当に抑えることができます。\n\n\nn = 10\nA^n - P * (D^n) * inv(P)\n\n3×3 Matrix{ComplexF64}:\n -7.81597e-14-0.0im   -7.4607e-14+1.51088e-15im  -2.13163e-14-1.29959e-15im\n -8.52651e-14-0.0im  -7.81597e-14+1.82988e-15im  -1.77636e-14-1.57398e-15im\n -8.52651e-14-0.0im  -7.81597e-14+1.55864e-15im   -2.4869e-14-1.34068e-15im\n\n\n\n\n行列関数\n行列関数（Matrix function）は、行列を入力として受け取り、行列を出力する関数です。 通常の数値関数がスカラーを操作するのに対して、行列関数は行列を操作するための特殊な関数です。 行列関数は線形代数や数値計算、物理学、統計学などの分野で広く使用されます。\nJuliaでは行列関数が標準で実装されているものが多く、固有値分解は勝手にやってくれてます。\n行列関数の具体的な例としては、以下のようなものがあります。\n\n行列の \\(n\\) 乗 \\[ A^n = P D^n P^{-1} \\]\n\n\nA ^ 5\n\n3×3 Matrix{Float64}:\n 3.55706  2.68683  1.88119\n 4.31038  3.26062  2.2685\n 3.6689   2.78246  1.92869\n\n\n\n行列の指数関数 行列指数関数は指数関数を行列に適用したもので、指数級数を用いて定義されます。 行列指数関数は、物理学や制御工学などで連立微分方程式の解を求める際に使用されます。 内部の詳細な仕様は知りませんが、固有値を使うと以下のように書けます。 \\[ e^{A} = P e^{D} P^{-1} \\]\n\n\nexp(A)\n\n3×3 Matrix{Float64}:\n 2.31989  1.47959   0.55023\n 1.89464  2.07686   1.21898\n 1.75728  0.927806  1.88681\n\n\n\n行列の対数関数 行列対数関数は対数関数を行列に適用したもので、行列指数関数の逆操作となります。 行列対数関数は、行列の対角化や行列の対称性を利用するなどの目的で使用されます。 \\[ \\log A = P \\log D P^{-1} \\]\n\n\nlog(A)\n\n3×3 Matrix{Float64}:\n -0.931117   2.84258  -2.01411\n  0.611082  -1.90257   2.15066\n  1.7123    -2.03951   1.16845\n\n\n\n行列の三角関数 行列の三角関数には行列のサイン、コサイン、タンジェントなどがあります。これらの関数は行列の固有値や固有ベクトルの計算、回転行列の操作などで使用されます。 \\[ \\sin A = P \\sin D P^{-1} \\]\n\n\nsin(A)\n\n3×3 Matrix{Float64}:\n 0.228515  0.710166    -0.0862748\n 0.563834  0.0543052    0.563262\n 0.653641  0.00929941   0.355089\n\n\n\n一般の関数 関数 \\(f(x)\\) のフーリエ級数が収束するなど、ある程度良い条件のもとでは、一般の関数 \\(f(x)\\) に対しても行列関数を適用できます。 \\[ f(x) = P f(D) P^{-1} \\]\n\n\nfunction f_MatrixFunction(f, A)\n  F    = eigen(A)\n  P, D = F.vectors, diagm(F.values)\n  f_D = diagm(f.(F.values))\n  return P * f_D * inv(P)\nend\n\nf_MatrixFunction(x -> tan(x+pi), A)\n\n3×3 Matrix{ComplexF64}:\n 14.5569+0.0im  11.5316-7.14392e-16im  7.45733+5.86732e-16im\n 17.8917+0.0im  13.1833-8.65224e-16im  9.69777+7.58104e-16im\n 15.4125+0.0im  11.1748-7.36975e-16im  8.15657+6.33912e-16im"
  },
  {
    "objectID": "page-julia-calculus-1.html",
    "href": "page-julia-calculus-1.html",
    "title": "mysite",
    "section": "",
    "text": "微分積分\n微分積分額について説明します。 あまり厳密には扱いません。\n\n微分と積分\n微分と積分は、数学の基本的な操作であり、相互関係を持つ重要な概念です。 微分は関数の変化率を求める操作であり、積分は関数の面積や累積量を求める操作です。 以下にそれぞれの操作を説明し、相互関係についても触れます。\n微分（Differentiation）は、関数の微小な変化率や勾配を求める操作です。ある関数の微分は、その関数の各点での傾きを表します。微分は関数の変化を詳細に分析するために使用され、物理学や経済学などの科学的なモデリングにおいても重要です。 \\[ \\frac{d}{dx} F(x) = f(x) \\] 左辺は以下の極限で表すこともできます。 実用上、とても大切な式です。 \\[ \\lim_{\\delta x -> 0} \\frac{f(x + \\delta x) - f(x)}{\\delta x} \\]\n積分（Integration）は、関数の面積や累積量を求める操作です。積分は関数を積み上げることにより、元の関数が表す領域の面積や累積を求めます。積分は、物理学の運動方程式の解析や確率論の確率密度関数の計算などで使用されます。 \\[ F(x) = \\int_{c}^{x} f(t) dt \\]\n微分と積分の相互関係は、微分と積分の逆操作を表します。\n\n微分と積分の関係 微分と積分は基本的な定理によって関連付けられています。 ニュートン・ライプニッツの基本定理によれば、ある関数f(x)の積分とその関数の原始関数F(x)の微分は互いに逆の関係にあります。 \\[ \\int_{a}^{b} f(x) dx = F(b) - F(a)  \\]\nこの定理により、積分は微分の逆操作として捉えることができます。\n\n具体的には、関数f(x)を微分して得られる導関数f’(x)を求め、その導関数を積分すると元の関数f(x)が得られます。\n\\[ \\frac{d}{dx} f(x) = f'(x) \\]\n\\[ \\int f'(x) dx = f(x) + C \\]\nここで、Cは積分定数です。微分と積分の逆操作によって、元の関数を復元することができます。\nこのように、微分と積分は相互に関連しており、微分によって関数の変化率や勾配を求め、積分によって関数の面積や累積量を求めることができます。微分と積分は数学の基礎であり、物理学、経済学、工学、統計学などのさまざまな分野で広く応用されています。\n数値積分、数値微分は数値解析の説明に譲ります。\n\n\n微分公式\nそれぞれの微分公式をJuliaで確認しましょう。\nSymPyでは微分積分などを扱えますが、対応していない計算に対しては動作しないので過信しないでください。\n\n\n\\(f(x)=x^n\\)\n微分すると、 \\(f'(x)=nx^{n-1}\\) となる。 これをJuliaで書くと以下のようになる:\n\nusing SymPy\n@vars x\ndiff(x^10, x)\n\n\\(10 x^{9}\\)\n\n\n\n\n\n\\(f(x)=\\sin(x), g(x)=\\cos(x)\\)\n微分すると、 \\(f'(x)=\\cos(x), g'(x)=-\\sin(x)\\) となる。 これをJuliaで書くと以下のようになる:\n\ndisplay.(\n    (diff(sin(x), x), diff(cos(x), x))\n);\n\n\\(\\cos{\\left(x \\right)}\\)\n\n\n\\(- \\sin{\\left(x \\right)}\\)\n\n\n\n\n\n\\(f(x)=e^x\\)\n微分すると、 \\(f'(x)=e^x\\) となる。 これをJuliaで書くと以下のようになる:\n\ndiff(exp(x), x)\n\n\\(e^{x}\\)\n\n\n\n\n\n\\(f(x)=a^x\\)\n微分すると、 \\(f'(x)= a^x \\log(a)\\) となる。 これをJuliaで書くと以下のようになる:\n\ndiff(10^x, x)\n\n\\(10^{x} \\log{\\left(10 \\right)}\\)\n\n\n\n\n\n\\(f(x)=e^x\\)\n微分すると、 \\(f'(x)=e^x\\) となる。 これをJuliaで書くと以下のようになる:\n\ndiff(exp(x), x)\n\n\\(e^{x}\\)\n\n\n\n\n\n\\(f(x)=\\log(x)\\)\n微分すると、 \\(f'(x)=\\frac{1}{x}\\) となる。 これをJuliaで書くと以下のようになる:\n\ndiff(log(x), x)\n\n\\(\\frac{1}{x}\\)\n\n\n\n\n\n\\(f(x)=\\sinh(x), g(x)=\\cosh(x)\\)\n微分すると、 \\(f'(x)=\\cosh(x), g'(x)=\\sinh(x)\\) となる。 これをJuliaで書くと以下のようになる:\n\ndisplay.(\n    (diff(sinh(x), x), diff(cosh(x), x))\n);\n\n\\(\\cosh{\\left(x \\right)}\\)\n\n\n\\(\\sinh{\\left(x \\right)}\\)\n\n\n\n\n\n関数の和 \\(h(x)=(f+g)(x)\\)\n微分すると、 \\(h'(x)=(f'+g')(x)\\) となる。 これをJuliaで書くと以下のようになる:\n\nf = sympy.Function(\"f\")(x)\ng = sympy.Function(\"g\")(x)\ndiff((f + g)(x), x)\n\n\\(\\frac{d}{d x} f{\\left(x \\right)} + \\frac{d}{d x} g{\\left(x \\right)}\\)\n\n\n\n\n\n関数の積 \\(h(x)=f(x)g(x)\\)\n微分すると、 \\(h'(x)=(f'*g)(x)+(f*g')(x)\\) となる。 これをJuliaで書くと以下のようになる:\n\nf = sympy.Function(\"f\")(x)\ng = sympy.Function(\"g\")(x)\ndiff((f * g)(x), x)\n\n\\(f{\\left(x \\right)} \\frac{d}{d x} g{\\left(x \\right)} + g{\\left(x \\right)} \\frac{d}{d x} f{\\left(x \\right)}\\)\n\n\n\n\n\n合成関数 \\(h(x)=f(g(x))\\)\n微分すると、 \\(h'(x)=f'(g(x))g'(x)\\) となる。 これをJuliaで書くと以下のようになる:\n\nf = sympy.Function(\"f\")(x)\ng = sympy.Function(\"g\")(x)\ndiff(f(g(x)), x)\n\n\\(\\frac{d}{d g{\\left(x \\right)}} f{\\left(g{\\left(x \\right)} \\right)} \\frac{d}{d x} g{\\left(x \\right)}\\)\n\n\n\n\n\n例えば……合成関数 \\(f(x)=\\sin(x^{10})\\)\n微分すると、 \\(f'(x)=10x^9 cos(x^{10})\\) となる。 これをJuliaで書くと以下のようになる:\n\ndiff(sin(x^10), x)\n\n\\(10 x^{9} \\cos{\\left(x^{10} \\right)}\\)\n\n\n\n\n\n\n積分公式\nそれぞれの積分公式をJuliaで確認しましょう。\nなお、今回は積分定数を無視します。\n\n\n\\(f(x)=x^n, g(x)=\\frac{1}{x}\\)\n積分すると、\\(F(x)=\\frac{1}{n+1}x^{n+1}, G(x)=\\log(|x|)\\) となる。 これをJuliaで書くと以下のようになる:\n\nusing SymPy\n@vars x\ndisplay.(\n  (integrate(x^10, x), integrate(1/x, x))\n)\n;\n\n\\(\\frac{x^{11}}{11}\\)\n\n\n\\(\\log{\\left(x \\right)}\\)\n\n\n\n\n\n\\(f(x)=\\sin(x), g(x)=\\cos(x), h(x)=\\tan(x)\\)\n積分すると、\\(F(x)=-\\cos(x), G(x)=\\sin(x), H(x)=-\\log(|\\cos(x)|)\\) となる。 これをJuliaで書くと以下のようになる:\n\ndisplay.(\n    (integrate(sin(x), x), integrate(cos(x), x), integrate(tan(x), x))\n)\n;\n\n\\(- \\cos{\\left(x \\right)}\\)\n\n\n\\(\\sin{\\left(x \\right)}\\)\n\n\n\\(- \\log{\\left(\\cos{\\left(x \\right)} \\right)}\\)\n\n\n\n\n\n\\(f(x)=e^x\\)\n積分すると、\\(F(x)=e^x\\) となる。 これをJuliaで書くと以下のようになる:\n\nintegrate(exp(x), x)\n\n\\(e^{x}\\)\n\n\n\n\n\n\\(f(x)=\\log(x)\\)\n積分すると、\\(F(x)=x \\log(x) - x\\) となる。 これをJuliaで書くと以下のようになる:\n\nintegrate(log(x), x)\n\n\\(x \\log{\\left(x \\right)} - x\\)\n\n\n\n\n\n\\(f(x)=\\sinh(x), g(x)=\\cosh(x)\\)\n積分すると、\\(F(x)=\\cosh(x), G(x)=\\sinh(x)\\) となる。 これをJuliaで書くと以下のようになる:\n\ndisplay.(\n    (integrate(sinh(x)), integrate(cosh(x)))\n)\n;\n\n\\(\\cosh{\\left(x \\right)}\\)\n\n\n\\(\\sinh{\\left(x \\right)}\\)"
  },
  {
    "objectID": "page-julia-howtoinstall.html",
    "href": "page-julia-howtoinstall.html",
    "title": "mysite",
    "section": "",
    "text": "Juliaを使ってみよう\n\n“禅 of Python” VS “なぜJuliaを創ったか？”\n\nJuliaとは？\n世の中には多くのプログラム言語があります。 それぞれのプログラム言語には適した利用法があり、CやC++ならOSプログラム、FortranやMatlabなら数値計算、Pythonは汎用、JavaはWebアプリ、Mathematicaなら数学の計算、Hadoopなら分散処理……などです。\n特に、JuliaはPythonの代替言語として、機械学習や数値計算領域での使用例が多くなっています。\n僕も数値計算のためにJuliaを勉強しました。 しかし、それだけではないのです。 Juliaの目指すところは、僕が思うに、あらゆる『プログラム言語の統合』です。\n将来は、Juliaを使えれば万能という時代が来るかもしれません。\n皆さん、Juliaを使ってみましょう。\n\n\nPythonの考え\n\n\n[引用]Pythonの考え\n\n\n美しいものが醜いものより優れている。\n明示的なものが暗黙的なものより優れている。\n簡潔なものが複雑なものより優れている。\n複雑なものが複雑化したものより優れている。\nネストされたものよりもフラットなものが優れている。\n疎なものが密なものより優れている。\n可読性が重要である。\n特別なケースはルールを破るほど特別ではない。\n実用性は純粋さに勝る。\nエラーは静かに通過すべきではない。\n明示的に抑制されるまで、沈黙して通過すべきではない。\n曖昧さに直面した場合、推測する誘惑を拒否するべきである。\nただ一つ、そしてできれば明らかな方法で行うべきである。\nただし、それが最初から明らかな方法ではない場合は、オランダ人でなければ気づけないような。\n今が、絶対にないよりも良い。\nただし、絶対にないことがしばしば「今」よりも良い。\n実装が説明しにくい場合、それは悪いアイデアである。\n実装が説明しやすい場合、それは良いアイデアかもしれない。\n名前空間は素晴らしいアイデアであり、これからもっと活用すべきである。\n\n\nPythonの禅\n\n\nJuliaの考え\n\n\n[引用]Juliaの考え\n\n\n簡単に言うと、我々は欲張りなのです。\n我々はMatlabのパワフルなユーザーです。中にはLispのハッカーもいます。PythonistaやRubyist、Perlのハッカーもいます。私たちの中には、まだひげを生やせない人もいますし、顔にひげが生える前からMathematicaを使っていた人もいます。私たちは、正気の範囲を超えるほど多くのRのプロットを生成してきました。Cは私たちにとって、無人島でのプログラミング言語です。\nこれらの言語を全て愛しています。それぞれが素晴らしくパワフルです。私たちが行う仕事、科学的な計算、機械学習、データマイニング、大規模な線形代数、分散および並列計算のために、それぞれが仕事の一部には完璧であり、他の部分にはひどいものです。それぞれはトレードオフです。\n私たちは欲張りです：もっと欲しいのです。\n私たちは、オープンソースの言語を望みます。Cの速度とRubyのダイナミズムを持つ言語が欲しいのです。Lispのような真のマクロを備えたホモアイコニックな言語が欲しいのですが、Matlabのような明白で馴染みのある数学表記も欲しいのです。一般的なプログラミングに使用できるPythonのようなもの、統計処理にはRのように簡単なもの、文字列処理にはPerlのように自然なもの、線形代数にはMatlabのように強力なもの、プログラムをつなぐのにはシェルのように優れたものが欲しいのです。学習が簡単でありながら、真剣なハッカーたちも満足できるものです。インタラクティブであり、コンパイルされたものが欲しいのです。\n（Cと同じくらい速いことを言いましたか？）\n要求が多い中で、私たちはHadoopの分散パワーを提供するものを望みます。ただし、JavaとXMLの冗長な記述なしで。バグを見つけるために数百台のマシン上のギガバイトのログファイルをひとつずつ見る必要はありません。複雑なレイヤーがなくても、パワーを求めます。単一のCPUのレジスタを使って、タイトなマシンコードにコンパイルされるシンプルなスカラーループを書きたいのです。A*Bと書き、数千の計算を数千のマシンで行い、巨大な行列の積を一緒に計算したいのです。\n私たちは、自分の気分に合わせて型を指定することはしたくありません。しかし、ポリモーフィックな関数が必要な場合には、ジェネリックプログラミングを使用してアルゴリズムを一度だけ書き、無限のタイプの格子に適用したいのです。さまざまなメソッド定義から関数の引数に最適なメソッドを効率的に選択するために、多重ディスパッチを使用したいのです。全く異なる型間で共通の機能を提供します。これだけのパワーにもかかわらず、言語はシンプルで清潔であることを望んでいます。\nこれらすべてを求めるのは、欲深いでしょうか？\n私たちは自分たちが非常に欲張りであることを認識していますが、それでも全てを手に入れたいと思っています。約2年半前、私たちは自分たちの欲望の言語を作るために取り組み始めました。まだ完全ではありませんが、初期のリリースの時が来ました。私たちが作った言語はJuliaと呼ばれています。それは私たちの無礼な要求の90%を既に実現しており、今は他の無礼な要求によってさらに形作られる必要があります。ですので、もしもあなたも欲張りで理不尽で要求の多いプログラマーなら、ぜひ試してみてください。\n\n\nなぜJuliaを創ったか？\n\n\n考えの違い、実装の違いはどこにあるのか？\n\nプログラマの人口はPythonの勝利\nプログラマの人口は、その言語の支持率と言ってもいいでしょう。 どれだけ多くのライブラリがあるか。どれだけ多くのドキュメントがあるかを考えれば、Pythonに軍配が上がる。 GitHut 2.0\n実際、日本語のドキュメントはまだそろってない感じで、初学者には難しいかも。\nパフォーマンス（実行速度）はJuliaの勝利\nPythonは計算速度はある程度のチューニングが必要で、チューニングをしてもJuliaには勝てそうにないです。言語の仕様上、JuliaやCの速度で動かすのは無理と言えます。\nPython+NumPy VS Julia\nJulia VS Python 3\nJulia VS C\n\n\n\n\nJuliaのインストール方法\n\nインストール方法(Windows)\n2023年現在のインストール方法を説明します。 ベーシックな方法だけ紹介するので、パッケージインストーラやポータブル版を使いたい人はそれぞれ調べてください。\n\nJuliaをダウンロードする\nまず、ダウンロードにアクセスし、お使いのオペレーティングシステムに基づいてダウンロードしたいJuliaのバージョンをクリックします。\n例えば、「64-bit (installer)」というリンクをクリックすると、インストーラという実行ファイルがダウンロードされます。\n.exeファイルを実行する\n次に、ダウンロードした.exeファイルを実行し、Juliaのインストールを進めてください。 「Add Julia To PATH」といったチェックボックスがあれば、チェックすることを推奨します。\nこのチェックをした場合、cmd（コマンドプロンプト）から直接juliaが実行できるようになります。\nJuliaの実行\nJuliaのインストールが完了したら、Juliaを起動します。 すると、REPL（read-eval-print-loop）としても知られるJuliaのコマンドラインが表示されます：\n簡単なコードを実行する\n最後に、コードの入力/実行を開始することができます。 例えば、“Hello World”を表示する簡単なコードを以下に示します：\nprintln(\"Hello World\")\nENTERを押すと、“Hello World”の結果が得られます。\n\n\n\njupyter-notebookでの動かし方\nusing Pkg; Pkg.add(\"IJulia\")を実行すると、jupyter-notebookで使えるようになります。"
  },
  {
    "objectID": "page-julia-numbertheory-1.html",
    "href": "page-julia-numbertheory-1.html",
    "title": "mysite",
    "section": "",
    "text": "整数論\n\n漸化式\n漸化式は僕の分野だと何に役立つか良く分かりません。 同次形の微分方程式にちょっと似てるかなってくらいです。\nただ、再帰的な解法を解くためのツールとして、何かに役立つかもしれないと思います。\nNaiveな方法なら、初期項 \\(a_0\\) から 更新式 \\(a_n = f(a_{n-1}, ..., a_0)\\) で逐次求めていけば良いだけのものです。\n\n\n漸化式の解法\n\nケースA\nA  \\(a_n = a_{n-1} + d\\)   \\(\\Rightarrow\\)  A’  \\(\\Delta a_n = a_n - a_{n-1} = d\\)   \\(\\Rightarrow\\)   \\(a_n = nd + a_0\\) \n\n\nケースB\nB  \\(a_n = r a_{n-1}\\)  \\(\\Rightarrow\\)   \\(a_n = r^n a_0\\) \n\n\nケースC\nC  \\(a_n = a_{n-1} + f(n)\\)   \\(\\Rightarrow\\)  C’  \\(\\Delta a_n = a_n - a_{n-1} = f(n)\\)   \\(\\Rightarrow\\)   \\(a_n= a_0 + \\sum_{k=1}^{n} f(k)\\) \n\n\nケースD\nD  \\(a_n = p a_{n-1} + q\\)   \\(\\Rightarrow\\)  D’  \\(b_n = p b_{n-1}\\)   \\(\\Rightarrow\\)  B\n\n\n式変形\n\n\\(p \\neq 1\\) かつ \\(n \\rightarrow \\infty\\) において \\(a_n \\rightarrow \\alpha\\) とする。 このとき、\\(b_n = a_n - \\alpha\\) と置くと、以下のように変形できます。 \\[\n\\begin{array}{rr}\n           & a_n    = p a_{n-1} + q\\\\\n  +\\big{)} & \\alpha = p \\alpha  + q\\\\\n  \\hline\n           & b_n    = p b_{n-1}\n\\end{array}\n\\]\n\n\n\nケースE\nE  \\(a_n = p a_{n-1} + q r^n\\)   \\(\\Rightarrow\\)  E’  \\(b_n = \\frac{p}{r} b_{n-1} + q\\)   \\(\\Rightarrow\\)  D\n\n\n式変形\n\n\\(b_n=\\frac{a_n}{r^n}\\) と置くと、以下のように変形できます。 \\[\n\\frac{a_n}{r^n} = \\frac{p a_{n-1}}{r^n}               + q \\Rightarrow\n\\frac{a_n}{r^n} = \\frac{p}{r} \\frac{a_{n-1}}{r^{n-1}} + q \\Rightarrow\nb_n             =         b_{n-1}                     + q\n\\]\n\n\n\nケースF\nF  \\(a_n = p a_{n-1} + q n + r\\)   \\(\\Rightarrow\\)  F’  \\(b_n = p b_{n-1} + q\\)   \\(\\Rightarrow\\)  D\n\n\n式変形\n\n\\(b_n=a_n - a_{n-1}\\) と置くと、以下のように変形できます。 \\[\n\\begin{array}{rr}\n           & a_n     = p a_{n-1} + q n     + r\\\\\n  +\\big{)} & a_{n-1} = p a_{n-2} + q (n-1) + r\\\\\n  \\hline\n           & b_n     = p b_{n-1} + q\n\\end{array}\n\\]\n\n\n\nケースG\nG  \\(a_n + p a_{n-1} + q a_{n-2} = 0\\)   \\(\\Rightarrow\\)  特性方程式  \\(\\Rightarrow\\)   \\(t^n + p t^{n-1} + q t^{n-2} = 0, a_n=t^n\\)   \\(\\Rightarrow\\)   \\(t^2 + p t + q = 0, a_n=t^n\\) \n\n\nケースH1\nH1  \\(a_n^k = r a_{n-1}^l\\)   \\(\\Rightarrow\\)  H1’  \\(k b_n = \\log(r) + l b_{n-1}\\)   \\(\\Rightarrow\\)  D\n\n\n式変形\n\n\\(b_n = \\log(a_n)\\)とすると、以下のように書き表せる。 \\[k \\log(a_n) = \\log(r) + l \\log(a_{n-1})\\] \\[k b_n = \\log(r) + l b_{n-1}\\]\n\n\n\nケースH2\nH2  \\(a_n^k = r a_{n-1}^l a_{n-2}^m\\)   \\(\\Rightarrow\\)  対数\n\n\nケースI\nI  \\(a_n = \\frac{p a_{n-1}}{r a_{n-1} + s}\\)   \\(\\Rightarrow\\)  逆数\n\n\nケースJ\nJ  \\(a_n = \\frac{p a_{n-1}}{r a_{n-1} + s}\\)   \\(\\Rightarrow\\)  \\(x=\\frac{p x}{r x + s}\\) で平行移動\n\n\nケースK\nK  \\(a_n=p a_{n-1}+q b_{n-1} , b_n = r a_{n-1} + s b_{n-1}\\)   \\(\\Rightarrow\\)  行列の固有値"
  },
  {
    "objectID": "page-julia-calculus-2.html",
    "href": "page-julia-calculus-2.html",
    "title": "mysite",
    "section": "",
    "text": "微分積分\n数学的な厳密性を無視して説明します。\n\n線積分とは\n凄く単純に言えば線積分とは、『線に沿って』積分を行うことです。\n線積分のパラメータとして、以下に曲線を \\(C\\) 、空間の任意のベクトルを \\(\\mathbb{r} \\in \\mathbb{R}^{n}\\) 、\\(C\\) 上の極小の \\(\\mathbb{r}\\) の変位を \\(d\\mathbb{r} \\in \\mathbb{R}^{n}\\) とします。\n\\(d\\mathbb{r}\\) は、その系での座標の表現方法によって、例えば、以下の3つのケースがあると思います。それぞれのケースで以下のような置換を行うことで、積分を計算しやすい形に変換できる可能性があります。\n\n\n媒介変数 \\(\\mathbb{r}=\\mathbb{r}(t)\\)\n\\[\nd\\mathbb{r} = \\frac{d\\mathbb{r}(t)}{dt} dt\n\\]\n\n\n例(曲線の長さ)\n\n\\(\\mathbb{r} = x(t) \\mathbb{i}_x + y(t) \\mathbb{i}_z + z(t) \\mathbb{i}_z\\) と表される曲線 \\(C\\) がある。この曲線の長さについて \\(t \\in [t_0, t_1]\\) の区間内で積分すると，以下の式が得られる。\n\\[\nL = \\int_C |d\\mathbb{r}| = \\int_{t_0}^{t_1} |\\frac{d\\mathbb{r}}{dt}| dt\n  = \\int_{t_0}^{t_1} \\| \\frac{dx}{dt} \\mathbb{i}_x + \\frac{dy}{dt} \\mathbb{i}_y + \\frac{dz}{dt} \\mathbb{i}_z \\| dt\n  = \\int_{t_0}^{t_1} \\sqrt{(\\frac{dx}{dt})^2 + (\\frac{dy}{dt})^2 + (\\frac{dz}{dt})^2} dt\n\\]\n\n\n\n\n\\(y\\) や \\(x\\) が \\(y=f(x)\\) などと関数で表されるケース \\(r=\\left[\\begin{matrix} x \\\\ f(x) \\end{matrix}\\right]\\)\n\\[\nd\\mathbb{r} = \\frac{d\\mathbb{r}}{dx} dx\n\\]\n\n\n例(曲線の長さ)\n\n\\(\\mathbb{r} = \\left[\\begin{matrix} x \\\\ y(x) \\end{matrix}\\right]\\) と表される曲線 \\(C\\) がある。この曲線の長さについて \\(x \\in [x_0, x_1]\\) の区間内で積分すると，以下の式が得られる。\n(これは実質媒介変数と同じ)\n\\[\nL = \\int_C |d\\mathbb{r}| = \\int_{x_0}^{x_1} |\\frac{d\\mathbb{r}}{dx}| dx\n  = \\int_{x_0}^{x_1} |\\left[\\begin{matrix} d(x)/dx \\\\ d(y(x))/dx \\end{matrix}\\right]| dx\n  = \\int_{x_0}^{x_1} \\sqrt{1 + (\\frac{dy(x)}{dx})^2} dx\n\\]\n\n\n\n\n極形式 \\(\\mathbb{r}=Polar(r, \\theta)\\)\n\\[\nd\\mathbb{r}= dr \\mathbb{i}_r + r d\\theta \\mathbb{i}_{\\theta}\n\\]\nなお、\\(\\mathbb{i}_r\\), \\(\\mathbb{i}_{\\theta}\\) はそれぞれ \\(\\mathbb{r}\\) と \\(\\mathbb{r}\\) に直交する接戦方向のベクトルです。\n\n\n例(曲線の長さ)\n\n\\(\\mathbb{r} = r \\mathbb{i}_r + r\\theta \\mathbb{i}_{\\theta}\\) と表される曲線 \\(C\\) がある。この曲線の長さについて \\(x \\in [x_0, x_1]\\) の区間内で積分すると，以下の式が得られる。\n\\[\nL = \\int_C |d\\mathbb{r}| = \\int_{\\theta_0}^{\\theta_1} |dr \\mathbb{i}_r + r d\\theta \\mathbb{i}_{\\theta}|\n  = \\int_{\\theta_0}^{\\theta_1} \\sqrt{dr^2 + (r d\\theta)^2}\n  = \\int_{\\theta_0}^{\\theta_1} \\sqrt{(\\frac{dr}{d\\theta})^2 + r^2} d\\theta\n\\]\n※この導出は数学的には微妙ですが、実際この式で解けます。\n\n\n\n\n\n線積分の公式\n線積分は、ベクトル場やスカラー場を沿って積分する方法です。\n主に物理学や数学で使用され、曲線や経路上のベクトル量やスカラー量を解析するのに役立ちます。 以下では、線積分の基本的な考え方と計算方法について説明します。\n線積分は、スカラー場かベクトル場かの２つの問題形式があります。 また、線分の長さを求める方法についても説明します。\n\nスカラー場の積分\n空間の至る所に値が紐づけされているようなものだと思ってください。 例えば、温度は僕らの生きるこの3次元空間においてそれぞれ違う値をとっています。\nスカラー場の積分は以下の式で表されます。 線の長さが正であることから、 \\(dr\\) には通常絶対値を付けていることに気を付けてください。 \\[\nw = \\int_{C} f(r) |dr|\n\\]\n\n\nベクトル場の積分\nベクトル場とは、空間の至る所にベクトル値が紐づけされているようなものだと思ってください。 例えば、クーロン力は電荷の位置などで異なる方向に働く力です。\nベクトル場の積分は以下の式で表されます。 \\(dr\\) や \\(F(r)\\) はベクトルであることに気を付けてください。(ちなみに、\\(\\cdot\\) は内積です) \\[\nW = \\int_{C} F(r) \\cdot dr\n\\]\n\n\n曲線の長さ\n曲線の長さは以下の式で表されます。 \\[\nL = \\int_{C} |dr|\n\\]\n\n\n\n線積分の実装\n参考"
  },
  {
    "objectID": "page-julia-packages-MAT.html",
    "href": "page-julia-packages-MAT.html",
    "title": "mysite",
    "section": "",
    "text": "Juliaのパッケージ\nインストールするには、JuliaのREPLでusing Pkg; Pkg.add(\"MAT\")を実行してください。\n\nMATとは？\n数値計算や機械学習の分野では、計算途中のデータを保存することで、事故の発生を防ぎたいことがあります。 多くの場合、.csvや.txtや.jsonといったファイル形式で保存するのですが、その他の方法として、Matlabの変数を格納する.mat形式のファイルを使いたい場合があります。\nこんなとき、MATパッケージを使用すれば、変数を辞書型にまとめて保存することができ、その辞書をファイルからそのまま取り出すこともできます。\nまた、このファイルは「MATLAB v7.3 format.」によって書き込まれるため、matlabでも読み込み可能です。\n参考文献\n\n\nMATの使い方\n\n書き込み\n書き込みは以下のように、ファイルのパスを与えて辞書型のデータを関数に渡すことで行います。\n\nusing MAT\n\nd = Dict(\n    \"var1\" => \"hello\",\n    \"var2\" => rand(3, 3)\n)\n\nmatwrite(\"tmp/__matfile.mat\", d)\n\n\n\n読み込み\n読み込みは以下のように、ファイルのパスを与えて辞書型のデータを受け取ることで行います。\n\ne = matread(\"tmp/__matfile.mat\")\ne\n\nDict{String, Any} with 2 entries:\n  \"var1\" => \"hello\"\n  \"var2\" => [0.747694 0.818366 0.44244; 0.123226 0.816386 0.0572965; 0.603717 0…"
  },
  {
    "objectID": "page-julia-packages-Random.html",
    "href": "page-julia-packages-Random.html",
    "title": "mysite",
    "section": "",
    "text": "Juliaのパッケージ\nインストールするには、JuliaのREPLでusing Pkg; Pkg.add(\"Random\")を実行してください。\n\nRandomとは？\n乱数生成はありとあらゆる場所で使われています。 特に、確率的に起こる事象を扱う場合に使われます。\n参考文献\n\n\nRandomの使い方\nRandomの使い方で大切なのは、randとRandom.seed!くらいです。 他は余り使わないと思います。\n\n0~1間の乱数\nなお、rand関数はusing Randomを宣言する前からBaseに含まれています。\n\n乱数生成\n以下のように、乱数を生成できます。\n\nrand()\n\n0.2895098423219379\n\n\n\n\n５次元の配列（ベクトル）\n以下のように、ベクトルを作ることもできます。\n\nrand(5)\n\n5-element Vector{Float64}:\n 0.028549977665983994\n 0.538639413965653\n 0.8969897902567084\n 0.25847781536337067\n 0.3389490517221738\n\n\n\n\n\\(2 \\times 4\\) の行列\n以下のように、行列も作れます。\n\nrand(2,4)\n\n2×4 Matrix{Float64}:\n 0.374877  0.768433  0.876292  0.934366\n 0.444003  0.178543  0.55      0.532499\n\n\n\n\n\\(3 \\times 4\\) の複素行列\n以下のように、型に沿った行列を作るみたいなこともできます。\n\nrand(ComplexF64, 3, 4)\n\n3×4 Matrix{ComplexF64}:\n 0.043883+0.325227im   0.63344+0.21631im   …  0.913038+0.409758im\n 0.494975+0.856017im  0.414769+0.702561im     0.624384+0.0565774im\n 0.164786+0.685904im  0.870925+0.757711im     0.871887+0.355375im\n\n\n\n\nランダム選択\n以下のように、さいころの出目みたいなものを扱うこともできます。\n\nchoise = [\"A\", \"B\", \"C\", 1, 2, 3]\nn      = 10\nrand(choise, n)\n\n10-element Vector{Any}:\n 1\n  \"B\"\n  \"B\"\n  \"C\"\n 1\n  \"B\"\n 3\n  \"A\"\n  \"B\"\n 1\n\n\n\n\n\n乱数のシードの設定\n乱数は「シード」と言われるパラメータを用いて生成しています。 シードは現在時刻などを参照して決められます。\nこのシードの値を用いて、非常に周期の長い（同じパターンが起こりにくい）疑似乱数を生成しています。\nプログラムに乱数を使っている場合、シードを設定していないと「再現性」の面で問題が起きる場合があり、シードをプログラム内で設定してやることが求められる事があります。数値計算のプログラムなどではシードを設定しておくことをお勧めします。\n\nusing Random\nRandom.seed!(0)\n;\n\n\n\nランダムな置換\n\nx = [1,2,3,4,5]\nx[randperm(length(x))]\n\n5-element Vector{Int64}:\n 4\n 5\n 3\n 2\n 1\n\n\n\n\n置換によるシャッフル\n\nx = [\"a\", \"b\", \"c\", \"d\"]\nshuffle(x)\n\n4-element Vector{String}:\n \"a\"\n \"d\"\n \"b\"\n \"c\""
  },
  {
    "objectID": "page-julia-packages-Base.html",
    "href": "page-julia-packages-Base.html",
    "title": "mysite",
    "section": "",
    "text": "Juliaのパッケージ\n\nBaseとは？\n\n\nBaseの使い方"
  },
  {
    "objectID": "page-julia-packages-LinearAlgebra.html",
    "href": "page-julia-packages-LinearAlgebra.html",
    "title": "mysite",
    "section": "",
    "text": "Juliaのパッケージ\nインストールしなくても最初から用意されているパッケージです。 プログラムの最初の方でusing LinearAlgebraと指定して読み込んでください。\n\nLinearAlgebraとは？\n行列の計算などをするのに適したパッケージです。 ただし、疎行列などの問題に適したアルゴリズムではないので注意してください。\n数値計算で使われる機能は大半このパッケージに含まれます。 また、BLASやLAPACKの機能が含まれます。\nここで述べる学問領域は僕の得意分野ですが、このセクションでは簡単な使い方の例を紹介するに留めます。\n参考\n\n\n基本的な機能\n\nノルム\nベクトルのノルムを求められます。 デフォルトはユークリッド空間における通常のノルム(２ノルム)になります。\n\nusing LinearAlgebra\nnorm([1, 2, 1])\n\n2.449489742783178\n\n\n\n\n内積\nベクトル同士のドット積（内積）を求められます。\n\ndot([1,3,2], [4,1,6])\n\n19\n\n\n\n\n外積\nベクトル同士のクロス積（外積）を求められます。\n\ncross([1,3,2], [4,1,6])\n\n3-element Vector{Int64}:\n  16\n   2\n -11\n\n\n\n\n行列式\n行列の行列式を求められます。\n\nA = [\n    1 2 4;\n    5 4 1;\n    9 2 6.0\n]\ndet(A)\n\n-124.0\n\n\n\n\nトレース\n行列のトレースを求められます。\n\nA = [\n    1 2 4;\n    5 4 1;\n    9 2 6.0\n]\ntr(A)\n\n11.0\n\n\n\n\n\n固有値問題\n固有値問題を解きます。\n\nA = rand(10, 10)\n\nF = eigen(A) # Λ, V = eigen(A)でもOK\nΛ, V = F.values, F.vectors\n\nnorm(\n    A*V - V*diagm(Λ)\n)\n\n1.3988919810697231e-14\n\n\n\n\n特異値分解\n特異値分解を解きます。(エコノミーサイズです)\n\nA = rand(10, 8)\n\nF = svd(A) # U, S, V = svd(A)でもOK\nU, S, V = F.U, F.S, F.V\n\nnorm(\n    A - U*diagm(S)*V'\n)\n\n3.2209424127120038e-15\n\n\n\n\nLU分解\nLU分解を解きます。\n\nA = rand(10, 8)\n\nF = lu(A) # L, U = lu(A)\nL, U, p = F.L, F.U, F.p\n\nnorm(\n   A[p,:] - L*U\n)\n\n3.9852227955858445e-16\n\n\n\n\nQR分解\nQR分解を解きます。\n\nA = rand(10, 8)\n\nF = qr(A)\nQ, R = F.Q, F.R\n\nnorm(\n    A - Q*R\n)\n\n1.3076087352977526e-15"
  },
  {
    "objectID": "page-julia-langbasic-3.html",
    "href": "page-julia-langbasic-3.html",
    "title": "mysite",
    "section": "",
    "text": "Juliaの文法基礎\n\n行列の使い方\n\n行列（自分で値を決めて）\n値を自分で決めて行列を作る場合、以下のようにしてください。\n\nA = [\n  1 2 4;\n  6 7 3;\n  2 2 9;\n  0 5 0.0\n]\n\n4×3 Matrix{Float64}:\n 1.0  2.0  4.0\n 6.0  7.0  3.0\n 2.0  2.0  9.0\n 0.0  5.0  0.0\n\n\n\n\n初期化された行列\n0で初期化された行列を作るには、以下のようにしてください。\n\nA = zeros(2, 2)\n\n2×2 Matrix{Float64}:\n 0.0  0.0\n 0.0  0.0\n\n\n\n\n任意行列\n中身が何でも良い適当な行列を作りたい場合は、以下のようにしてください。\n\nA = rand(3, 5)\n\n3×5 Matrix{Float64}:\n 0.220238  0.957616  0.974877  0.385393  0.891681\n 0.334465  0.987858  0.130555  0.583025  0.943827\n 0.915218  0.908973  0.409851  0.423888  0.721225\n\n\n\n\n単位行列\n単位行列を作りたい場合は、以下のようにしてください。 型を指定しない場合、Boolの行列になってしまいます。\n\nusing LinearAlgebra\nE = Matrix{Float64}(I, 3, 3)\n\n3×3 Matrix{Float64}:\n 1.0  0.0  0.0\n 0.0  1.0  0.0\n 0.0  0.0  1.0\n\n\n\n\n行列の表示\nprintlnよりもdisplayで表示した方が見やすいので、小さい行列はそうやって表示しましょう。\n\nA = rand(3, 3)\ndisplay(A)\n\n3×3 Matrix{Float64}:\n 0.579375  0.072156  0.930005\n 0.381244  0.312008  0.0840836\n 0.637532  0.503068  0.539931\n\n\n\n\n行列の型\n行列に限らず……ですが、typeof関数でどういう型になっているかを調べることができます。\n\nA = rand(ComplexF64, 10, 10)\ntypeof(A)\n\n\nMatrix{ComplexF64} (alias for Array{Complex{Float64}, 2})\n\n\n\n\n\n\n行列の参照\n説明のため、\\(9 \\times 9\\) サイズの行列を作りました。 この行列は九九の表を表してます。 効率的に覚えるため(？)、下半分を削りました。\n※なんでこうなるかは取り敢えず無視してください。\n\na = [1, 2, 3, 4, 5, 6, 7, 8, 9]\nA = (M -> M - tril(M, -1))(a * a')\n\n9×9 Matrix{Int64}:\n 1  2  3   4   5   6   7   8   9\n 0  4  6   8  10  12  14  16  18\n 0  0  9  12  15  18  21  24  27\n 0  0  0  16  20  24  28  32  36\n 0  0  0   0  25  30  35  40  45\n 0  0  0   0   0  36  42  48  54\n 0  0  0   0   0   0  49  56  63\n 0  0  0   0   0   0   0  64  72\n 0  0  0   0   0   0   0   0  81\n\n\n\n特定の行（列）のベクトルとしての参照\n特定の行だけ取り出し、ベクトルとして参照したいときは、以下のようにしてください。\n\nx = A[1, :]\n\n9-element Vector{Int64}:\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n\n\n特定の列だけ取り出し、ベクトルとして参照したいときは、以下のようにしてください。\n\nx = A[:, 2]\n\n9-element Vector{Int64}:\n 2\n 4\n 0\n 0\n 0\n 0\n 0\n 0\n 0\n\n\n\n\n特定の行（列）の参照\n特定の行だけ取り出したいときは、以下のようにしてください。（行列として参照されます）\n\nx = A[1:1, :]\n\n1×9 Matrix{Int64}:\n 1  2  3  4  5  6  7  8  9\n\n\n特定の列だけ取り出したいときは、以下のようにしてください。\n\nx = A[:, 2:2]\n\n9×1 Matrix{Int64}:\n 2\n 4\n 0\n 0\n 0\n 0\n 0\n 0\n 0\n\n\n\n\n複数行（列）をまとめて取り出したい\n特定の連続する数行だけ取り出したいときは、以下のようにしてください。\n\nx = A[5:8, :]\n\n4×9 Matrix{Int64}:\n 0  0  0  0  25  30  35  40  45\n 0  0  0  0   0  36  42  48  54\n 0  0  0  0   0   0  49  56  63\n 0  0  0  0   0   0   0  64  72\n\n\n特定の連続する数列だけ取り出したいときは、以下のようにしてください。\n\nx = A[:, 2:5]\n\n9×4 Matrix{Int64}:\n 2  3   4   5\n 4  6   8  10\n 0  9  12  15\n 0  0  16  20\n 0  0   0  25\n 0  0   0   0\n 0  0   0   0\n 0  0   0   0\n 0  0   0   0\n\n\n\n\n小行列の参照\n\nx = A[5:8, 2:5]\n\n4×4 Matrix{Int64}:\n 0  0  0  25\n 0  0  0   0\n 0  0  0   0\n 0  0  0   0\n\n\n\n\n行と列を複数個指定して参照\n\nx = A[[1, 5, 6], [1, 3, 4, 9]]\n\n3×4 Matrix{Int64}:\n 1  3  4   9\n 0  0  0  45\n 0  0  0  54\n\n\n\n\n\n行列への代入\n参照した行列に代入することができます。 .=でなくて=でも代入できますが、メモリを気にするときは.=を使ってください。\n例えば、以下のようにしてください。\n\nA[[1, 5, 6], [1, 3, 4, 9]] .= zeros(3, 4)\nA\n\n9×9 Matrix{Int64}:\n 0  2  0   0   5   6   7   8   0\n 0  4  6   8  10  12  14  16  18\n 0  0  9  12  15  18  21  24  27\n 0  0  0  16  20  24  28  32  36\n 0  0  0   0  25  30  35  40   0\n 0  0  0   0   0  36  42  48   0\n 0  0  0   0   0   0  49  56  63\n 0  0  0   0   0   0   0  64  72\n 0  0  0   0   0   0   0   0  81"
  },
  {
    "objectID": "page-julia-crypto-2.html",
    "href": "page-julia-crypto-2.html",
    "title": "mysite",
    "section": "",
    "text": "暗号理論\n\n暗号アルゴリズム（計算機登場以前）\n\nシーザー暗号\nシーザー暗号は、古代ローマの将軍であるガイウス・ユリウス・カエサルが使用したとされる、非常にシンプルな代替暗号の一種です。 シーザー暗号は、アルファベットの文字を一定の数だけシフトさせて暗号化します。\n単位換字暗号\n単一換字暗号は、平文の各文字を別の文字に1対1で置き換える暗号化手法です。\nエニグマ\nエニグマは、第二次世界大戦中にドイツが使用した複雑な電子機械式暗号装置です。\n\n\n\nシーザー暗号\nシーザー暗号は、「鍵」を文字のシフト数 \\(n \\in K=\\{0,1,2,\\dots,2\\}\\) とする暗号です。 鍵空間 \\(K\\) の大きさはここでは \\(|K|=26\\) であり、ブルート・フォース・アタックでの突破が容易な暗号である。\n文字のシフトとは、例えば以下のように、表をもとに文字をずらす手法です。\n\n'あ' + 5\n\n'ぇ': Unicode U+3047 (category Lo: Letter, other)\n\n\nそれぞれの文字（アルファベット）を n_shift だけシフトさせるプログラムは以下の通りです。\n\nfunction char_shift(c, n_shift)\n    if !isletter(c)\n        return c\n    end\n    if !('a' <= lowercase(c) <= 'z')\n        return c\n    end\n    a = 'a'\n    if isuppercase(c)\n        a = 'A'\n    end\n    i = c - a\n    j = (i + n_shift) % 26\n    return a + j\nend\n\nchar_shift.(['a', 'X'], 3)\n\n2-element Vector{Char}:\n 'd': ASCII/Unicode U+0064 (category Ll: Letter, lowercase)\n 'A': ASCII/Unicode U+0041 (category Lu: Letter, uppercase)\n\n\nシーザー暗号の実装は以下の通りです。\n\nfunction encode_caesar(\n    plaintext::AbstractString, \n    n_shift::Integer # key\n)\n    l_plaintext  = collect(plaintext)\n    l_ciphertext = char_shift.(l_plaintext, n_shift)\n    ciphertext   = join(l_ciphertext)\n    return ciphertext\nend\n\nfunction decode_caesar(ciphertext, n_shift)\n    return encode_caesar(ciphertext, 26 - n_shift)\nend\n\n# key\nmykey = 3\n\n# encode\nplaintext  = \"hello world\"\nciphertext = encode_caesar(plaintext, mykey)\n\n# decode\nplaintext_ = decode_caesar(ciphertext, mykey)\n\nplaintext_\n\n\"hello world\"\n\n\n\n\n単一換字暗号\n単一換字暗号は、「鍵」を換字表 \\(\\text{Tbl} \\in K\\) とする暗号です。 鍵空間 \\(K\\) の大きさは \\(|K|=26!=403291461126605635584000000\\) であり、ブルート・フォース・アタックでの突破は困難ですが、頻度分析により比較的簡単に突破できます。\nそれぞれの文字（アルファベット）を Tbl に従って置換するプログラムは以下の通りです。\n\nfunction char_replace(c, tbl)\n    if !isletter(c)\n        return c\n    end\n    if !('a' <= lowercase(c) <= 'z')\n        return c\n    end\n    return tbl[c]\nend\n\nchar_replace (generic function with 1 method)\n\n\n単一換字暗号の暗号は以下の通りです。\n\nfunction encode_monoalphabetic(\n    plaintext::AbstractString, \n    key\n)\n    tbl = Dict(\n        zip(\n            collect(key[1]), collect(key[2])\n        )\n    )\n    l_plaintext  = collect(plaintext)\n    l_ciphertext = (c -> char_replace(c, tbl)).(l_plaintext)\n    ciphertext   = join(l_ciphertext)\n    return ciphertext\nend\n\nfunction decode_monoalphabetic(ciphertext, key)\n    key = (key[2], key[1])\n    return encode_monoalphabetic(ciphertext, key)\nend\n\n# key\nmykey = (\n    collect(\"abcdefghijklmnopqrstuvwxyz\"), \n    collect(\"gpkhayvwcoxzqntudeflmijbrs\")\n)\n\n# encode\nplaintext  = \"hello world\"\nciphertext = encode_monoalphabetic(plaintext, mykey)\n\n# decode\nplaintext_ = decode_monoalphabetic(ciphertext, mykey)\n\nplaintext_\n\n\"hello world\"\n\n\n\n\nエニグマ\nエニグマ（Enigma）は、第二次世界大戦中にドイツで使用された暗号化機械です。 当時は非常に高度な暗号化手法であるとされ、暗号文の解読が非常に困難であると考えられていました。\n機械式の代替暗号装置であり、電気信号を用いて文字を暗号化した暗号です。\nエニグマは、複数の可変ローター（回転ディスク）とプラグボード（Steckerboard）と呼ばれる接続装置から構成されており、これによって文字の置換と交換が行われました。 暗号学の歴史上、重要な節目となる装置であり、暗号解読の研究や教育においても広く取り上げられています。 平文の文字を入力すると、可変ローターの回転と接続装置の置換によって暗号文の文字が出力されます。\nエニグマは KEK(key encrypting key)と言われる、鍵を暗号化するための日替わり鍵を導入したことでも知られています。 そのため、同じ文字が連続して入力されても、異なる文字が出力されるため、エニグマは多重換字暗号として知られる複雑な暗号方式でした。\n※実装は省略します。\n\n\n\n\ngraph LR\n    A[平文] --> B((暗号化))\n    D --> E[暗号化通信鍵と暗号文]\n    F[通信鍵] -.-> B\n    B --> C[暗号文]\n    F --> H((暗号化))\n    I[KEK] -.-> H\n    subgraph LR\n        B\n        C --> D((結合))\n        G[暗号化通信鍵] --> D\n        H --> G\n    end\n\n\n\n\n\n\n\n\n\n\n解読アルゴリズム\n\nブルート・フォース・アタック\nブルート・フォース・アタックは、全ての可能な組み合わせを試行することで、暗号を解読する攻撃手法です。\n頻度分析\n頻度分析は、暗号文の中の文字や記号の出現頻度を解析し、元の平文を特定する手法です。\n\n\n\nブルート・フォース・アタック\nencode_caesarによる暗号は鍵空間が小さいので、ブルート・フォース・アタックで簡単に解読できる。\n以下のシーザー暗号によって暗号化された暗号文を解読することを考える。\n\nciphertext = \"twzgpozrd\"\n\n\"twzgpozrd\"\n\n\n復号化のアルゴリズムは知っているため、decode_caesarを使うことができるものと考え、鍵を\n\nkeys        = collect(0:25)\ndecodetexts = (key -> decode_caesar(ciphertext, key)).(keys)\noutputs     = collect(zip(keys, decodetexts))\n\n26-element Vector{Tuple{Int64, String}}:\n (0, \"twzgpozrd\")\n (1, \"svyfonyqc\")\n (2, \"ruxenmxpb\")\n (3, \"qtwdmlwoa\")\n (4, \"psvclkvnz\")\n (5, \"orubkjumy\")\n (6, \"nqtajitlx\")\n (7, \"mpszihskw\")\n (8, \"loryhgrjv\")\n (9, \"knqxgfqiu\")\n (10, \"jmpwfepht\")\n (11, \"ilovedogs\")\n (12, \"hknudcnfr\")\n (13, \"gjmtcbmeq\")\n (14, \"filsbaldp\")\n (15, \"ehkrazkco\")\n (16, \"dgjqzyjbn\")\n (17, \"cfipyxiam\")\n (18, \"behoxwhzl\")\n (19, \"adgnwvgyk\")\n (20, \"zcfmvufxj\")\n (21, \"ybelutewi\")\n (22, \"xadktsdvh\")\n (23, \"wzcjsrcug\")\n (24, \"vybirqbtf\")\n (25, \"uxahqpase\")\n\n\nこの中で、意味の通る文章は\"ilovedogs\"だけです。 鍵は11なので、次も同じ鍵を使ってた場合、内容がバレバレになってしまいます。\n犬が好きらしいですね。\n\n\n頻度分析\nencode_monoalphabeticによる暗号は鍵空間は少々大きいので、ブルート・フォース・アタックで解読するのは難しそうです。なので、頻度分析と言う手法を使います。\n以下の単一換字暗号によって暗号化された暗号文を解読することを考える。\n\nciphertext = \"cnkerultveguwrgkcuwaetekruwaecfgngzvteclwqyteuaeyteqcnvankerulctntehakerulctngfaecaftyjazzhaycnahflauflwglkgnpaytzztjahgfguetkahmeagngzlaenglciazaffktqqtnlaeqcfankcuwaeqanlltankcuwaeteankthacfltktniaelcnyteqglctncnltkcuwaetekthacnktqqtnugezgnkakcuwaecffrntnrqtmfjclwkthagflwargeaptlwgfaltyflauflwglankerulgqaffgvawtjaiaelwaktnkaulfgeahcflcnklcnkerultveguwrafuakcgzzrkzgffckgzkerultveguwr\"\n\n\"cnkerultveguwrgkcuwaetekruwaecfgngzvteclwqyteuaeyteqcnvankerulctntehakerulctngfaecaftyjazzhaycnahflauflwglkgnpaytzztjahgfguetkahmeagngzlaenglciazaffktqqtnlaeqcfankcuwaeqanlltankcuwaeteankthacfltktniaelcnyteqglctncnltkcuwaetekthacnktqqtnugezgnkakcuwaecffrntnrqtmfjclwkthagflwargeaptlwgfaltyflauflwglankerulgqaffgvawtjaiaelwaktnkaulfgeahcflcnklcnkerultveguwrafuakcgzzrkzgffckgzkerultveguwr\"\n\n\n古典的な頻度分析の手法として、以下のようなアイデアがある。文字列の中に頻出する文字（文字列）を推定できる可能性がある。ただし、これらのアイデアは偏りのない巨大な文章に対しては意味があるが、そうでなければ上手くいかない。\n\n出現するアルファベットの頻度\n多い順に、e, t, a, o, i, n, …, j, x, q, z\n出現する２文字のアルファベット文字列の頻度\n多い順に、th, he, in, er, …\n出現する３文字のアルファベット文字列の頻度\nthe, and, ing, ion,\n参考\n\nこれらのアイデアを利用するために、以下のようにパターンを解析するプログラムを実装した。\n\nfunction pattern_frequency_analysis(\n    text::AbstractString, n::Integer\n)\n    pattern_counts = Dict() # Dict{SubString, Int64}()\n    for i in 1:length(text)- n + 1\n        pattern = text[i:i+n-1]\n        if haskey(pattern_counts, pattern)\n            pattern_counts[pattern] += 1\n        else\n            pattern_counts[pattern] = 1\n        end\n    end\n    result = sort(collect(pattern_counts), by = x -> x[2], rev=true)\n    return result\nend\n\nfunction frequency_analysis(ciphertext, N)\n    for n = 1:N\n        result = pattern_frequency_analysis(ciphertext, n)\n        display(result[1:8])\n    end\nend\n\nfrequency_analysis(ciphertext, 3)\n\n\n\n8-element Vector{Pair{Any, Any}}:\n \"a\" => 46\n \"t\" => 35\n \"e\" => 34\n \"l\" => 30\n \"n\" => 28\n \"c\" => 27\n \"g\" => 27\n \"k\" => 27\n\n\n8-element Vector{Pair{Any, Any}}:\n \"ae\" => 12\n \"nk\" => 11\n \"uw\" => 9\n \"wa\" => 8\n \"tn\" => 8\n \"te\" => 8\n \"cn\" => 8\n \"ul\" => 7\n\n\n8-element Vector{Pair{Any, Any}}:\n \"ker\" => 6\n \"wae\" => 6\n \"eru\" => 6\n \"rul\" => 6\n \"uwa\" => 6\n \"cuw\" => 5\n \"kcu\" => 5\n \"ank\" => 5\n\n\n\n\nここで、aの頻度が多いことから、aをeだと考えて置換する。\n\nciphertext = replace(ciphertext, 'a' => 'e', 'e' => 'a')\nfrequency_analysis(ciphertext, 3)\n\n\n\n8-element Vector{Pair{Any, Any}}:\n \"e\" => 46\n \"t\" => 35\n \"a\" => 34\n \"l\" => 30\n \"n\" => 28\n \"c\" => 27\n \"g\" => 27\n \"k\" => 27\n\n\n8-element Vector{Pair{Any, Any}}:\n \"ea\" => 12\n \"nk\" => 11\n \"uw\" => 9\n \"we\" => 8\n \"tn\" => 8\n \"cn\" => 8\n \"ta\" => 8\n \"ul\" => 7\n\n\n8-element Vector{Pair{Any, Any}}:\n \"wea\" => 6\n \"aru\" => 6\n \"uwe\" => 6\n \"rul\" => 6\n \"kar\" => 6\n \"enk\" => 5\n \"cuw\" => 5\n \"kcu\" => 5\n\n\n\n\nここで、eaはerとすることにする。\n\nciphertext = replace(ciphertext, 'a' => 'r', 'r' => 'a')\nfrequency_analysis(ciphertext, 3)\n\n\n\n8-element Vector{Pair{Any, Any}}:\n \"e\" => 46\n \"t\" => 35\n \"r\" => 34\n \"l\" => 30\n \"n\" => 28\n \"c\" => 27\n \"g\" => 27\n \"k\" => 27\n\n\n8-element Vector{Pair{Any, Any}}:\n \"er\" => 12\n \"nk\" => 11\n \"uw\" => 9\n \"we\" => 8\n \"tn\" => 8\n \"cn\" => 8\n \"tr\" => 8\n \"ul\" => 7\n\n\n8-element Vector{Pair{Any, Any}}:\n \"aul\" => 6\n \"uwe\" => 6\n \"rau\" => 6\n \"wer\" => 6\n \"kra\" => 6\n \"enk\" => 5\n \"cuw\" => 5\n \"kcu\" => 5\n\n\n\n\nこのように、頻度表を用いて試行錯誤していくことで少ない時間で解ける……場合がある。\n# 元の文章\nincryptographyacipherorcypherisanalgorithmforperformingencryptionordecryption—aseriesofwelldefinedstepsthatcanbefollowedasaprocedureanalternativelesscommontermisenciphermenttoencipherorencodeistoconvertinformationintocipherorcodeincommonparlancecipherissynonymouswithcodeastheyarebothasetofstepsthatencryptamessagehowevertheconceptsaredistinctincryptographyespeciallyclassicalcryptography\n引用した文章"
  }
]