[
  {
    "objectID": "page-julia-howtoinstall.html",
    "href": "page-julia-howtoinstall.html",
    "title": "mysite",
    "section": "",
    "text": "Juliaを使ってみよう\n\nJuliaとは？\n世の中には多くのプログラミング言語があります。 そして、それぞれのプログラム言語には適した使い方があります。\nCやC++ならOSプログラム、FortranやMatlabなら数値計算、Pythonは汎用、JavaはWebアプリ、MathematicaやMaximaなら数学の計算、Hadoopなら分散処理……などです。\n特にJuliaはPythonの代替言語として、機械学習や数値計算領域で使用例が増加してきています。\n僕も数値計算の為にJuliaを勉強しました。\nしかし、Juliaが応用できる分野は、Pythonのそれとは違います。\nなぜなら、Juliaの設計思考は、貪欲に汎用性を求め、あらゆる要求を一手に満たすことだからです。\n\n\n[引用]Juliaの考え\n\n\n簡単に言うと、我々は欲張りなのです。\n我々はMatlabのパワフルなユーザーです。中にはLispのハッカーもいます。PythonistaやRubyist、Perlのハッカーもいます。私たちの中には、まだひげを生やせない人もいますし、顔にひげが生える前からMathematicaを使っていた人もいます。私たちは、正気の範囲を超えるほど多くのRのプロットを生成してきました。Cは私たちにとって、無人島でのプログラミング言語です。\nこれらの言語を全て愛しています。それぞれが素晴らしくパワフルです。私たちが行う仕事、科学的な計算、機械学習、データマイニング、大規模な線形代数、分散および並列計算のために、それぞれが仕事の一部には完璧であり、他の部分にはひどいものです。それぞれはトレードオフです。\n私たちは欲張りです：もっと欲しいのです。\n私たちは、オープンソースの言語を望みます。Cの速度とRubyのダイナミズムを持つ言語が欲しいのです。Lispのような真のマクロを備えたホモアイコニックな言語が欲しいのですが、Matlabのような明白で馴染みのある数学表記も欲しいのです。一般的なプログラミングに使用できるPythonのようなもの、統計処理にはRのように簡単なもの、文字列処理にはPerlのように自然なもの、線形代数にはMatlabのように強力なもの、プログラムをつなぐのにはシェルのように優れたものが欲しいのです。学習が簡単でありながら、真剣なハッカーたちも満足できるものです。インタラクティブであり、コンパイルされたものが欲しいのです。\n（Cと同じくらい速いことを言いましたか？）\n要求が多い中で、私たちはHadoopの分散パワーを提供するものを望みます。ただし、JavaとXMLの冗長な記述なしで。バグを見つけるために数百台のマシン上のギガバイトのログファイルをひとつずつ見る必要はありません。複雑なレイヤーがなくても、パワーを求めます。単一のCPUのレジスタを使って、タイトなマシンコードにコンパイルされるシンプルなスカラーループを書きたいのです。A*Bと書き、数千の計算を数千のマシンで行い、巨大な行列の積を一緒に計算したいのです。\n私たちは、自分の気分に合わせて型を指定することはしたくありません。しかし、ポリモーフィックな関数が必要な場合には、ジェネリックプログラミングを使用してアルゴリズムを一度だけ書き、無限のタイプの格子に適用したいのです。さまざまなメソッド定義から関数の引数に最適なメソッドを効率的に選択するために、多重ディスパッチを使用したいのです。全く異なる型間で共通の機能を提供します。これだけのパワーにもかかわらず、言語はシンプルで清潔であることを望んでいます。\nこれらすべてを求めるのは、欲深いでしょうか？\n私たちは自分たちが非常に欲張りであることを認識していますが、それでも全てを手に入れたいと思っています。約2年半前、私たちは自分たちの欲望の言語を作るために取り組み始めました。まだ完全ではありませんが、初期のリリースの時が来ました。私たちが作った言語はJuliaと呼ばれています。それは私たちの無礼な要求の90%を既に実現しており、今は他の無礼な要求によってさらに形作られる必要があります。ですので、もしもあなたも欲張りで理不尽で要求の多いプログラマーなら、ぜひ試してみてください。\n\n\nなぜJuliaを創ったか？\n\n\nJuliaの強みと弱み\n\nプログラマ人口\nプログラマの人口は、その言語の支持率です。 どれだけ多くのライブラリがあるか、どれだけ多くのドキュメントがあるかは、人口の少ない言語では太刀打ちできません。\nJuliaのプログラマ人口は0.1%に満たないです。\nGitHut 2.0\nパフォーマンス\nJuliaについて説明するとき最も重要なのは、パフォーマンスの話です。\nPythonやJavaなどの言語と比較し、Juliaは十分なチューニングをしなくとも高速動作します。\nPython+NumPy VS Julia\nJulia VS Python 3\nJulia VS C\n\n\n\nJuliaのインストール方法\n\nインストール方法（Windows）\n2023年現在のインストール方法を説明します。 ベーシックな方法だけ紹介するので、パッケージインストーラやポータブル版を使いたい人はそれぞれ調べてください。\n\nJuliaのダウンロード\nまず、ダウンロードにアクセスし、お使いのオペレーティングシステムに基づいてダウンロードしたいJuliaのバージョンをクリックします。\n例えば、「64-bit (installer)」というリンクをクリックすると、インストーラという実行ファイルがダウンロードされます。\nexeファイルを実行する\n次に、ダウンロードした.exeファイルを実行し、Juliaのインストールを進めてください。 「Add Julia To PATH」といったチェックボックスがあれば、チェックすることを推奨します。\nこのチェックをした場合、cmd（コマンドプロンプト）から直接juliaが実行できるようになります。\nJuliaの実行\nJuliaのインストールが完了したら、Juliaを起動します。 すると、REPL（read-eval-print-loop）としても知られるJuliaのコマンドラインが表示されます：\n簡単なコードを実行する\n最後に、コードの入力/実行を開始することができます。 例えば、“Hello World”を表示する簡単なコードを以下に示します：\nprintln(\"Hello World\")\nENTERを押すと、“Hello World” の結果が得られます。\n\n\n\n\nJupyterでの動作\nREPLにてusing Pkg; Pkg.add(\"IJulia\")を実行すると、jupyter-notebookで使えるようになります。"
  },
  {
    "objectID": "page-julia-lang-basic-1.html",
    "href": "page-julia-lang-basic-1.html",
    "title": "mysite",
    "section": "",
    "text": "Juliaの文法基礎\nプログラミングの構成要素となる型や値、変数などの扱いについてざっくりと列挙しています。 コピーしてREPLで実行してみてください。\n\n値と型\n\n整数(Int64)\n\n8\n\n8\n\n\n\n\n浮動小数点(Float64)\n\n2.0\n\n2.0\n\n\n\n\n文字(Char)\n\n'a'\n\n'a': ASCII/Unicode U+0061 (category Ll: Letter, lowercase)\n\n\n\n\n文字列(String)\n\n\"abc\"\n\n\"abc\"\n\n\n\n\nベクトル(Vector{TYPE})\n\n[1, 2, 5] # [1.0, 2, 5]とすればVector{Float64}型になる\n\n3-element Vector{Int64}:\n 1\n 2\n 5\n\n\n\n\n行列(Matrix{TYPE})\n\n[1 2 3; 2 6 5; 9 3 1; 1 5 1] # どれかの要素をFloat64型にすればMatrix{Float64}型になります。\n\n4×3 Matrix{Int64}:\n 1  2  3\n 2  6  5\n 9  3  1\n 1  5  1\n\n\n\n[1 2 3]\n\n1×3 Matrix{Int64}:\n 1  2  3\n\n\n\n[1; 2; 3]\n\n3-element Vector{Int64}:\n 1\n 2\n 3\n\n\n\n\nタプルNTuple{n, TYPE}\n\n(1, 2, 4, 6)\n\n(1, 2, 4, 6)\n\n\n\n\n辞書型Dict{TYPEA, TYPEB}\n\nDict(\n    \"var1\" => \"hello\",\n    \"var2\" => rand(3, 3)\n)\n\nDict{String, Any} with 2 entries:\n  \"var1\" => \"hello\"\n  \"var2\" => [0.639533 0.76238 0.357519; 0.80105 0.20415 0.348276; 0.829473 0.37…\n\n\n\n\n\n代入\n\n値1の変数aへの代入\n\na = 1\n\n1\n\n\n\n\n値(\"\", \"2\", 3)を変数(b, c, d)に同時に代入\n\nb, c, d = \"\", \"2\", 3\n\n(\"\", \"2\", 3)\n\n\n\n\n値のスワップ(交換)\n\nx, y = 1, 100\nprintln(\"before: $x $y\")\nx, y = y, x\nprintln(\"after : $x $y\")\n\nbefore: 1 100\nafter : 100 1\n\n\n\n\n\n出力\n\n値の標準出力println\n\ns = \"aaaa\"\nprintln(s)\nprintln(s, \"b\", s) # , で区切ると繋げて表示される\nv = [1, 2, 4]\nprintln(v)\nV = [1 1 2; 5 4 5]\nprintln(V)\n\naaaa\naaaabaaaa\n\n\n\n[1, 2, 4]\n\n\n\n[1 1 2; 5 4 5]\n\n\n\n\n値を整形して表示display\n\ns = \"aaaa\"\ndisplay(s)\nv = [1, 2, 4]\ndisplay(v)\nV = [1 1 2; 5 4 5]\ndisplay(V)\n\n\"aaaa\"\n\n\n3-element Vector{Int64}:\n 1\n 2\n 4\n\n\n2×3 Matrix{Int64}:\n 1  1  2\n 5  4  5\n\n\n\n\n\n四則演算+α\n\n足し算+\n\n1 + 2 + 4\n\n7\n\n\n\n\n引き算-\n\n132 - 451\n\n-319\n\n\n\n\n掛け算*\n\n111 * 222\n\n24642\n\n\n\n\n割り算/\n\n10 / 3.0 # 3.0を3としても動作する\n\n3.3333333333333335\n\n\n\n\n商÷と剰余%\n\n10 ÷ 3, 10 % 3\n\n(3, 1)\n\n\n\n\n累乗^\n\n5 ^ 3\n\n125\n\n\n\n\n平方根sqrt, √\n\nsqrt(13)\n\n3.605551275463989\n\n\n\n\n\n論理演算子\n\nAND演算&, and\n\ntrue & false\n\nfalse\n\n\n\n\nOR演算|\n\ntrue | false\n\ntrue\n\n\n\n\nXOR⊻\n\ntrue ⊻ false\n\ntrue\n\n\n\n\nNOT!\n\n! true\n\nfalse\n\n\n\n\n\n比較演算子\n\n同値==\n\n1 == 1.0 # 型が違う\n\ntrue\n\n\n\n\n～より大きい>=\n\n9.1 >= 0.0\n\ntrue\n\n\n\n\n～より小さい>=\n\n1 <= -1\n\nfalse\n\n\n\n\n～と異なる!=\n\n10 != 10\n\nfalse\n\n\n\n\n\n文字列の演算\n\n結合\n\nx, y = 3, 5\ns1, s2 = \"times\", \"equalsto\"\ns1 = \"$(x) $(s1) $(y) $(s2) $(x*y) !\" \n\n\"3 times 5 equalsto 15 !\"\n\n\n\n\n\n関数の定義\n\n関数の作り方1function ~ end\n\nfunction f1(x, y)\n  println(\"calc: $x ^ $y\")\n  return x ^ y\nend\nf1(5, 3)\n\ncalc: 5 ^ 3\n\n\n125\n\n\n\n\n関数の作り方2f(...)=...\n\nf2(x, y) = x ^ y\nf2(5, 3)\n\n125\n\n\n\n\n関数の作り方3f = (...) -> (...)\n\nf3 = (x, y) -> x ^ y\nf3(5, 3)\n\n125\n\n\n\n\nキーワード変数function f(...;...)\n※文字列を生成した後に表示しているため、表示の順序に注意\n\nfunction f4(x, y; c=1)\n  println(\"calc: $c * $x ^ $y\")\n  return c * x ^ y\nend\nprintln(\"$(f4(5, 3)) $(f4(5, 3, c=2))\")\n\ncalc: 1 * 5 ^ 3\ncalc: 2 * 5 ^ 3\n125 250\n\n\n\n\n\nブロードキャスト\n\nベクトルと定数の間の四則演算\n他の計算も大抵同じことができます\n\nv, a = [1.0, 2, 3], 3\n\nv1   = v .+ a # それぞれの要素に足し算\nv2   = v .- a # 　　　　　　　　引き算\nv3   = v .* a # 　　　　　　　　掛け算\nv4   = v ./ a # 　　　　　　　　割り算\n\nprintln(v1, v2, v3, v4)\n\n[4.0, 5.0, 6.0][-2.0, -1.0, 0.0][3.0, 6.0, 9.0][0.3333333333333333, 0.6666666666666666, 1.0]\n\n\n\n\n関数に対しても……\n\n# f(x) = x^2\nfunction f(x)\n  return x ^ 2\nend\nprintln(f.([1, 2, 3, 5]))\n\n[1, 4, 9, 25]\n\n\n\n\n2変数関数に対しても……\n\nf(x, y) = x^y\n\nl1 = f.([1, 2, 3, 4], 2)\nl2 = f.(2, [1, 2, 3, 4])\n\ndisplay.([l1', l2']);\n\n1×4 adjoint(::Vector{Int64}) with eltype Int64:\n 1  4  9  16\n\n\n1×4 adjoint(::Vector{Int64}) with eltype Int64:\n 2  4  8  16\n\n\n\n\n多次元データのブロードキャスト\n\nf(x) = 3*x + 1\nf.([1 2 3; 4 5 6])\n\n2×3 Matrix{Int64}:\n  4   7  10\n 13  16  19"
  },
  {
    "objectID": "page-julia-lang-basic-2.html",
    "href": "page-julia-lang-basic-2.html",
    "title": "mysite",
    "section": "",
    "text": "Juliaの文法基礎\n\nif文\nif文は真理値(以下の(x == 0):: Bool)がtrueのとき内部のコードを実行します。\nif 真理値\n  コード\nend\n実際の例は以下の通りです：\n\n# x が 0 と等しい場合にそれを出力します。\nx = 0\nif x == 0 # x == 0 は比較演算子の返り値＝真理値型\n  println(\"$(x)と0は同じ値です\")\nend\n\n0と0は同じ値です\n\n\nif ~ else文は真理値がtrueのとき内部のコード1を実行し、それ以外の場合にelseの内部のコード2を実行します。\nif 真理値\n  コード1\nelse\n  コード2\nend\n実際の例は以下の通りです：\n\nx = 0\nif x == 0\n  println(\"$(x)と0は同じ値です\")\nelse\n  println(\"$(x)と0は異なります\")\nend\n\n0と0は同じ値です\n\n\n\nx = 1\nif x == 0\n  println(\"$(x)と0は同じ値です\")\nelse\n  println(\"$(x)と0は異なります\")\nend\n\n1と0は異なります\n\n\nif ~ elseif ~ else文は真理値1がtrueのときコード1を実行し、真理値k-1までがfalseのとき、真理値kがtrueならばコードkを実行します。また、真理値nまで実行してコードが全部実行できなかったとき、elseの内部のコードn+1を実行します。\nまあ要するに、上から順番にどの条件が真になるかを確かめて、実行していく感じです。\nif     真理値1\n  コード1\nelseif 真理値2\n  コード2\n...\nelseif 真理値k-1\n  コードk-1\nelseif 真理値k\n  コードk\n...\nelseif 真理値n\n  コードn\nelse \n  コードn+1\nend\n実際の例は以下の通りです：\n\nx = -3\nif x == 0\n  println(\"$(x)と0は同じ値です\")\nelseif -3 < x <= 3\n  println(\"$(x)は、集合(-3,+3]に含まれます\")\nelse\n  println(\"$(x)は集合(-∞, -3]と(+3, ∞)の和集合に含まれます\")\nend\n\n-3は集合(-∞, -3]と(+3, ∞)の和集合に含まれます\n\n\n\n\nfor文\nfor文は、n回連続で『似た』処理を実行したいときに使います。 何かの順番を持つオブジェクト（イテレーティブオブジェクト）に応じて、順次、内部のコード(i)を実行します。\nfor i = イテレーティブオブジェクト\n  コード(i)\nend\n\n# iとi^2をnまで足し合わせるプログラム\nn = 0\nk = 0\nfor i = 1:10 # UnitRange型オブジェクト\n  k = k + i\n  n = n + i^2\nend\nprintln(\"$n, $k\")\n\n385, 55\n\n\nベクトルでもできます。勿論、タプルでも……。\n\nn = 0\nk = 0\nfor i = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n  k = k + i\n  n = n + i^2\nend\nprintln(\"$n, $k\")\n\n385, 55\n\n\nベクトルとか行列を作りたいとき、for文を使った内包表記という書き方ができます。\n\n# 1から10まで、2乗の和を計算する\n[i^2 for i = 1:10]\n\n10-element Vector{Int64}:\n   1\n   4\n   9\n  16\n  25\n  36\n  49\n  64\n  81\n 100\n\n\n\n\nwhile文\nwhile文は真理値がtrueの間に限り内部のコードが実行されるループです。\nwhile 真理値\n  コード\nend\n\n# n^2の和を合計が1000を越えるまで足していく。\nn = 0\nN = 0\nwhile N < 1000\n  N = N + n^2\n  n = n + 1\nend\nprintln(\"0 から $(n-1) までの値の2乗の和は $N となる\")\n\n0 から 14 までの値の2乗の和は 1015 となる\n\n\n\n\ncontinue文\ncontinueはループfor, whileの内部のコードをその回の終了までスキップします。\n\n# １～１０までの間で偶数だけを出力する\nfor i = 1:10\n  if i % 2 == 1 \n    continue\n  end\n  println(\"$i は偶数です\")\nend\n\n2 は偶数です\n4 は偶数です\n6 は偶数です\n8 は偶数です\n10 は偶数です\n\n\n\n\nbreak文\nbreakはループfor, whileをその場で抜けます。\n\nfor i = 1:10\n  if i == 7\n    break\n  end\n  println(\"$i は 7 未満です\")\nend\n\n1 は 7 未満です\n2 は 7 未満です\n3 は 7 未満です\n4 は 7 未満です\n5 は 7 未満です\n6 は 7 未満です"
  },
  {
    "objectID": "page-julia-lang-basic-3.html",
    "href": "page-julia-lang-basic-3.html",
    "title": "mysite",
    "section": "",
    "text": "Juliaの文法基礎\n\n行列の使い方\n\n行列（自分で値を決めて）\n値を自分で決めて行列を作る場合、以下のようにしてください。\n\nA = [\n  1 2 4;\n  6 7 3;\n  2 2 9;\n  0 5 0.0\n]\n\n4×3 Matrix{Float64}:\n 1.0  2.0  4.0\n 6.0  7.0  3.0\n 2.0  2.0  9.0\n 0.0  5.0  0.0\n\n\n\n\n初期化された行列\n0で初期化された行列を作るには、以下のようにしてください。\n\nA = zeros(2, 2)\n\n2×2 Matrix{Float64}:\n 0.0  0.0\n 0.0  0.0\n\n\n\n\n任意行列\n中身が何でも良い適当な行列を作りたい場合は、以下のようにしてください。\n\nA = rand(3, 5)\n\n3×5 Matrix{Float64}:\n 0.172831  0.866655  0.432303  0.454327  0.104064\n 0.82046   0.861971  0.941381  0.606381  0.639392\n 0.886441  0.788796  0.293827  0.92935   0.336948\n\n\n\n\n単位行列\n単位行列を作りたい場合は、以下のようにしてください。 型を指定しない場合、Boolの行列になってしまいます。\n\nusing LinearAlgebra\nE = Matrix{Float64}(I, 3, 3)\n\n3×3 Matrix{Float64}:\n 1.0  0.0  0.0\n 0.0  1.0  0.0\n 0.0  0.0  1.0\n\n\n\n\n行列の表示\nprintlnよりもdisplayで表示した方が見やすいので、小さい行列はそうやって表示しましょう。\n\nA = rand(3, 3)\ndisplay(A)\n\n3×3 Matrix{Float64}:\n 0.865704  0.252724  0.810673\n 0.486044  0.969458  0.786968\n 0.735257  0.968663  0.545522\n\n\n\n\n行列の型\n行列に限らず……ですが、typeof関数でどういう型になっているかを調べることができます。\n\nA = rand(ComplexF64, 10, 10)\ntypeof(A)\n\n\nMatrix{ComplexF64} (alias for Array{Complex{Float64}, 2})\n\n\n\n\n\n\n行列の参照\n説明のため、\\(9 \\times 9\\) サイズの行列を作りました。 この行列は九九の表を表してます。 効率的に覚えるため(？)、下半分を削りました。\n※なんでこうなるかは取り敢えず無視してください。\n\na = [1, 2, 3, 4, 5, 6, 7, 8, 9]\nA = (M -> M - tril(M, -1))(a * a')\n\n9×9 Matrix{Int64}:\n 1  2  3   4   5   6   7   8   9\n 0  4  6   8  10  12  14  16  18\n 0  0  9  12  15  18  21  24  27\n 0  0  0  16  20  24  28  32  36\n 0  0  0   0  25  30  35  40  45\n 0  0  0   0   0  36  42  48  54\n 0  0  0   0   0   0  49  56  63\n 0  0  0   0   0   0   0  64  72\n 0  0  0   0   0   0   0   0  81\n\n\n\n特定の行（列）のベクトルとしての参照\n特定の行だけ取り出し、ベクトルとして参照したいときは、以下のようにしてください。\n\nx = A[1, :]\n\n9-element Vector{Int64}:\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n\n\n特定の列だけ取り出し、ベクトルとして参照したいときは、以下のようにしてください。\n\nx = A[:, 2]\n\n9-element Vector{Int64}:\n 2\n 4\n 0\n 0\n 0\n 0\n 0\n 0\n 0\n\n\n\n\n特定の行（列）の参照\n特定の行だけ取り出したいときは、以下のようにしてください。（行列として参照されます）\n\nx = A[1:1, :]\n\n1×9 Matrix{Int64}:\n 1  2  3  4  5  6  7  8  9\n\n\n特定の列だけ取り出したいときは、以下のようにしてください。\n\nx = A[:, 2:2]\n\n9×1 Matrix{Int64}:\n 2\n 4\n 0\n 0\n 0\n 0\n 0\n 0\n 0\n\n\n\n\n複数行（列）をまとめて取り出したい\n特定の連続する数行だけ取り出したいときは、以下のようにしてください。\n\nx = A[5:8, :]\n\n4×9 Matrix{Int64}:\n 0  0  0  0  25  30  35  40  45\n 0  0  0  0   0  36  42  48  54\n 0  0  0  0   0   0  49  56  63\n 0  0  0  0   0   0   0  64  72\n\n\n特定の連続する数列だけ取り出したいときは、以下のようにしてください。\n\nx = A[:, 2:5]\n\n9×4 Matrix{Int64}:\n 2  3   4   5\n 4  6   8  10\n 0  9  12  15\n 0  0  16  20\n 0  0   0  25\n 0  0   0   0\n 0  0   0   0\n 0  0   0   0\n 0  0   0   0\n\n\n\n\n小行列の参照\n\nx = A[5:8, 2:5]\n\n4×4 Matrix{Int64}:\n 0  0  0  25\n 0  0  0   0\n 0  0  0   0\n 0  0  0   0\n\n\n\n\n行と列を複数個指定して参照\n\nx = A[[1, 5, 6], [1, 3, 4, 9]]\n\n3×4 Matrix{Int64}:\n 1  3  4   9\n 0  0  0  45\n 0  0  0  54\n\n\n\n\n\n行列への代入\n参照した行列に代入することができます。 .=でなくて=でも代入できますが、メモリを気にするときは.=を使ってください。\n例えば、以下のようにしてください。\n\nA[[1, 5, 6], [1, 3, 4, 9]] .= zeros(3, 4)\nA\n\n9×9 Matrix{Int64}:\n 0  2  0   0   5   6   7   8   0\n 0  4  6   8  10  12  14  16  18\n 0  0  9  12  15  18  21  24  27\n 0  0  0  16  20  24  28  32  36\n 0  0  0   0  25  30  35  40   0\n 0  0  0   0   0  36  42  48   0\n 0  0  0   0   0   0  49  56  63\n 0  0  0   0   0   0   0  64  72\n 0  0  0   0   0   0   0   0  81"
  },
  {
    "objectID": "page-julia-lang-macro.html",
    "href": "page-julia-lang-macro.html",
    "title": "mysite",
    "section": "",
    "text": "Juliaのマクロ\n\nマクロとは\nマクロとは、コンパイル時に実行されるコード生成機能であり、柔軟なコード記述と静的なコード変換を可能にします。\nマクロはソースコードのAST（抽象構文木）に対して操作を行い、新しいコードを生成します。\nJuliaのマクロは、@を使って呼び出せます。\n呼び出しは、マクロに渡される引数を含んだ式として解釈され、マクロ内の処理が実行されます。その後、マクロは評価結果として新しい式を返します。この返された式は、通常のコードとして実行されます。\nつまり、マクロはプログラムを生成するプログラムと言えます。\nマクロは、繰り返しパターンやコードの自動生成、ドメイン固有言語（DSL）の構築など、柔軟なコード記述を可能とします。 マクロは、静的なコード解析やコード変換を行うための強力なツールです。\n\n\nマクロの記述方法\nマクロは以下のコードで定義されます。\n\nmacro マクロ名(引数1, 引数2, ...)\n  処理内容\n  return 式\nend\n\nマクロの使用方法は以下のように@を使えばよいです。\n\n@マクロ名 引数1 引数2 ...\n\n\n\nクオート（引用）\nクオートは以下のどちらかの方法で行われます。 なお、expr1, expr2は、そのものがプログラムだと考えてください。\n:(expr)を使う方法\n\nexpr1 = :(x + 1)\n\n:(x + 1)\n\n\nquote(), quote ~ endを使う方法\n\nexpr2 = quote \n    x + 1\nend\n\n\nquote\n    #= In[3]:2 =#\n    x + 1\nend\n\n\n\n\n\nアンクオート（引用解除）\nquote, :()でクオートした式（プログラム）の内部でアンクオート$という動作を行わせることができます。 アンクオートした部分の式(以下の$(y+1))は、マクロの展開時に評価されます。\n\ny = 3 # マクロ展開時\nexpr = quote \n    z = $(y + 1) + y\nend\ndisplay(expr)\n\n\nquote\n    #= In[4]:3 =#\n    z = 4 + y\nend\n\n\n\n\n\n評価\nクオートした式を実行して評価するには、evalを使ってください。 例えば、上で作成した \\(z \\gets y+1\\) を表現する式exprは、以下のように評価できます。\n\ny = 1\neval(expr)\ndisplay(z)\n\n5\n\n\n\n\nASTの生成\nAST(抽象構文木)を作成するには、以下のようにdumpが使えます。\n\nexpr = :(x + y / z)\ndump(expr)\n\nExpr\n  head: Symbol call\n  args: Array{Any\n\n\n}((3,))\n    1: Symbol +\n    2: Symbol x\n    3: Expr\n      head: Symbol call\n      args: Array{Any}((3,))\n        1: Symbol /\n        2: Symbol y\n        3: Symbol z\n\n\n\n\nエスケープ\nマクロの展開時に式が評価されることから保護するため、escが使えます。\nこれを使わないと、マクロを展開するときに勝手に式が評価されてしまいます。\nなので、以下のように、式をエスケープしてコードに埋め込んでからアンクオートすることでプログラムの順序が守られます。\n\nmacro mymacro(expr)\n    quote \n        println(\"-\"^10)\n        $(esc(expr))\n        println(\"-\"^10)\n    end\nend\n\nname = \"YAMADA\"\n@mymacro println(\"Hello \", name)\n\n----------\nHello YAMADA\n----------\n\n\n\n\nマクロの例\n時間計測のマクロは以下の通りです。 実のところ、@timeとか@timedなどのマクロが既にあるので、あまり意味はないのですが……。\n\nmacro time_measure(expr)\n    quote\n        local start_time = time()\n        local result = $(esc(expr))\n        local end_time = time()\n        println(\"Execution time: \", end_time - start_time, \" seconds\")\n        result\n    end\nend\n\nA = @time_measure begin\n    sleep(0.05)\nend\n;\n\nExecution time: 0.0559999942779541 seconds"
  },
  {
    "objectID": "page-julia-langwiredpart.html",
    "href": "page-julia-langwiredpart.html",
    "title": "mysite",
    "section": "",
    "text": "Juliaの文法基礎\n\nJuliaの変なところ\nJuliaは非常に便利な言語です。 それを支えている部分ではあるのですが、他のプログラム言語と比較して、少し変な部分もあります。\nいくつかご紹介します。\n\n\nUnicodeのサポート（ひらがなも使える）\nJuliaでは大抵のUnicode文字が使えます。 便利か不便かは人によると思いますが、奇妙なのは間違いないと思います。\n英語を使うのに慣れていない人（超初心者や小学生など）にプログラミングを説明するのに向いてるかも？\n例えば、ひらがなや漢字を使って変数を定義する以下のようなプログラムも動いてしまいます。\n\n# おまじない（関数に別名を付ける）\n表示して = println\n足す,引く,掛ける,割る = +,-,*,/\n\n# やってみる（実際に動くコードの例）\nこれは２かな = 足す(1, 1)\n表示して( これは２かな )\n言いたいこと = \"ハローワールド!\"\n表示して( 言いたいこと )\n\n2\nハローワールド!\n\n\nα, βなども含め、他のUnicode文字も使えます。\nそのため、表現力の面ではJuliaは相当強いです。\n\n\n柔軟な型システム\nJuliaは強力な型システムを持っていますが、静的な型宣言が必須ではありません。 関数や変数に明示的な型注釈を付けることもできますが、Juliaは型推論によって自動的に型を推測することもできます。\nこれにより、動的なタイピングと静的なタイピングのメリットを組み合わせた柔軟なプログラミングが可能になります。\n※Integer型の行列にFloat型の値を入れたり演算をすることはできません。pythonより少しだけ型にうるさい言語だと思っておきましょう。\n\nx::Integer = 1; println(x)\ny::Float64 = 1; println(y)\nz = 1\n\n1\n1.0\n\n\n1\n\n\n\n\n配列のインデックス\nJuliaの配列のインデックスは、一般的なプログラミング言語とは異なり、1から始まります。 多くの言語では0から始まるインデックスが一般的ですが、Juliaでは数学的な表記に近い1から始まるインデックスが採用されています。\n同じような言語として、Fortranがあります。 JuliaはFortran技術者にとっては良い言語かもしれません。\nこれは好みの問題ですが、数学的に自然なプログガムが書けるので個人的には気に入ってます。\n\na = [1, 2, 3, 4]\na[1]\n\n1\n\n\n\n\nブロードキャスト\nJuliaは、要素ごとの演算をベクトル化して高速化することが得意です。 これにより、ループを使わずにコードを記述し、高速な計算を行うことができます。 また、Juliaのブロードキャスト機能を使用すると、異なるサイズや形状の配列の間で要素ごとの演算を行うことができます。\nループを平坦化する（ネストを減らす）ことは、可読性向上の為に重要な意味があります。 余計なループは排除しましょう。\n\n# 1:10までの数字の逆数を計算する。\n1.0 ./ (1:10)\n\n10-element Vector{Float64}:\n 1.0\n 0.5\n 0.3333333333333333\n 0.25\n 0.2\n 0.16666666666666666\n 0.14285714285714285\n 0.125\n 0.1111111111111111\n 0.1\n\n\n\n# 1:10までの数字の3乗を計算する。\nf(x) = x^3\nf.(1:10)\n\n10-element Vector{Int64}:\n    1\n    8\n   27\n   64\n  125\n  216\n  343\n  512\n  729\n 1000\n\n\n\n\n多重ディスパッチ\nJuliaの型システムには多重ディスパッチと呼ばれる機能があります。 これにより、関数が引数の型に基づいて自動的に異なる実装を選択することができます。\nこの機能は、同じ操作を異なる型に対して一貫して適用する場合に特に有用です。\n\n# 同じ数字を並べて大きな数字を作る\nfunction concat(x::Int, n::Int)\n    if n == 0\n        return 0\n    end\n    return x + 10 * concat(x, n-1)\nend\n\n# 同じ文字を並べて大きな文字列を作る\nfunction concat(x::Union{AbstractChar, AbstractString}, n::Int)\n    if n == 0\n        return \"\"\n    end\n    return x*concat(x, n-1)\nend\n\ndisplay.(\n    [concat(1, 5), concat(\"a\", 4)]\n)\n;\n\n11111\n\n\n\"aaaa\""
  },
  {
    "objectID": "page-julia-linearalgebra-1.html",
    "href": "page-julia-linearalgebra-1.html",
    "title": "mysite",
    "section": "",
    "text": "線形代数\n\n行列とは？\n行列は、数値や変数を配列したものです。 行と列からなる2次元のデータ構造で、さまざまな分野で広く使用されています。\n一般的な行列は、以下のように表現されます: \\[\n\\begin{bmatrix}\na_{11} & a_{12} & \\ldots & a_{1n} \\\\\na_{21} & a_{22} & \\ldots & a_{2n} \\\\\n\\vdots & \\vdots & \\ddots & \\vdots \\\\\na_{m1} & a_{m2} & \\ldots & a_{mn} \\\\\n\\end{bmatrix}\n\\]\n行列における加減乗除は、以下のように計算できます。\n\nA = [\n    1 2  1;\n    4 5 -2;\n    3 2 1.0\n]\nB = [\n    -1 5  6;\n     4 3 -7;\n     2 4 9.0\n]\n;\n\n行列の和\n\nA + B\n\n3×3 Matrix{Float64}:\n 0.0  7.0   7.0\n 8.0  8.0  -9.0\n 5.0  6.0  10.0\n\n\n行列の差\n\nA - B\n\n3×3 Matrix{Float64}:\n 2.0  -3.0  -5.0\n 0.0   2.0   5.0\n 1.0  -2.0  -8.0\n\n\n行列の積\n\nA * B\n\n3×3 Matrix{Float64}:\n  9.0  15.0    1.0\n 12.0  27.0  -29.0\n  7.0  25.0   13.0\n\n\n行列の除算(逆行列の作用)\n\nA \\ B\n\n3×3 Matrix{Float64}:\n  1.5       -0.5       1.5\n -0.777778   1.77778  -0.444444\n -0.944444   1.94444   5.38889\n\n\n行列の転置\n\nA'\n\n3×3 adjoint(::Matrix{Float64}) with eltype Float64:\n 1.0   4.0  3.0\n 2.0   5.0  2.0\n 1.0  -2.0  1.0\n\n\n\n\n行列の便利さ\n線形代数における行列は非常に重要です。 行列は、数値の集合を整理し、ベクトルや線形写像の表現や解析に利用されます。 以下に、行列の重要性をいくつか説明します。\n※内容について詳しく理解する必要はありません。\n\n線形写像の表現\n行列は線形写像を表現するための重要な道具です。 線形写像はベクトル空間から別のベクトル空間への線形な変換を表すものであり、例えば、以下のような表現ができます。 \\[ f(x) = Ax \\] \\[g \\bullet f(x) = BAx \\]\n線形方程式の解法\n行列は線形方程式の解法にも使用されます。 線形方程式は未知の変数に関する線形な等式の集合です。 \\[ Ax = b \\]\n固有値と固有ベクトル\n行列の固有値と固有ベクトルは、線形写像の特性を表す重要な概念です。 固有値とは、線形写像がベクトルに対して与える変換のスケールを表し、固有ベクトルはそのスケールが現れる方向を表します。行列の固有値と固有ベクトルを求めることで、線形写像の性質や変換の効果を理解することができます。固有値分解や特異値分解などの手法も、行列の固有値と固有ベクトルを利用しています。 \\[ Ax=\\lambda x \\]\nデータ解析と機械学習\n行列はデータ解析や機械学習の分野でも広く利用されます。例えば、多次元データを行列の形で表現することで、特徴ベクトルや特徴行列を得ることができます。これにより、データの類似性や相関関係を解析したり、機械学習アルゴリズムによるパターン識別や予測を行うための入力として利用することができます。また、行列の演算や変換を用いて、データの次元削減や特徴抽出などの処理も行われます。\n線形独立性と行列のランク\n行列の線形独立性と行列のランクは、ベクトルや行列の性質を理解する上で重要な概念です。行列の線形独立性は、ベクトルや行列の組が線形的に独立しているかどうかを示し、行列のランクはその独立な列または行の最大の数を表します。線形独立性とランクは、行列の性質や特徴を解析する際に役立ちます。\n\n\n\n有名な行列\n一般的な名前のついた行列について、可能な限り網羅します。 また、その性質についても説明します。\n\nゼロ行列（Zero Matrix）：すべての要素が0の行列です。\nゼロ行列は行列演算の加法単位元(「……？」って人はとりあえず無視)です。\nJuliaでのゼロ行列の作成方法は次の通りです。\n\nusing LinearAlgebra\n# 3x3のゼロ行列\nO = zeros(3, 3)\nO\n\n3×3 Matrix{Float64}:\n 0.0  0.0  0.0\n 0.0  0.0  0.0\n 0.0  0.0  0.0\n\n\n\n任意の行列Aとゼロ行列Oの和は元の行列Aと等しくなります。 \\[ A+O = O+A \\]\n任意の行列Aとゼロ行列Oの積はゼロ行列となります。 \\[ AO = OA = O \\]\nゼロ行列は任意のスカラー倍によってゼロ行列となります。 \\[ cO = Oc = O, c \\in \\mathbb{R} \\]\n\n\n\n単位行列（Identity Matrix）：主対角線上の要素がすべて1で、それ以外の要素が0の行列です。\n単位行列はは行列演算の乗法単位元です。\nJuliaでの単位行列の作成方法は次の通りです。\n\n# 3x3の単位行列\nE = Matrix{Float64}(I, 3, 3)\nE\n\n3×3 Matrix{Float64}:\n 1.0  0.0  0.0\n 0.0  1.0  0.0\n 0.0  0.0  1.0\n\n\n\n任意の行列Aと単位行列Iの積は元の行列Aと等しくなります。 \\[ A * I = I * A = A \\]\n単位行列を任意の非負定数乗すると、同じ単位行列が得られます。 \\[ I^n = I \\]\n逆行列は単位行列となる。 \\[ II^{-1} = I^{-1}I = I \\]\n単位行列は、対称行列である。\n\n\n\n対角行列（Diagonal Matrix）：主対角線上以外の要素がすべて0で、主対角線上の要素が非ゼロの行列です。\nJuliaでの対角行列の作成方法は次の通りです。\n\n# 3x3の対角行列（対角要素：1, 2, 3）\nD = Diagonal([1, 2, 3])\nD\n\n3×3 Diagonal{Int64, Vector{Int64}}:\n 1  ⋅  ⋅\n ⋅  2  ⋅\n ⋅  ⋅  3\n\n\n\n\n対称行列（Symmetric Matrix）：転置しても元の行列と等しい行列です。主対角線を中心に対称な要素を持ちます。\nJuliaでの対称行列の作成方法は次の通りです。\n\n# 3x3の対称行列\nSym = Symmetric(\n    [1 2 3;\n     2 4 5;\n     3 5 6]\n)\nSym\n\n3×3 Symmetric{Int64, Matrix{Int64}}:\n 1  2  3\n 2  4  5\n 3  5  6\n\n\n\n転置した行列と等しい。 \\[ D^\\mathrm{T} = D \\]\n対称行列の和は対称行列になる。 \\[ (D_1 + D_2)D_1^\\mathrm{T} = D_1 + D_2 \\]\n要素全てが実数のエルミート行列である。\n\n\n\n上三角行列（Upper Triangular Matrix）：主対角線より下の要素がすべて0である行列です。\nJuliaでの上三角行列の作成方法は次の通りです。\n\n# 3x3の上三角行列（対角要素：1, 2, 3）\nUT = UpperTriangular(\n    [1 2 3; \n     0 4 5; \n     0 0 6]\n)\nUT\n\n3×3 UpperTriangular{Int64, Matrix{Int64}}:\n 1  2  3\n ⋅  4  5\n ⋅  ⋅  6\n\n\n\n\n下三角行列（Lower Triangular Matrix）：主対角線より上の要素がすべて0である行列です。\nJuliaでの下三角行列の作成方法は次の通りです。\n\n# 3x3の下三角行列（対角要素：1, 2, 3）\nLT = LowerTriangular(\n    [1 0 0;\n     2 3 0;\n     4 5 6]\n)\nLT\n\n3×3 LowerTriangular{Int64, Matrix{Int64}}:\n 1  ⋅  ⋅\n 2  3  ⋅\n 4  5  6\n\n\n\n\nエルミート行列（Hermitian Matrix）：転置共役しても元の行列と等しい行列です。主対角線を中心にエルミート（共役転置）な要素を持ちます。\nJuliaでのエルミート行列の作成方法は次の通りです。\n\n# 3x3のエルミート行列\nHermit = Hermitian(\n    [1     2+3im 4-1im;\n     2-3im 5     6+2im;\n     4+1im 6-2im 7     ]\n)\nHermit\n\n3×3 Hermitian{Complex{Int64}, Matrix{Complex{Int64}}}:\n 1+0im  2+3im  4-1im\n 2-3im  5+0im  6+2im\n 4+1im  6-2im  7+0im\n\n\n\n\nフロベニウス行列（Frobenius Matrix）：非負整数の正方行列で、各行の要素が行番号と列番号の積と等しい行列です。\nJuliaでのフロベニウス行列の作成方法は次の通りです。\n\nusing SpecialMatrices\n# 3x3のフロベニウス行列\nFrobenius(3, [1, 2, 3])\n\n6×6 Frobenius{Int64}:\n 1  0  0  0  0  0\n 0  1  0  0  0  0\n 0  0  1  0  0  0\n 0  0  1  1  0  0\n 0  0  2  0  1  0\n 0  0  3  0  0  1\n\n\n\n\n巡回行列（Circulant Matrix）：行列の各行が循環的にシフトされた結果得られる行列です。\nJuliaでの巡回行列の作成方法は次の通りです。\n\nusing ToeplitzMatrices\n# 3x3の巡回行列\nCirculant([1, 2, 3])\n\n3×3 Circulant{Int64, Vector{Int64}}:\n 1  3  2\n 2  1  3\n 3  2  1\n\n\n\n\nハンケル行列（Hankel Matrix）：対角線から左上方向と右下方向に同じ要素が並ぶ行列です。\nJuliaでのハンケル行列の作成方法は次の通りです。\n\n# 3x3のハンケル行列\nHankel([1,2,3,4,5,6], (3,4))\n\n3×4 Hankel{Int64, Vector{Int64}, Tuple{Int64, Int64}}:\n 1  2  3  4\n 2  3  4  5\n 3  4  5  6"
  },
  {
    "objectID": "page-julia-linearalgebra-2.html",
    "href": "page-julia-linearalgebra-2.html",
    "title": "mysite",
    "section": "",
    "text": "線形代数\n行列の分解手法は沢山ありますが、固有値分解は最も汎用的に役立つ例の一つです。\n\n固有値と固有ベクトル\n固有値（Eigenvalues）と固有ベクトル（Eigenvectors）は、線形代数において重要な概念です。 これらの対（組）を固有対（eigenpair）と呼ぶことがあります。 固有値と固有ベクトルは、行列に対して特定の性質を持つベクトルとスカラー値です。\n行列Aが与えられたとき、ベクトル \\(v\\) とスカラー \\(\\lambda\\) に対して以下の式が成り立つとき、\\(v\\) を \\(A\\) の固有ベクトル、\\(\\lambda\\) を \\(A\\) の固有値と呼びます。\n\\[ A v = \\lambda v \\]\nこの式は、行列 \\(A\\) によってベクトル \\(v\\) が \\(\\lambda\\) 倍に変換されることを表しています。 固有ベクトルは方向が変化せずにスケールされるため、行列の変換の中で特別な役割を果たします。\n固有ベクトルは、行列を関数として扱いたいときに効力を発揮します。 超便利！\n行列が異なる固有値を持つ \\(n\\) 個の線形独立な固有ベクトルを持つ場合、その行列は対角化可能だと言えます。 この『対角化』とは、行列 \\(A\\) を以下の形式で表せるということです。 実際、式をいじってみるとこうなります。 \\[ A = PDP^{-1} \\]\nJuliaで固有値、固有ベクトルを求める方法は以下の通りです：\n\nusing LinearAlgebra\nA = rand(3, 3)\nF = eigen(A) # F.valuesが固有値, F.vectorsが固有ベクトル\nF\n\nEigen{ComplexF64, ComplexF64, Matrix{ComplexF64}, Vector{ComplexF64}}\nvalues:\n3-element Vector{ComplexF64}:\n -0.17368081196005505 - 0.3039770069012261im\n -0.17368081196005505 + 0.3039770069012261im\n   1.5431914300861154 + 0.0im\nvectors:\n3×3 Matrix{ComplexF64}:\n  0.526931+0.302582im   0.526931-0.302582im  0.532166+0.0im\n -0.251746-0.400011im  -0.251746+0.400011im  0.644524+0.0im\n -0.638281-0.0im       -0.638281+0.0im       0.548988+0.0im\n\n\nF.valuesを見ると内部が昇順にソートされてるのが分かると思います。 固有値は大きさで挙動が変わるので確かめておくと便利です。\nちなみに、固有値の定義から以下のように計算すると、実際に値が正しいか確認できます。\n\nP, D = F.vectors, diagm(F.values)\nA - P * D * inv(P)\n\n3×3 Matrix{ComplexF64}:\n -2.22045e-16-0.0im  -1.11022e-15+3.04406e-17im   7.21645e-16-2.61836e-17im\n -2.22045e-16-0.0im   3.33067e-16+3.68676e-17im  -1.11022e-16-4.55896e-17im\n -3.33067e-16-0.0im  -1.11022e-16+3.14028e-17im   1.11022e-16-8.25225e-17im\n\n\n誤差が十分小さいので、\\(A\\) を表現できたと確認できましたね。\nもし、使いたい行列が \\(A=PDP^{-1}\\) となったとしたら、そのことは凄く重要な意味を持ちます。\n\n\n固有値の性質\n\nトレースが全ての固有値の和になる\n\n\ntr(A) - sum(F.values)\n\n2.220446049250313e-16 - 0.0im\n\n\n\n行列式が全ての固有値の積になる。\n\n\ndet(A) - prod(F.values)\n\n-3.885780586188048e-16 - 0.0im\n\n\n\n逆行列が固有値の逆数で簡単に求められる（後述する行列関数の特殊ケース）\n\n\ninv_D = diagm(F.values .^ -1)\ninv(A) - (P * inv_D * inv(P))\n\n3×3 Matrix{ComplexF64}:\n 1.44329e-15-0.0im  -8.88178e-16+1.27824e-17im  8.88178e-16-1.22017e-16im\n 8.88178e-16-0.0im  -1.77636e-15+1.54812e-17im  6.66134e-16-1.33162e-17im\n  -2.498e-15-0.0im   1.77636e-15+1.31865e-17im          0.0+9.96799e-17im\n\n\n\n行列関数の高速計算に使える。 \\(A^n\\) みたいな計算を特に考えずに \\(AAA...AA\\) と行列の積で計算しようとする相当なコストがかかります。 なぜなら、\\(A\\) が \\(m\\times m\\) 行列だとすれば、単純な掛け算が \\(O(nm^3)\\) も行われるからです。 しかし、固有値を使うと、\\(A=PDP^{-1}\\) より、\\(A^n = A=P D^n P^{-1}\\) になります。 計算量は（固有値分解に係るコストを無視すれば）相当に抑えることができます。\n\n\nn = 10\nA^n - P * (D^n) * inv(P)\n\n3×3 Matrix{ComplexF64}:\n -7.81597e-14-0.0im   -7.4607e-14+1.51088e-15im  -2.13163e-14-1.29959e-15im\n -8.52651e-14-0.0im  -7.81597e-14+1.82988e-15im  -1.77636e-14-1.57398e-15im\n -8.52651e-14-0.0im  -7.81597e-14+1.55864e-15im   -2.4869e-14-1.34068e-15im\n\n\n\n\n行列関数\n行列関数（Matrix function）は、行列を入力として受け取り、行列を出力する関数です。 通常の数値関数がスカラーを操作するのに対して、行列関数は行列を操作するための特殊な関数です。 行列関数は線形代数や数値計算、物理学、統計学などの分野で広く使用されます。\nJuliaでは行列関数が標準で実装されているものが多く、固有値分解は勝手にやってくれてます。\n行列関数の具体的な例としては、以下のようなものがあります。\n\n行列の \\(n\\) 乗 \\[ A^n = P D^n P^{-1} \\]\n\n\nA ^ 5\n\n3×3 Matrix{Float64}:\n 3.55706  2.68683  1.88119\n 4.31038  3.26062  2.2685\n 3.6689   2.78246  1.92869\n\n\n\n行列の指数関数 行列指数関数は指数関数を行列に適用したもので、指数級数を用いて定義されます。 行列指数関数は、物理学や制御工学などで連立微分方程式の解を求める際に使用されます。 内部の詳細な仕様は知りませんが、固有値を使うと以下のように書けます。 \\[ e^{A} = P e^{D} P^{-1} \\]\n\n\nexp(A)\n\n3×3 Matrix{Float64}:\n 2.31989  1.47959   0.55023\n 1.89464  2.07686   1.21898\n 1.75728  0.927806  1.88681\n\n\n\n行列の対数関数 行列対数関数は対数関数を行列に適用したもので、行列指数関数の逆操作となります。 行列対数関数は、行列の対角化や行列の対称性を利用するなどの目的で使用されます。 \\[ \\log A = P \\log D P^{-1} \\]\n\n\nlog(A)\n\n3×3 Matrix{Float64}:\n -0.931117   2.84258  -2.01411\n  0.611082  -1.90257   2.15066\n  1.7123    -2.03951   1.16845\n\n\n\n行列の三角関数 行列の三角関数には行列のサイン、コサイン、タンジェントなどがあります。これらの関数は行列の固有値や固有ベクトルの計算、回転行列の操作などで使用されます。 \\[ \\sin A = P \\sin D P^{-1} \\]\n\n\nsin(A)\n\n3×3 Matrix{Float64}:\n 0.228515  0.710166    -0.0862748\n 0.563834  0.0543052    0.563262\n 0.653641  0.00929941   0.355089\n\n\n\n一般の関数 関数 \\(f(x)\\) のフーリエ級数が収束するなど、ある程度良い条件のもとでは、一般の関数 \\(f(x)\\) に対しても行列関数を適用できます。 \\[ f(x) = P f(D) P^{-1} \\]\n\n\nfunction f_MatrixFunction(f, A)\n  F    = eigen(A)\n  P, D = F.vectors, diagm(F.values)\n  f_D = diagm(f.(F.values))\n  return P * f_D * inv(P)\nend\n\nf_MatrixFunction(x -> tan(x+pi), A)\n\n3×3 Matrix{ComplexF64}:\n 14.5569+0.0im  11.5316-7.14392e-16im  7.45733+5.86732e-16im\n 17.8917+0.0im  13.1833-8.65224e-16im  9.69777+7.58104e-16im\n 15.4125+0.0im  11.1748-7.36975e-16im  8.15657+6.33912e-16im"
  },
  {
    "objectID": "page-julia-numbertheory-1.html",
    "href": "page-julia-numbertheory-1.html",
    "title": "mysite",
    "section": "",
    "text": "整数論\n\n漸化式\n漸化式は僕の分野だと何に役立つか良く分かりません。 同次形の微分方程式にちょっと似てるかなってくらいです。\nただ、再帰的な解法を解くためのツールとして、何かに役立つかもしれないと思います。\nNaiveな方法なら、初期項 \\(a_0\\) から 更新式 \\(a_n = f(a_{n-1}, ..., a_0)\\) で逐次求めていけば良いだけのものです。\n\n\n漸化式の解法\n\nケースA\nA  \\(a_n = a_{n-1} + d\\)   \\(\\Rightarrow\\)  A’  \\(\\Delta a_n = a_n - a_{n-1} = d\\)   \\(\\Rightarrow\\)   \\(a_n = nd + a_0\\) \n\n\nケースB\nB  \\(a_n = r a_{n-1}\\)  \\(\\Rightarrow\\)   \\(a_n = r^n a_0\\) \n\n\nケースC\nC  \\(a_n = a_{n-1} + f(n)\\)   \\(\\Rightarrow\\)  C’  \\(\\Delta a_n = a_n - a_{n-1} = f(n)\\)   \\(\\Rightarrow\\)   \\(a_n= a_0 + \\sum_{k=1}^{n} f(k)\\) \n\n\nケースD\nD  \\(a_n = p a_{n-1} + q\\)   \\(\\Rightarrow\\)  D’  \\(b_n = p b_{n-1}\\)   \\(\\Rightarrow\\)  B\n\n\n式変形\n\n\\(p \\neq 1\\) かつ \\(n \\rightarrow \\infty\\) において \\(a_n \\rightarrow \\alpha\\) とする。 このとき、\\(b_n = a_n - \\alpha\\) と置くと、以下のように変形できます。 \\[\n\\begin{array}{rr}\n           & a_n    = p a_{n-1} + q\\\\\n  +\\big{)} & \\alpha = p \\alpha  + q\\\\\n  \\hline\n           & b_n    = p b_{n-1}\n\\end{array}\n\\]\n\n\n\nケースE\nE  \\(a_n = p a_{n-1} + q r^n\\)   \\(\\Rightarrow\\)  E’  \\(b_n = \\frac{p}{r} b_{n-1} + q\\)   \\(\\Rightarrow\\)  D\n\n\n式変形\n\n\\(b_n=\\frac{a_n}{r^n}\\) と置くと、以下のように変形できます。 \\[\n\\frac{a_n}{r^n} = \\frac{p a_{n-1}}{r^n}               + q \\Rightarrow\n\\frac{a_n}{r^n} = \\frac{p}{r} \\frac{a_{n-1}}{r^{n-1}} + q \\Rightarrow\nb_n             =         b_{n-1}                     + q\n\\]\n\n\n\nケースF\nF  \\(a_n = p a_{n-1} + q n + r\\)   \\(\\Rightarrow\\)  F’  \\(b_n = p b_{n-1} + q\\)   \\(\\Rightarrow\\)  D\n\n\n式変形\n\n\\(b_n=a_n - a_{n-1}\\) と置くと、以下のように変形できます。 \\[\n\\begin{array}{rr}\n           & a_n     = p a_{n-1} + q n     + r\\\\\n  +\\big{)} & a_{n-1} = p a_{n-2} + q (n-1) + r\\\\\n  \\hline\n           & b_n     = p b_{n-1} + q\n\\end{array}\n\\]\n\n\n\nケースG\nG  \\(a_n + p a_{n-1} + q a_{n-2} = 0\\)   \\(\\Rightarrow\\)  特性方程式  \\(\\Rightarrow\\)   \\(t^n + p t^{n-1} + q t^{n-2} = 0, a_n=t^n\\)   \\(\\Rightarrow\\)   \\(t^2 + p t + q = 0, a_n=t^n\\) \n\n\nケースH1\nH1  \\(a_n^k = r a_{n-1}^l\\)   \\(\\Rightarrow\\)  H1’  \\(k b_n = \\log(r) + l b_{n-1}\\)   \\(\\Rightarrow\\)  D\n\n\n式変形\n\n\\(b_n = \\log(a_n)\\)とすると、以下のように書き表せる。 \\[k \\log(a_n) = \\log(r) + l \\log(a_{n-1})\\] \\[k b_n = \\log(r) + l b_{n-1}\\]\n\n\n\nケースH2\nH2  \\(a_n^k = r a_{n-1}^l a_{n-2}^m\\)   \\(\\Rightarrow\\)  対数\n\n\nケースI\nI  \\(a_n = \\frac{p a_{n-1}}{r a_{n-1} + s}\\)   \\(\\Rightarrow\\)  逆数\n\n\nケースJ\nJ  \\(a_n = \\frac{p a_{n-1}}{r a_{n-1} + s}\\)   \\(\\Rightarrow\\)  \\(x=\\frac{p x}{r x + s}\\) で平行移動\n\n\nケースK\nK  \\(a_n=p a_{n-1}+q b_{n-1} , b_n = r a_{n-1} + s b_{n-1}\\)   \\(\\Rightarrow\\)  行列の固有値"
  },
  {
    "objectID": "page-julia-numericalanalysis-MonteCarlo.html",
    "href": "page-julia-numericalanalysis-MonteCarlo.html",
    "title": "mysite",
    "section": "",
    "text": "数値解析の基礎\n\nモンテカルロ法\nモンテカルロ法とは、シミュレーションや数値計算を乱数を用いて行う手法の総称です。 元々は、中性子が物質中を動き回る様子を探るためにスタニスワフ・ウラムが考案しジョン・フォン・ノイマンにより命名された手法です。 カジノで有名な国家モナコ公国の4つの地区（カルティ）の1つであるモンテカルロから名付けられた。ランダム法とも呼ばれます。\n円周率の計算が例として挙げられますが、上記の通りとてもふわふわした定義なので、応用範囲もとても膨大です。\n参考\n\n\nモンテカルロ法で公式を求める\n円周率や四角錐や球などの公式は、数理モデルを上手く予測できれば、モンテカルロ法で簡単に解くことができます。\n\n円の公式を求める\n円の面積の公式を求めたいものとします。 面積は \\(r^2\\) に比例するというモデルを採用し、 \\(A = p r^2\\) という式を予測します。\n円を囲う正方形の面積は、\\(B=4r^2\\) であり、\\(A:B = p:4\\) となることが分かります。\nここで、一様に乱数を \\(B\\) 内部に発生させた場合、その乱数が \\(A\\) に入っている割合は \\(\\frac{A}{B}=\\frac{p}{4}\\) に収束するはずです。\n実際にやってみます。\nまず、乱数を生成します。なお、0~1範囲で考えます。\n\nusing Random, Plots\nRandom.seed!(0)\nn    = 1000\nx, y = rand(n), rand(n)\n\n([0.4552384158732863, 0.5476424498276177, 0.7733535276924052, 0.9405848223512736, 0.02964765308691042, 0.74694291453392, 0.7468008914093891, 0.9766699015845924, 0.32933536727734813, 0.6720006783993265  …  0.7072449674757433, 0.15432438066942566, 0.3355867684577334, 0.11787146264666937, 0.4326256342755368, 0.3263459955343042, 0.5040915702513394, 0.4363318426010223, 0.06184246643407698, 0.5336768573898811], [0.16014320814891514, 0.5011358617291459, 0.018743665453639813, 0.8601828553599953, 0.6556360448565952, 0.7746656838366666, 0.7817315740767116, 0.5553797706980106, 0.6028345068808697, 0.5690620902865082  …  0.6889826593908546, 0.9148951558240528, 0.1436759291283286, 0.5991633714310699, 0.312059069800222, 0.5199998247362753, 0.7200565636157686, 0.05883652803392858, 0.7601316084452316, 0.7233055822178146])\n\n\n次に、プロットして確かめてみます。\n\nt = range(0, 2π, 1000)\nxc = ((r, θ) -> r*cos(θ)).(1, t)\nyc = ((r, θ) -> r*sin(θ)).(1, t)\nplt = plot(\n    xc, yc, \n    xlims=(0, 1), ylims=(0, 1), \n    linewidth = 3, linecolor=:black, \n    aspect_ratio=1.0\n)\nscatter!(plt, x, y)\n\n\n\n\nパラメータ \\(p\\) は以下のように計算できます。\n\n# p / 4 = n' / n\nn_ = sum(x.^2 + y.^2 .< 1)\np  = 4 * n_ / n\np\n\n3.076\n\n\nよって、予測した円の面積の公式は以下の通りです。本来 \\(p=π=3.141...\\) なので、ちょっと惜しい感じですね。\n\\[\nA = 3.076 r^2\n\\]\n\n\n四角錐（正方形を底面とする錐）\n\n数理モデル\n四角錐の体積 \\(A = p h a^2\\)\n囲う境界内部\n立方体の体積 \\(B = 8 h a^2\\)\nよって、\\(\\frac{A}{B} = p\\)\n境界の判定式\n判定式 \\((x + z < 1) \\wedge (y + z < 1), \\;\\;\\; h=a=1\\)\n\n\nRandom.seed!(0)\nn       = 1000\nx, y, z = rand(n), rand(n), rand(n)\n\nn_ = sum((x + z .< 1) .& (y + z .< 1))\n# p = n' / n\np  =  n_ / n\np\n\n0.354\n\n\nよって、予測した球の体積の公式は以下の通りです。本来は \\(p=\\frac{1}{3}=0.333...\\) です。\n\\[\nA = 0.354 h a^2\n\\]\n\n\n球\n\n数理モデル\n球の体積 \\(A = p r^3\\)\n囲う境界内部\n立方体の体積 \\(B = 8 r^3\\)\nよって、\\(\\frac{A}{B} = \\frac{p}{8}\\)\n境界の判定式\n判定式 \\(x^2 + y^2 < r^2\\)\n\n\nRandom.seed!(0)\nn       = 1000\nx, y, z = rand(n), rand(n), rand(n)\n\nn_ = sum(x.^2 + y.^2 + z.^2 .< 1)\n# p / 8 = n_ / n\np  = 8 * n_ / n\np\n\n4.296\n\n\nよって、予測した球の体積の公式は以下の通りです。本来は \\(p=\\frac{4}{3} \\pi=4.188...\\) です。\n\\[\nA = 4.296 r^3\n\\]\n\n\n\nモンテカルロ法で数値積分\n上記の通り、モンテカルロ法は体積や面積を求めるのに使えます。\nこれは積分ができることと同義です。\n\n自然な手法\n\n\nMISER法\n\n\nVEGAS法"
  },
  {
    "objectID": "page-julia-numericalanalysis-QR.html",
    "href": "page-julia-numericalanalysis-QR.html",
    "title": "mysite",
    "section": "",
    "text": "数値解析の基礎\n\nQR分解\nQR分解（QR decomposition）は、行列 \\(A\\) を直交行列 \\(Q\\) と上三角行列 \\(R\\) の積に分解する手法です。\nQR分解は数値解析や線形代数の応用分野で広く使われています。\n\\[\nA = QR\n\\]\nQR分解は正方行列に限らず、 \\(A \\in \\mathbb{R}^{m\\times n}, m \\ge n\\) の行列に適用できます。その時の式は以下の通りです。\nこの場合も \\(Q \\in \\mathbb{R}^{m \\times m}, R \\in \\mathbb{R}^{m \\times n}\\) の形式を使うのが一般的ですが、数値計算上の効率性を考えると \\(Q_1 \\in \\mathbb{R}^{m \\times n}, R_1 \\in \\mathbb{R}^{n \\times n}\\) の形式（エコノミー分解形式）を使う方がより適切です。\n\\[\nA = Q R = \\begin{bmatrix} Q_1 & Q_2 \\end{bmatrix} \\begin{bmatrix} R_1 \\\\ O \\end{bmatrix}\n  = Q_1 R_1\n\\]\n\n\nグラム・シュミットの直交化法\n「グラム・シュミットの直交化法によるQR分解」は、QR分解を分かりやすく説明するうえで重要なアルゴリズムです。\nただし、実際の実装では使いにくいため、このアルゴリズムを用いて数値計算を行うことは稀です。\n\n\n\n\ngraph LR\n  A[A] -- 直交化 --> B[Q]\n  B --> C[R]\n\n\n\n\n\n\n\n\n\n\\(A\\) からグラム・シュミットの直交化により、\\(Q\\) を構築\nグラム・シュミットの直交化は、ベクトル \\(\\{x_j \\in \\mathbb{R}^{m}\\}_{j=1}^{n}\\) を使って直交する \\(n\\) 本のベクトル \\(\\{e_j \\in \\mathbb{R}^{m}\\}_{j=1}^{n}\\) を作るアルゴリズムです。\nこの手法は、次のような漸化式で計算されます(\\(e_j\\) などは縦ベクトルを想定)。\nこれをプログラムで実装することを考える。\n\\[\ne_i = \\frac{u_i}{\\|u_i\\|}, \\;\\;\\; u_i = x_i - \\sum_{j=1}^{i-1} e_j e_j^\\mathrm{T} x_i, \\;\\;\\; e_1 = \\frac{x_1}{\\|x_1\\|}\n\\]\n\\(n\\) についての漸化式によって、\\(e_i\\) を求めるプログラムを実装すると、以下の通りになる。\n\nusing LinearAlgebra\n\nfunction e_orth!(x, E, i)\n    u = x - sum( E[:,j]' * x * E[:,j] for j = 1:i-1 )\n    e = u / norm(u)\n    E[:,i] = e\nend\n;\n\nよって、グラム・シュミットの直交化は以下のように実装される。\n\nfunction orth_gram_schmidt(X)\n   E = zeros(size(X))\n   E[:, 1] = X[:,1] / norm(X[:,1])\n   for i = 2:size(X, 2)\n       xi = X[:,i]\n       e_orth!(xi, E, i)\n   end\n   return E\nend\n\nE = orth_gram_schmidt(rand(3, 3))\nE' * E # 単位行列になっている。\n\n3×3 Matrix{Float64}:\n  1.0          -3.60822e-16  -8.88178e-16\n -3.60822e-16   1.0           1.05471e-15\n -8.88178e-16   1.05471e-15   1.0\n\n\n\n\n\\(Q\\) から \\(R\\) を構築\n作成した直交行列を用いると、行列 \\(A=[a_1, a_2, ..., a_n]\\) の各ベクトル \\(a_i\\) は以下のように表現されることになります。\n\\[\na_i = \\sum_{j=1}^{i} e_j e_j' a_i = [e_1, \\dots, e_i, e_{i+1}, \\dots, e_n] \\begin{bmatrix}e_1' a_i \\\\ \\vdots \\\\ e_i' a_i \\\\ 0 \\\\ \\vdots \\\\ 0 \\end{bmatrix}\n\\]\nよって、\\(A\\) は以下のようになります。\n\\[\nA = \\begin{bmatrix}\n  e_1'a_1 & e_1'a_2 & e_1'a_3 & \\dots \\\\\n  0       & e_2'a_2 & e_2'a_3 & \\dots \\\\\n  0       & 0       & e_2'a_3 & \\dots \\\\\n  \\vdots  & \\vdots  & \\vdots  & \\vdots\n\\end{bmatrix}\n\\]\nこれをプログラムで実装すると、以下の通りになります。\n\nfunction Q_to_R(Q, A)\n    n = size(A, 2)\n    R = zeros(n, n)\n    for i = 1:n\n        for j = i:n\n            ei, aj = Q[:,i],  A[:,j]\n            R[i,j] = ei' * aj\n        end\n    end\n    return R\nend\n\nA = rand(5, 4)\nQ = orth_gram_schmidt(A)\nR = Q_to_R(Q, A)\n\n4×4 Matrix{Float64}:\n 1.38986  0.768571  1.55875    0.929791\n 0.0      0.897478  0.647178  -0.127088\n 0.0      0.0       0.844311   0.973667\n 0.0      0.0       0.0        0.393711\n\n\n\n\nQR分解の実装\nグラム・シュミットの直交化法によりQR分解を行う関数myqr_gram_schmidtは以下の通りになります。\n\nfunction myqr_gram_schmidt(A)\n    Q = orth_gram_schmidt(A)\n    R = Q_to_R(Q, A)\n    return Q, R\nend\n\nA = rand(6, 4)\nQ, R = myqr_gram_schmidt(A)\n\nnorm(A - Q*R) \n\n6.562392647709663e-16\n\n\n\n\n\nハウスホルダー法\n「ハウスホルダー法によるQR分解」は、QR分解の実用的なアルゴリズムの１つです。\n\n\n\n\ngraph LR\n  A[A] --> B[A']\n  B -- 変換 --> C[Qi]\n  C -- 小行列化 --> B\n  C --> D[R]\n\n\n\n\n\n\n\n\n\nハウスホルダー変換の意味\nハウスホルダー変換とは、法線ベクトル \\(e\\) の超平面に対して対称に点を写す変換のことです。\n変換を表す以下の行列 \\(H\\) は直交行列かつ対称行列です。\n\\[\nH = I - 2 e e^\\mathrm{T}\n\\]\nハウスホルダー変換は直交変換であるため、どんな超平面を選んでも元のベクトルのノルムを半径とした超球面上にしか変換を行うことはできないことに注意します。\nそうすると、例えば、以下のような変換を行うように \\(e\\) を選んでやることもできます。\n\\[\ny = Hx, \\;\\;\\;  y = \\begin{bmatrix} \\|x\\| \\\\ 0_{m-1} \\end{bmatrix}\n\\]\nこのときの \\(e\\) は以下のベクトルになる。\n\\[\ne =\\frac{x-y}{\\|x-y\\|}\n\\]\n\n\nQR法でのハウスホルダー変換\n以下、全体の変換により得られる行列を \\(A_i\\) 、行列Aを変換していく際の小行列として表れる行列を \\(B_i\\) と定めます。\n\\[\nA_1 = A = B_1\n\\]\n行列 \\(A_1 = A=[a_!, \\dots , a_n]\\) に対して、 \\(x=a_1, \\;\\;\\; y=[\\|x\\|, 0_{m-1}^\\mathrm{T}]^\\mathrm{T}\\) とした時のハウスホルダー変換行列 \\(H_1\\) を作用させると以下のようになります。\n\\[\nA_2 = H_1 A_1 = [H_1 a_1 , \\dots , H_1 a_n] =\n\\begin{bmatrix}\n    \\|a_1\\| & * \\\\\n    0_{m-1} & B_2\n\\end{bmatrix}\n\\]\nここで、小行列を逐次作用させていくことで、\\(k\\) 次上三角行列 \\(R_k\\) と小行列 \\(B_k\\) により、以下のような行列が作れるものとする。\n\\[\nA_k =\n\\begin{bmatrix}\n    R_k & * \\\\\n    O   & B_{k}\n\\end{bmatrix}\n\\]\nここで、\\(B_k\\) という行列に対しても同じようにハウスホルダー変換を施すことができるので、その行列を \\(H_k\\) とすると、以下のように、\\(A_k\\) から \\(A_{k+1}\\) を得る式が求められます。\n\\[\n\\begin{bmatrix}\n    I & O^\\mathrm{T}\\\\\n    O   & H_{k}\n\\end{bmatrix}\nA_k\n=\n\\begin{bmatrix}\n    I & O^\\mathrm{T}\\\\\n    O   & H_{k}\n\\end{bmatrix}\n\\begin{bmatrix}\n    R_k & * \\\\\n    O   & B_{k}\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n    R_k & *\\\\\n    O   & H_{k}B_{k}\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n    R_{k+1} & * \\\\\n    O       & B_{k+1}\n\\end{bmatrix}\n=\nA_{k+1}\n\\]\n\n\nQR法でのハウスホルダー変換の漸化式\nまとめると、\\(Q\\)、\\(R\\) を構築する以下の漸化式が得られます。\n\\[\nR = A_n, \\;\\;\\; Q = Q_1^\\mathrm{T} Q_2^\\mathrm{T} \\dots Q_t^\\mathrm{T}, \\;\\;\\; t=\\text{min}(m-1, n)\n\\]\n\\[\nA_{k+1} = Q_k A_k, \\;\\;\\; A_k=\\begin{bmatrix} R_k & * \\\\ O & B_k \\end{bmatrix} \\;\\;\\; A_1 = A = B_1\n\\]\nここで、直行行列 \\(Q_k\\) は以下の式で表されます。 なお、\\(I\\) は \\(k\\) 次単位行列、\\(O\\) はそれぞれの大きさのゼロ行列です。\n\\[\nQ_k =\n\\begin{bmatrix}\n    I & O^\\mathrm{T}\\\\\n    O   & H_{k}\n\\end{bmatrix}, \\;\\;\\;\nH_k = I - 2 ee', \\;\\;\\;\ne =\\frac{x-y}{\\|x-y\\|}, \\;\\;\\;\nx = b_1, \\;\\;\\;\ny=\\begin{bmatrix} \\|b_1\\| \\\\ 0 \\end{bmatrix}, \\;\\;\\;\nb_1 = B_k[:, 1]\n\\]\n\n\nQR分解の実装\nハウスホルダー変換を行う行列を生成するプログラムは以下の通りです。\n\nusing LinearAlgebra\n\n# e を使って行列 H_k を構築する。\nH(e)    = Matrix{Float64}(I, length(e), length(e)) - 2 * e * e'\n\n# x, y を使って行列 H_k を構築する。\nH(x, y) = H((v -> v / norm(v))(x - y))\n\n# b1 を使って行列 H_k を構築する。\nfunction Bk_to_Hk(Bk)\n    b1 = Bk[:,1]\n    x  = b1\n    y  = zeros(size(b1)); y[1] = norm(b1)\n    return H(x, y)\nend\n\n# 行列 Q_k を構築する。\nfunction Ak_to_Qk!(Qk, Ak, k)\n    Qk[:, :] .= 0\n    Qk[1:k, 1:k]     = Matrix{Float64}(I, k, k)\n    Qk[k:end, k:end] = Bk_to_Hk(Ak[k:end, k:end])\nend\n;\n\n以下のように、本来計算上0になるべき部分にごく小さい値が入っているため、効率はやや悪いですが、細かい部分なのでそこを気にするのは取り敢えず止めておきます。\n\nA = rand(5, 5)\nQ = zeros(size(A))\nAk_to_Qk!(Q, A, 1)\nQ * A\n\n5×5 Matrix{Float64}:\n  0.510881      0.918488   0.649733     0.63135     0.601804\n -3.15588e-17   0.221955   0.334637     0.149022    0.00241317\n -1.10957e-16  -0.343959  -0.402003    -0.0759852   0.119281\n -3.27052e-18   0.17631    0.603643     0.124452   -0.0380358\n -6.22882e-18   0.496062  -0.00917068   0.254652    0.877774\n\n\n漸化式を適用していく部分を実装すると以下の通りになります。\n\nfunction A_next!(Q, Qk, Ak, k)\n    Ak_to_Qk!(Qk, Ak, k)\n    Ak .= Qk*Ak \n    Q  .= Q*Qk'\nend\n;\n\nQR分解の実装は以下の通りになります。\n\nfunction myqr_house(AA)\n    m, n  = size(AA)\n    Ak = copy(AA)\n    Qk = zeros(m, m)\n    Q  = Matrix{Float64}(I, m, m)\n    t = min(m-1, n)\n    for k = 1:t\n        A_next!(Q, Qk, Ak, k)\n    end\n    R = Ak\n    return Q, R\nend\n\nA = rand(4, 4)\nQ, R = myqr_house(A)\n\nnorm(A - Q*R)\n\n6.959765930514777e-16\n\n\n参考\n\n\n\nギブンス回転\n「ギブンス回転」を用いる方法は、QR分解の実用的なアルゴリズムの１つです。 並列化に向いている手法です。\n説明は暇があったら書きます。\n\n# 行列の下三角の部分だけを返す\nfunction tril_indices(m, n)\n    idx = []\n    for i = 1:m\n        for j = 1:i-1\n            if j > n\n                break\n            end\n            push!(idx, (i,j))\n        end\n    end\n    return idx\nend\n;\n\n\nfunction cos_givens_rotation(a, b)\n    r = √(a^2 + b^2)\n    rot = [\n        a/r -b/r; #  cos sin\n        b/r  a/r  # -sin cos\n    ]\n    return rot\nend\n\n\nfunction myqr_givens_rotation(A)\n    m, n = size(A)\n    Q = Matrix{Float64}(I, m, m)\n    R = copy(A)\n    for ij = tril_indices(m, n)\n        i, j = ij\n        if R[i, j] == 0\n            continue\n        end\n        G = Matrix{Float64}(I, m, m)\n        G[[j, i], [j, i]] = cos_givens_rotation(R[j, j], R[i, j])\n\n        R = G * R\n        Q = Q * G'\n    end\n    return Q, R\nend\n;\n\n\nA = rand(6, 4)\nQ, R = myqr_givens_rotation(A)\n\nnorm(A - Q*R)\n\n4.965068306494546e-16\n\n\n参考"
  },
  {
    "objectID": "page-julia-packages-Base.html",
    "href": "page-julia-packages-Base.html",
    "title": "mysite",
    "section": "",
    "text": "Juliaのパッケージ\nインストールしなくても最初から用意されている機能のパッケージです。\n\nBaseとは？\nJuliaでは、built-inの関数が大抵はこの名前空間にあります。\n例えば、rand関数はBase.rand関数と同じ関数を表しています。\nJuliaでは多重ディスパッチが許されているため、定義の違うBase.randを定義したりすることもできます。"
  },
  {
    "objectID": "page-julia-packages-Gen.html",
    "href": "page-julia-packages-Gen.html",
    "title": "mysite",
    "section": "",
    "text": "Juliaのパッケージ\nインストールするには、JuliaのREPLでusing Pkg; Pkg.add(\"Gen\")を実行してください。 使いたいタイミングでusing Genと指定して読み込んでください。\n\nusing Gen\n\n\nGenとは？\nMITが開発した、オープンソースの生成モデルと確率的推論のためのパッケージです。 一般的な仕様が できることが多いので、何から手を付けたらいいやら……。\n\nGenは確率的推論アルゴリズムの細かい実装を自動化する。\nトリッキーな数学や低レベルの実装を自動化しながら、ユーザのモデルに併せた効率的な確率的推論アルゴリズムを書くためのブロックを提供します。\nGenはパフォーマンスのトレードオフを柔軟に操作することを可能としています。\nアルゴリズムの一部はユーザの指定する言語やアルゴリズムに置き換えることができます。\nGenはカスタムハイブリッド推論アルゴリズムをサポートします。\nニューラルネットワークによる計算（低コスト）とモデルベースの計算（高コスト）の両方の長所を生かしたアルゴリズムをサポートしています。\nコンパイラを拡張することなく、カスタム推論アルゴリズムを書くことができる。\n確率的構造を持つモデルにおける効率的な推論\n\nWhy Gen\n\n\nGenの使い方\nTutorial"
  },
  {
    "objectID": "page-julia-packages-Images.html",
    "href": "page-julia-packages-Images.html",
    "title": "mysite",
    "section": "",
    "text": "Juliaのパッケージ\nインストールするには、JuliaのREPLでusing Pkg; Pkg.add(\"Images\")を実行してください。 使いたいタイミングでusing Imagesと指定して読み込んでください。\n\nusing Images\n\n\nImagesとは？\nImagesはjuliaの画像処理を扱うパッケージです。\n画像データの読み込み、保存、変換、操作など、さまざまな画像処理タスクをサポートしています（ゲームなどで画像を扱いたいときは別のライブラリを使ってください）。\n高速な画像処理を実現するために、Juliaの高性能な数値計算機能や並列処理機能を活用しています。\nImages.jlは、画像データを表現するためのImage型や、画像処理関数の集合などの主要な要素から構成されています。以下に、Images.jlの主な機能と使用例をいくつか示します。\nImageViewやImageShowというパッケージを併せて使えば、imshowなどの関数によって画像の表示ができますが、保存やnotebookでの表示は成功するので気にしないでください（このパッケージ、なぜか重いので私の環境では使っていません）。\n画像の確認はdisplayで行ってください。\n参考\n\n\nImagesの使い方\n\n画像の読み込み\n画像はload関数で読み込めます。\n\nimg1 = load(\"tmp/__imagesample1.bmp\")\ndisplay(img1)\n\n\n\n\n\n\n画像の書き込み（保存）\n書き込みはsave関数です。\n\nx = collect(1.0:-0.1:0)\nimg2 = Gray.(x * x')\ndisplay(img2)\nsave(\"tmp/__imagesample2.png\", img2)\n\n\n\n\n\n\n画像の操作\nグレイスケールにする。\n\nimg1_gray = Gray.(img1)\n\n\n\n\nサイズを変更する。\n\nsiz = (10, 10)\nimg1_resized = imresize(img1, siz)\n\n\n\n\n回転する。\n\nimg1_rotated = imrotate(img1, 45)\n\n\n\n\n切り取る。\n\nss = size(img1)\nimg1_cropped = img1[1:ss[1] ÷ 2, 1:ss[2]  ÷ 2]"
  },
  {
    "objectID": "page-julia-packages-LinearAlgebra.html",
    "href": "page-julia-packages-LinearAlgebra.html",
    "title": "mysite",
    "section": "",
    "text": "Juliaのパッケージ\nインストールしなくても最初から用意されているパッケージです。 プログラムの最初の方でusing LinearAlgebraと指定して読み込んでください。\n\nLinearAlgebraとは？\n行列の計算などをするのに適したパッケージです。 ただし、疎行列などの問題に適したアルゴリズムではないので注意してください。\n数値計算で使われる機能は大半このパッケージに含まれます。 また、BLASやLAPACKの機能が含まれます。\nここで述べる学問領域は僕の得意分野ですが、このセクションでは簡単な使い方の例を紹介するに留めます。\n参考\n\n\n基本的な機能\n\nノルム\nベクトルのノルムを求められます。 デフォルトはユークリッド空間における通常のノルム(２ノルム)になります。\n\nusing LinearAlgebra\nnorm([1, 2, 1])\n\n2.449489742783178\n\n\n\n\n内積\nベクトル同士のドット積（内積）を求められます。\n\ndot([1,3,2], [4,1,6])\n\n19\n\n\n\n\n外積\nベクトル同士のクロス積（外積）を求められます。\n\ncross([1,3,2], [4,1,6])\n\n3-element Vector{Int64}:\n  16\n   2\n -11\n\n\n\n\n行列式\n行列の行列式を求められます。\n\nA = [\n    1 2 4;\n    5 4 1;\n    9 2 6.0\n]\ndet(A)\n\n-124.0\n\n\n\n\nトレース\n行列のトレースを求められます。\n\nA = [\n    1 2 4;\n    5 4 1;\n    9 2 6.0\n]\ntr(A)\n\n11.0\n\n\n\n\n\n固有値問題\n固有値問題を解きます。\n\nA = rand(10, 10)\n\nF = eigen(A) # Λ, V = eigen(A)でもOK\nΛ, V = F.values, F.vectors\n\nnorm(\n    A*V - V*diagm(Λ)\n)\n\n1.3988919810697231e-14\n\n\n\n\n特異値分解\n特異値分解を解きます。(エコノミーサイズです)\n\nA = rand(10, 8)\n\nF = svd(A) # U, S, V = svd(A)でもOK\nU, S, V = F.U, F.S, F.V\n\nnorm(\n    A - U*diagm(S)*V'\n)\n\n3.2209424127120038e-15\n\n\n\n\nLU分解\nLU分解を解きます。\n\nA = rand(10, 8)\n\nF = lu(A) # L, U = lu(A)\nL, U, p = F.L, F.U, F.p\n\nnorm(\n   A[p,:] - L*U\n)\n\n3.9852227955858445e-16\n\n\n\n\nQR分解\nQR分解を解きます。\n\nA = rand(10, 8)\n\nF = qr(A)\nQ, R = F.Q, F.R\n\nnorm(\n    A - Q*R\n)\n\n1.3076087352977526e-15"
  },
  {
    "objectID": "page-julia-packages-MAT.html",
    "href": "page-julia-packages-MAT.html",
    "title": "mysite",
    "section": "",
    "text": "Juliaのパッケージ\nインストールするには、JuliaのREPLでusing Pkg; Pkg.add(\"MAT\")を実行してください。\n\nMATとは？\n数値計算や機械学習の分野では、計算途中のデータを保存することで、事故の発生を防ぎたいことがあります。 多くの場合、.csvや.txtや.jsonといったファイル形式で保存するのですが、その他の方法として、Matlabの変数を格納する.mat形式のファイルを使いたい場合があります。\nこんなとき、MATパッケージを使用すれば、変数を辞書型にまとめて保存することができ、その辞書をファイルからそのまま取り出すこともできます。\nまた、このファイルは「MATLAB v7.3 format.」によって書き込まれるため、matlabでも読み込み可能です。\n参考文献\n\n\nMATの使い方\n\n書き込み\n書き込みは以下のように、ファイルのパスを与えて辞書型のデータを関数に渡すことで行います。\n\nusing MAT\n\nd = Dict(\n    \"var1\" => \"hello\",\n    \"var2\" => rand(3, 3)\n)\n\nmatwrite(\"tmp/__matfile.mat\", d)\n\n\n\n読み込み\n読み込みは以下のように、ファイルのパスを与えて辞書型のデータを受け取ることで行います。\n\ne = matread(\"tmp/__matfile.mat\")\ne\n\nDict{String, Any} with 2 entries:\n  \"var1\" => \"hello\"\n  \"var2\" => [0.747694 0.818366 0.44244; 0.123226 0.816386 0.0572965; 0.603717 0…"
  },
  {
    "objectID": "page-julia-packages-Pkg.html",
    "href": "page-julia-packages-Pkg.html",
    "title": "mysite",
    "section": "",
    "text": "Juliaのパッケージ\nインストールしなくても最初から用意されているパッケージです。 主にPEPLで、使いたいタイミングでusing Pkgと指定して読み込んでください。\n\nPkgとは？\nJuliaのパッケージインストーラです。\n主に、パッケージのインストールを行う際に使うものです。 プログラム中で使うことはあまり想定されてないため、JuliaのREPL上で実行してください。\n\nパッケージのインストール\nインストール方法は２つあります（やり方が違うだけで両方同じです）。\n\nPkgパッケージの関数addを使ってインストールする。\nusing Pkg; Pkg.add(\"パッケージ名\")というコマンドによって、インストールできます。\n]add パッケージ名でパッケージインストーラを起動する。\nREPL上でjulia> ]として、(***) pkg>と出た時点で、add パッケージ名としてください。\n\n\n\nプロジェクトの操作\n\nパッケージの作成\n以下のコマンドを実行して、新しいパッケージを作成します。 これにより、パッケージのskeltonが生成されます。\n] generate パッケージのパス\nパッケージのアクティベート\nJuliaのREPL（対話型環境）で以下のコマンドを実行します。このコマンドは、作成したプロジェクトのディレクトリをアクティブな環境として設定します。\n] activate パッケージのパス\nJuliaで開発を行う際には、Revise.jlというパッケージを使うと便利です。 Reviseは、外部から与えられる変更を監視してREPL上で扱われるパッケージの内容が自動で更新されるので便利です。"
  },
  {
    "objectID": "page-julia-packages-Plots.html",
    "href": "page-julia-packages-Plots.html",
    "title": "mysite",
    "section": "",
    "text": "Juliaのパッケージ\nインストールするには、JuliaのREPLでusing Pkg; Pkg.add(\"Plots\")を実行してください。\n実行時には、以下のように読み込んでください。\n\nusing Plots\n\n\nPlotsとは？\n数字だけ見てもデータの意味が分かりにくいことが多いので、グラフの利用は数値計算の分野では重要です。\n例えば、乱数を生成するrand関数で作った３次元の点群がどのようになっているかを数字とグラフでそれぞれ表示してみます。\n\nusing Random\nRandom.seed!(0)\n\nn = 100\nx, y, z = rand(n), rand(n), rand(n)\ndisplay.([x', y', x'])\n;\n\n1×100 adjoint(::Vector{Float64}) with eltype Float64:\n 0.455238  0.547642  0.773354  0.940585  …  0.351491  0.193291  0.116989\n\n\n1×100 adjoint(::Vector{Float64}) with eltype Float64:\n 0.655636  0.774666  0.781732  0.55538  …  0.355375  0.524008  0.279907\n\n\n1×100 adjoint(::Vector{Float64}) with eltype Float64:\n 0.455238  0.547642  0.773354  0.940585  …  0.351491  0.193291  0.116989\n\n\n\nusing Plots \nscatter(x, y, z)\n\n\n\n\n勿論、グラフの方が分かりやすいと思います。\nこのように、Plotsでは、数値を可視化する機能が複数用意されています。\n\n\n折れ線グラフplot, plot!\nplotは連続的なデータや関数の表示が得意な関数です。 基本的には、折れ線グラフの表示を行いますが、他のプロットにも使える多機能な関数です。\n\n関数のプロット\n以下のように、関数をプロットできます。\n\nplt = plot(sin)\nplot!(plt, cos) # 重ねて描く\n\ndisplay(plt)\n;\n\n\n\n\n\n\nデータのプロット\nデータの点群を与えると、直線で結んで表示してくれます。\n\nx = 0:0.1:1\ny = (n -> n^2).(x)\nplt1 = plot(x, y)\n\n\n\n\n\n\n\n\n\n\n\n散布図scatter, scatter!\nscatterは散布図を作成する関数です。 散布図とは、データを散らしたグラフのことです。\n\nデータのプロット\n以下のようにして使えます。\n\n# 2dimプロット\nx = 0:0.1:1\ny = (n -> n^2).(x)\nscatter(x, y)\n# 3dimプロット\nx = 0:0.1:1\ny = sin.(x)\nz = exp.(x)\nplt2 = scatter(x, y, z)\n\ndisplay.([plt1, plt2])\n;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n円グラフpie\n円グラフを作成できます。\n\nデータの表示\n\nx = [\"nitrogen\", \"oxygen\", \"argon\", \"carbon dioxide gas\"]\ny = [78.11, 20.96, 0.9343, 0.03]\nplt = pie(x, y, title=\"Volume ratio of atmospheric composition on the ground\",l = 0.5)\ndisplay(plt)\n;\n\n\n\n\n\n\n\n\n参考\n\n\n\n棒グラフbar\n棒グラフを作成できます。\n\nx = [\"A\", \"B\", \"C\", \"D\"]  # x軸のラベル\ny = [3, 5, 2, 7]  # 各バーの高さ\n\nbar(x, y)\n\n\n\n\n\n\nプロットやグラフの整形方法\nグラフにタイトルを付けたいとき、描画範囲を指定したいとき、方対数グラフを作りたいときなど、参考にしてください。\n\nそのプロット全体に適用\n\nグラフのタイトルをつける\ntitle = \"Title\"\nグラフの範囲を決める\nxlims = (1.0^-5. 1)\nylims = (0, 1)\nグラフのフォントサイズを設定する\ntickfontsize = 20\nグラフの軸を対数にする\nxaxis = :log\nyaxis = :log\nグラフを箱で囲む\nframestyle = :box\nグラフに指定の目盛りを付ける\nyticks = [0, 10, 20, 30, 40, 50]\nグラフのアスペクト比を制御する。\naspect_ratio = 1.0\n\n\n\nそのグラフに適用\n\nグラフの凡例ラベルをつける\nlabel = \"func\"\n線の色を変更する\nlinecolor = :red\nグラフの線の長さを決める\nlinewidth = 3\nマーカーを設定する。\nmarkershape = :x\n\n\n\n\nプロットテクニック\n\nテンプレート\n適当に全部詰めたテンプレートが以下の通りです。 要らないものは消してください。\n\nplt = plot(\n    title = \"ThisIsTitle\",    # タイトル\n    xlims = (-10, 10),        # xの範囲\n    ylims = (1e-1, 1e10),     # yの範囲\n    tickfontsize = 5,         # フォントサイズ\n    yaxis = :log,             # y軸方対数グラフ\n    framestyle   = :box,      # 枠で囲む\n    yticks= exp.((0:10) .^ 2) # 目盛り\n)\nplot!(plt, x -> exp(x^2), \n    label = \"exp(x^2)\",       # 凡例のラベル\n    linecolor   = :red,       # 赤い線\n    linewidth   = 2,          # 線の太さ\n    markershape = :x          # マーカーの設定\n)\n\n\n\n\n\n\n対数の下駄履かせ\nイテレーションの回数などのパラメータを変化させていった時の相対誤差をプロットしたいときなど、対数プロットをしたいときがあると思います。\nコンピュータの計算では、誤差の計算結果が0になることはよくあるため、結果に下駄を履かせないとプロットが正確に行われない場合があります。\nこのとき、計算結果が0のデータは正常に表示できないため、以下のようにepsを足して下駄を履かせることで、プロットを正常に行えます。\n例えば、以下はsin関数を \\(n3\\) 次のマクローリン展開で近似した関数sin_macとの相対誤差のグラフです。\n\nfunction sin_mac(n, x)\n    q = p = x; k  = round(n/2) - 1\n    for i = 1:k\n        q = q * ((- 1) / ( (2*i) * (2*i + 1))) * x^2; p = p  + q\n    end\n  return p\nend\n\nx   = range(-10π, 10π, 1000)\ny   = sin_mac.(10, x)\ny_t = sin.(x)\n\neps = 1e-19\n\nrelerr_y = abs.((y_t - y) ./ y) .+ eps\n\nplot(x, relerr_y, yaxis=:log, ylims=(1e-10, 1e1))"
  },
  {
    "objectID": "page-julia-packages-Random.html",
    "href": "page-julia-packages-Random.html",
    "title": "mysite",
    "section": "",
    "text": "Juliaのパッケージ\nインストールするには、JuliaのREPLでusing Pkg; Pkg.add(\"Random\")を実行してください。\n\nRandomとは？\n乱数生成はありとあらゆる場所で使われています。 特に、確率的に起こる事象を扱う場合に使われます。\n参考文献\n\n\nRandomの使い方\nRandomの使い方で大切なのは、randとRandom.seed!くらいです。 他は余り使わないと思います。\n\n0~1間の乱数\nなお、rand関数はusing Randomを宣言する前からBaseに含まれています。\n\n乱数生成\n以下のように、乱数を生成できます。\n\nrand()\n\n0.2895098423219379\n\n\n\n\n５次元の配列（ベクトル）\n以下のように、ベクトルを作ることもできます。\n\nrand(5)\n\n5-element Vector{Float64}:\n 0.028549977665983994\n 0.538639413965653\n 0.8969897902567084\n 0.25847781536337067\n 0.3389490517221738\n\n\n\n\n\\(2 \\times 4\\) の行列\n以下のように、行列も作れます。\n\nrand(2,4)\n\n2×4 Matrix{Float64}:\n 0.374877  0.768433  0.876292  0.934366\n 0.444003  0.178543  0.55      0.532499\n\n\n\n\n\\(3 \\times 4\\) の複素行列\n以下のように、型に沿った行列を作るみたいなこともできます。\n\nrand(ComplexF64, 3, 4)\n\n3×4 Matrix{ComplexF64}:\n 0.043883+0.325227im   0.63344+0.21631im   …  0.913038+0.409758im\n 0.494975+0.856017im  0.414769+0.702561im     0.624384+0.0565774im\n 0.164786+0.685904im  0.870925+0.757711im     0.871887+0.355375im\n\n\n\n\nランダム選択\n以下のように、さいころの出目みたいなものを扱うこともできます。\n\nchoise = [\"A\", \"B\", \"C\", 1, 2, 3]\nn      = 10\nrand(choise, n)\n\n10-element Vector{Any}:\n 1\n  \"B\"\n  \"B\"\n  \"C\"\n 1\n  \"B\"\n 3\n  \"A\"\n  \"B\"\n 1\n\n\n\n\n\n乱数のシードの設定\n乱数は「シード」と言われるパラメータを用いて生成しています。 シードは現在時刻などを参照して決められます。\nこのシードの値を用いて、非常に周期の長い（同じパターンが起こりにくい）疑似乱数を生成しています。\nプログラムに乱数を使っている場合、シードを設定していないと「再現性」の面で問題が起きる場合があり、シードをプログラム内で設定してやることが求められる事があります。数値計算のプログラムなどではシードを設定しておくことをお勧めします。\n\nusing Random\nRandom.seed!(0)\n;\n\n\n\nランダムな置換\n\nx = [1,2,3,4,5]\nx[randperm(length(x))]\n\n5-element Vector{Int64}:\n 4\n 5\n 3\n 2\n 1\n\n\n\n\n置換によるシャッフル\n\nx = [\"a\", \"b\", \"c\", \"d\"]\nshuffle(x)\n\n4-element Vector{String}:\n \"a\"\n \"d\"\n \"b\"\n \"c\""
  },
  {
    "objectID": "page-julia-packages-Revise.html",
    "href": "page-julia-packages-Revise.html",
    "title": "mysite",
    "section": "",
    "text": "Juliaのパッケージ\nインストールするには、JuliaのREPLでusing Pkg; Pkg.add(\"Revise\")を実行してください。\n\nReviseとは？\nJuliaのReviseパッケージは、Juliaのソースコードを変更した際に、自動的に変更を検知して再評価するためのツールです。\nReviseパッケージを使用すると、開発者はREPL環境でソースコードの変更をリアルタイムに反映させることができます。\n参考\n\n\nReviseの使い方\n以下のような使用感になります。 以下は、vscodeで書き換えてREPLで評価してみた実行結果です。\n\npkg  > activate プロジェクト\njulia> using Revise        # `using プロジェクト`の前に実行してください\njulia> using プロジェクト\njulia> \njulia> プロジェクト.f(2)\nUndefVarError: f not defined\n...\njulia> # 外部ファイルで関数f(x)=x^2を追加\njulia> プロジェクト.f(2)\n4\njulia> # 外部ファイルで関数f(x)=x^3に変更\njulia> プロジェクト.f(2)\n8\njulia>"
  },
  {
    "objectID": "page-julia-packages-TaylorSeries.html",
    "href": "page-julia-packages-TaylorSeries.html",
    "title": "mysite",
    "section": "",
    "text": "Juliaのパッケージ\nインストールするには、JuliaのREPLでusing Pkg; Pkg.add(\"TaylorSeries\")を実行してください。 使いたいタイミングでusing TaylorSeriesと指定して読み込んでください。\n\nusing TaylorSeries\n\n\nTaylorSeriesとは？\nマクローリン展開やテイラー展開を扱うライブラリです。\n\n\nTaylorSeriesの使い方\n以下のように、テイラー展開のモデルと変数を定義できます。\n※Taylor1とかTaylorNという関数で変数を定義する方法もありますが、あまり有用性が分かりませんでした。\n\ntaylor_vars = set_variables(\n  \"x\",      # 変数の組\n  order = 5 # テイラー展開で計算する次数\n)\n\nx = taylor_vars[1]\ntaylor_expr = sin(x)\n\ntaylor_expr\n\n 1.0 x - 0.16666666666666666 x³ + 0.008333333333333333 x⁵ + 𝒪(‖x‖⁶)\n\n\n変数が２つの場合は以下のようになります。\n\ntaylor_vars = set_variables(\n  \"x y\",    # 変数の組\n  order = 7 # テイラー展開で計算する次数\n)\n\nx, y = taylor_vars\ntaylor_expr = exp(x + y)\n\ntaylor_expr\n\n 1.0 + 1.0 x + 1.0 y + 0.5 x² + 1.0 x y + 0.5 y² + 0.16666666666666666 x³ + 0.5 x² y + 0.5 x y² + 0.16666666666666666 y³ + 0.041666666666666664 x⁴ + 0.16666666666666666 x³ y + 0.25 x² y² + 0.16666666666666666 x y³ + 0.041666666666666664 y⁴ + 0.008333333333333333 x⁵ + 0.041666666666666664 x⁴ y + 0.08333333333333333 x³ y² + 0.08333333333333333 x² y³ + 0.041666666666666664 x y⁴ + 0.008333333333333333 y⁵ + 0.001388888888888889 x⁶ + 0.008333333333333333 x⁵ y + 0.020833333333333332 x⁴ y² + 0.027777777777777776 x³ y³ + 0.020833333333333332 x² y⁴ + 0.008333333333333333 x y⁵ + 0.001388888888888889 y⁶ + 0.0001984126984126984 x⁷ + 0.001388888888888889 x⁶ y + 0.004166666666666667 x⁵ y² + 0.006944444444444443 x⁴ y³ + 0.006944444444444443 x³ y⁴ + 0.004166666666666667 x² y⁵ + 0.001388888888888889 x y⁶ + 0.0001984126984126984 y⁷ + 𝒪(‖x‖⁸)"
  },
  {
    "objectID": "page-julia-tech-programgen.html",
    "href": "page-julia-tech-programgen.html",
    "title": "mysite",
    "section": "",
    "text": "プログラム生成\n※制作中\n\nプログラム生成の手法\n※制作中\n\n\nDSL（ドメイン固有言語）\n汎用型言語（GPL; General Purpose Language）に対して、ドメイン固有言語（DSL; Domain Specific Language）とは、特定の目的に特化した言語です。\n\n\n\nGPL\nC, C++, Fortran, Java, Python, Julia, Lisp\n\n\nDSL\nSQL, HTML, LaTex, Mathematica, gnuplot, Markdown\n\n\n\nまあ、DSLが言語だと言っても、そこまで格式ばった定義があるわけでもなく、プログラムで呼び出す設定ファイル（ini, xml, jsonとか）やパッケージ（JuliaのRandomとか）みたいなものの拡張になっていると思ってください。\nこの、設定ファイルを使う方針が外部言語的なアプローチへと拡張し、パッケージを使う方針が内部言語的なアプローチへと拡張すると考えてください。\nDSLは前述のとおり、普通のプログラム言語の機能拡張が高じたものに過ぎず、PythonやJuliaなどの優秀な言語では目的のための関数が用意されていたり、やり方が明確で少ない行数で書けることもあります。\n重要なのは問題のドメインを見失わないことでしょう。"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "mysite",
    "section": "",
    "text": "鋭意制作中"
  },
  {
    "objectID": "page-julia-packages-MLDatasets.html",
    "href": "page-julia-packages-MLDatasets.html",
    "title": "mysite",
    "section": "",
    "text": "Juliaのパッケージ\nインストールするには、JuliaのREPLでusing Pkg; Pkg.add(\"MLDatasets\"); Pkg.add(\"DataFrames\")を実行してください。\n実行時には、以下のように読み込んでください。\n\nusing DataFrames, MLDatasets\n\n\nMLDatasetsとは？\n機械学習やパターン認識で、サンプルとして一般的に使われるデータを提供するパッケージです。 個人のパソコンなどでも扱える、比較的小さなデータです。 主に以下のサイトにあるデータセットをダウンロードして提供します（初使用時にダウンロードします）。\nこれらのデータは何らかのアルゴリズムの有用性を試す際に、試用的に用いるのが良いでしょう。\nデータセットのサイト\n参考\n以下のようなデータセットがあります。\n\nMNIST（MLDatasets.MNIST）\n28*28のサイズにリサイズされた70000個の手書き数字画像のデータセットです。\n訓練データ \\(\\{X_T, y_T\\}\\) は、mnist_train=MNIST(split=:train)で読み込みます。データのサイズは、\\(X_T \\in \\mathbb{R}^{28 \\times 28 \\times 60000}\\) です。\nまた，テストデータ \\(\\{X_t, y_t\\}\\) は、mnist_test=MNIST(split=:test)で読み込みます。データのサイズは、\\(X_t \\in \\mathbb{R}^{28 \\times 28 \\times 10000}\\) です。\nFashion MNIST（MLDatasets.FashionMNIST）\nMNISTの代わりとなるデータセットです。\nCIFAR-10（MLDatasets.CIFAR10）\n60000個の小さい画像のデータセットです。\nCIFAR-100（MLDatasets.CIFAR100）\nIris（MLDatasets.Iris）\n３種（setosa, versicolor and virginica）の各アヤメの50例のデータ。\nデータの種類は、４種類（sepal length, sepal width, petal length and petal width）となる。\nBoston Housing（MLDatasets.BostonHousing）\nPTBLM\nCiteSeer\nCora\nPubMed\n\n\n\nMLDatasetsの使い方\nIris（アヤメの特徴を格納したデータセット）を例として、使い方を説明します。\n\n読み込み\n以下のようにして、データセットを読み込むことができます。 このように、irisの中身を表示すると、データセットの中に以下の３種のデータフレームがあることが分かると思います。\n\nusing DataFrames, MLDatasets\n\niris = Iris()\n\ndataset Iris:\n  metadata   =>    Dict{String, Any} with 4 entries\n  features   =>    150×4 DataFrame\n  targets    =>    150×1 DataFrame\n  dataframe  =>    150×5 DataFrame\n\n\nfeaturesが特徴で、targetsが分類されるクラス（どの種か？）で、dataframeがそれらを１つのデータフレームとしたものです。\n\n\n開放\n使わなくなったデータは以下のようにしてメモリを開放してください。 次にGC（ガーベッジコレクタ）が実行されたときに自動で開放されますが、手動でやりたい場合は、gc()を実行してください（あまりお勧めしませんが）。\n\niris = Nothing\n\nNothing"
  },
  {
    "objectID": "page-julia-lang-wiredpart.html",
    "href": "page-julia-lang-wiredpart.html",
    "title": "mysite",
    "section": "",
    "text": "Juliaの文法基礎\n\nJuliaの変なところ\nJuliaは非常に便利な言語です。 それを支えている部分ではあるのですが、他のプログラム言語と比較して、少し変な部分もあります。\nいくつかご紹介します。\n\n\nUnicodeのサポート（ひらがなも使える）\nJuliaでは大抵のUnicode文字が使えます。 便利か不便かは人によると思いますが、奇妙なのは間違いないと思います。\n英語を使うのに慣れていない人（超初心者や小学生など）にプログラミングを説明するのに向いてるかも？\n例えば、ひらがなや漢字を使って変数を定義する以下のようなプログラムも動いてしまいます。\n\n# おまじない（関数に別名を付ける）\n表示して = println\n足す,引く,掛ける,割る = +,-,*,/\n\n# やってみる（実際に動くコードの例）\nこれは２かな = 足す(1, 1)\n表示して( これは２かな )\n言いたいこと = \"ハローワールド!\"\n表示して( 言いたいこと )\n\n2\nハローワールド!\n\n\nα, βなども含め、他のUnicode文字も使えます。\nそのため、表現力の面ではJuliaは相当強いです。\n\n\n柔軟な型システム\nJuliaは強力な型システムを持っていますが、静的な型宣言が必須ではありません。 関数や変数に明示的な型注釈を付けることもできますが、Juliaは型推論によって自動的に型を推測することもできます。\nこれにより、動的なタイピングと静的なタイピングのメリットを組み合わせた柔軟なプログラミングが可能になります。\n※Integer型の行列にFloat型の値を入れたり演算をすることはできません。pythonより少しだけ型にうるさい言語だと思っておきましょう。\n\nx::Integer = 1; println(x)\ny::Float64 = 1; println(y)\nz = 1\n\n1\n\n\n\n1.0\n\n\n1\n\n\n\n\n配列のインデックス\nJuliaの配列のインデックスは、一般的なプログラミング言語とは異なり、1から始まります。 多くの言語では0から始まるインデックスが一般的ですが、Juliaでは数学的な表記に近い1から始まるインデックスが採用されています。\n同じような言語として、Fortranがあります。 JuliaはFortran技術者にとっては良い言語かもしれません。\nこれは好みの問題ですが、数学的に自然なプログガムが書けるので個人的には気に入ってます。\n\na = [1, 2, 3, 4]\na[1]\n\n1\n\n\n\n\nブロードキャスト\nJuliaは、要素ごとの演算をベクトル化して高速化することが得意です。 これにより、ループを使わずにコードを記述し、高速な計算を行うことができます。 また、Juliaのブロードキャスト機能を使用すると、異なるサイズや形状の配列の間で要素ごとの演算を行うことができます。\nループを平坦化する（ネストを減らす）ことは、可読性向上の為に重要な意味があります。 余計なループは排除しましょう。\n\n# 1:10までの数字の逆数を計算する。\n1.0 ./ (1:10)\n\n10-element Vector{Float64}:\n 1.0\n 0.5\n 0.3333333333333333\n 0.25\n 0.2\n 0.16666666666666666\n 0.14285714285714285\n 0.125\n 0.1111111111111111\n 0.1\n\n\n\n# 1:10までの数字の3乗を計算する。\nf(x) = x^3\nf.(1:10)\n\n10-element Vector{Int64}:\n    1\n    8\n   27\n   64\n  125\n  216\n  343\n  512\n  729\n 1000\n\n\n\n\n多重ディスパッチ\nJuliaの型システムには多重ディスパッチと呼ばれる機能があります。 これにより、関数が引数の型に基づいて自動的に異なる実装を選択することができます。\nこの機能は、同じ操作を異なる型に対して一貫して適用する場合に特に有用です。\n\n# 同じ数字を並べて大きな数字を作る\nfunction concat(x::Int, n::Int)\n    if n == 0\n        return 0\n    end\n    return x + 10 * concat(x, n-1)\nend\n\n# 同じ文字を並べて大きな文字列を作る\nfunction concat(x::Union{AbstractChar, AbstractString}, n::Int)\n    if n == 0\n        return \"\"\n    end\n    return x*concat(x, n-1)\nend\n\ndisplay.(\n    [concat(1, 5), concat(\"a\", 4)]\n)\n;\n\n11111\n\n\n\"aaaa\""
  },
  {
    "objectID": "page-julia-packages-DataFrames.html",
    "href": "page-julia-packages-DataFrames.html",
    "title": "mysite",
    "section": "",
    "text": "Juliaのパッケージ\nインストールするには、JuliaのREPLでusing Pkg; Pkg.add(\"DataFrames\")を実行してください。 使いたいタイミングでusing DataFramesと指定して読み込んでください。\n\nusing DataFrames\n\nなおデータフレームを使うパッケージとして、juliaにはPandasというパッケージもあります。\n\nDataFramesとは？\nデータフレームとは、主にPythonのpandasというライブラリで使われるデータの形式です。 特に機械学習で使われているイメージです。\nが、余り高速ではないので、本当に高い効率を必要とするなら、普通に行列を使ってください。\n表を模したデータ構造で、一般的に 行(row)方向にはデータの系列を説明する特徴量(feature)が並び、 列(column)方向には特徴を表現するデータ(index)が並びます。\n\n\n\nsepallength\nsepalwidth\npetallength\npetalwidth\nclass\n\n\n\n\n5.1\n3.5\n1.4\n0.2\nIris-setosa\n\n\n4.9\n3.0\n1.4\n0.2\nIris-setosa\n\n\n…\n…\n…\n…\n…\n\n\n\n仕様が頻繁に変更される場合があることは注意しておいてください。\n\n\nDataFrameコンストラクタ\n\n空のデータを生成する\nDataFrameはデータフレームを表す型で、コンストラクタにより以下のように生成できる。\n\ndf = DataFrame()\n\n\n0×0 DataFrame\n\n\n\n\n行列から生成する。\n特徴名feature_nameはStringでもSymbolでも大丈夫です。 この記事ではSymbolとします（SymbolはExprが包含する変数を表す型だと思ってください）。\n特徴名を自動生成したい場合、以下の第二引数を:autoにしてください。\n\nA = [\n  1 2.0 \"a\";\n  3 4.0 \"b\";\n  5 6.0 \"d\";\n  7 8.0 \"d\";\n  9 0.0 \"e\"\n]\nfeature_name = [:num_odd, :num_even, :alphabet]\ndf = DataFrame(A, feature_name)\n\n\n5×3 DataFrameRownum_oddnum_evenalphabetAnyAnyAny112.0a234.0b356.0d478.0d590.0e\n\n\n\n\n辞書から生成する。\n表記があれですが、上と似た結果になってるのが分かると思います。\n\nd = Dict(\n  :num_odd  => [1  , 3  , 5  , 7  , 9  ], \n  :num_even => [2.0, 4.0, 6.0, 8.0, 0.0], \n  :alphabet => [\"a\", \"b\", \"c\", \"d\", \"e\"]\n)\ndf = DataFrame(d)\n\n\n5×3 DataFrameRowalphabetnum_evennum_oddStringFloat64Int641a2.012b4.033c6.054d8.075e0.09\n\n\n\n\n直接生成する。\nDataFrameの内部の可変長引数の仕組みを使って直接生成することもできます。\n\ndf = DataFrame(\n  :num_odd  => [1  , 3  , 5  , 7  , 9  ], \n  :num_even => [2.0, 4.0, 6.0, 8.0, 0.0], \n  :alphabet => [\"a\", \"b\", \"c\", \"d\", \"e\"]\n)\n\n\n5×3 DataFrameRownum_oddnum_evenalphabetInt64Float64String112.0a234.0b356.0c478.0d590.0e\n\n\n以下、以下の乱数生成されたデータフレームを参考に記します。\n\nusing Random\nRandom.seed!(0)\ndf = DataFrame(\n  round.(rand(100, 10), digits=3), \n  :auto\n)\n;\n\n\n\n\nデータの参照\n\n最初のn行\n\ndf_first5 = first(df, 5)\ndf_first5\n\n\n5×10 DataFrameRowx1x2x3x4x5x6x7x8x9x10Float64Float64Float64Float64Float64Float64Float64Float64Float64Float6410.4550.7350.5550.8760.1070.2910.6940.8640.9190.40820.5480.9940.5210.5720.170.9430.3130.9910.0410.28230.7730.7040.470.9750.4350.3340.0790.1690.1050.87140.9410.1510.2070.5940.9280.9250.1480.4090.3470.94550.030.4090.2060.6590.370.0140.8350.1980.3210.864\n\n\n\n\n最後のn行\n\ndf_last5 = last(df, 5)\ndf_last5\n\n\n5×10 DataFrameRowx1x2x3x4x5x6x7x8x9x10Float64Float64Float64Float64Float64Float64Float64Float64Float64Float6410.3750.9240.4330.8920.8850.3880.8360.6980.880.32620.1830.7490.3130.8960.5740.9740.3340.3820.0260.50430.0390.9090.2220.8340.0310.4710.960.2930.3060.43640.8920.0430.7940.2950.1850.2880.6090.8540.5860.06250.4750.7760.3780.8030.1430.9060.5390.2280.8030.534\n\n\n\n\n行の取り出し\n\ndf_trim_rows = df[4:10, :]\ndf_trim_rows\n\n\n7×10 DataFrameRowx1x2x3x4x5x6x7x8x9x10Float64Float64Float64Float64Float64Float64Float64Float64Float64Float6410.9410.1510.2070.5940.9280.9250.1480.4090.3470.94520.030.4090.2060.6590.370.0140.8350.1980.3210.86430.7470.8650.520.650.8050.7770.420.6330.9790.74640.7470.6460.4490.890.7090.5660.9720.8430.3470.1650.9770.6930.7490.4190.440.2360.1590.9360.7620.86460.3290.2540.5960.2480.7980.7250.8550.8990.510.1570.6720.870.7680.9980.5810.8290.8130.7530.9910.013\n\n\n\n\n列の取り出し\n\n行数を指定\n\n\ndf_trim_columns = df[:, 3:6]\nfirst(df_trim_columns, 5)\n\n\n5×4 DataFrameRowx3x4x5x6Float64Float64Float64Float6410.5550.8760.1070.29120.5210.5720.170.94330.470.9750.4350.33440.2070.5940.9280.92550.2060.6590.370.014\n\n\n\n行名を指定\n\n\ndf_trim_columns = df[:, [:x2, :x5, :x7]]\nfirst(df_trim_columns, 5)\n\n\n5×3 DataFrameRowx2x5x7Float64Float64Float6410.7350.1070.69420.9940.170.31330.7040.4350.07940.1510.9280.14850.4090.370.835\n\n\n\n\n\nデータのフィルタリング（条件抽出）\n\nfilter関数を用いる方法\nフィルターをかけて、抽出できます。 フィルター関数はデータ（DataFrameの１行分）を受け取って、そのデータがtrueかfalseかを出力する関数です。\n\n\nf = x -> (x[:x1] >= 0.9)\ndf_above9 = filter(f, df)\ndf_above9\n\n\n14×10 DataFrameRowx1x2x3x4x5x6x7x8x9x10Float64Float64Float64Float64Float64Float64Float64Float64Float64Float6410.9410.1510.2070.5940.9280.9250.1480.4090.3470.94520.9770.6930.7490.4190.440.2360.1590.9360.7620.86430.9850.3560.7530.7310.1850.1820.6770.9390.3780.58240.9080.1090.9140.7650.6420.3380.230.2840.6070.49950.940.2240.3210.3240.0310.8250.1260.1230.3760.09860.9230.5190.4880.2420.2350.4860.9630.30.3180.05870.9080.840.0570.0080.5420.2010.6410.1950.0350.56880.9330.9210.0130.7690.1510.4290.3930.0110.2180.890.9970.5670.6970.4260.3870.5630.0540.4230.8580.393100.970.8040.4890.8150.510.6560.2050.7390.7550.206110.9940.5620.7550.4290.5690.190.3320.0450.7780.547120.9030.4460.0880.3840.0620.6610.8910.7320.5140.396130.9520.0860.1170.3920.0980.0030.3470.0510.4690.154140.9510.5270.450.2210.4260.020.7920.1650.8720.433\n\n\n\n条件演算を用いる方法\n\n条件演算子を使ってアクセスできます。 ちなみにこれは普通の行列の場合も同じように使えます。\n\ndf_bool = (df[:, :x1] .>= 0.9)\ndf_above9 = df[df_bool, :]\ndf_above9\n\n\n14×10 DataFrameRowx1x2x3x4x5x6x7x8x9x10Float64Float64Float64Float64Float64Float64Float64Float64Float64Float6410.9410.1510.2070.5940.9280.9250.1480.4090.3470.94520.9770.6930.7490.4190.440.2360.1590.9360.7620.86430.9850.3560.7530.7310.1850.1820.6770.9390.3780.58240.9080.1090.9140.7650.6420.3380.230.2840.6070.49950.940.2240.3210.3240.0310.8250.1260.1230.3760.09860.9230.5190.4880.2420.2350.4860.9630.30.3180.05870.9080.840.0570.0080.5420.2010.6410.1950.0350.56880.9330.9210.0130.7690.1510.4290.3930.0110.2180.890.9970.5670.6970.4260.3870.5630.0540.4230.8580.393100.970.8040.4890.8150.510.6560.2050.7390.7550.206110.9940.5620.7550.4290.5690.190.3320.0450.7780.547120.9030.4460.0880.3840.0620.6610.8910.7320.5140.396130.9520.0860.1170.3920.0980.0030.3470.0510.4690.154140.9510.5270.450.2210.4260.020.7920.1650.8720.433\n\n\n\n\nデータの追加と特徴の追加\n行方向にデータが、列方向に特徴があるのはもう説明しましたね。\nデータの追加は、push!かvcat関数を用いて行い、特徴の追加は、hcatを用いて行ってください。 ここでは、データの追加をpush!で、特徴の追加をhcatを使ってやる方法を示します。\n以下が元のデータフレームです。\n\ndf1 = DataFrame(rand(5, 3), :auto)\n\n\n5×3 DataFrameRowx1x2x3Float64Float64Float6410.1601430.7746660.62438420.5011360.7817320.056577430.01874370.555380.87188740.8601830.9130380.35537550.6556360.4097580.524008\n\n\npush!を使うと以下のように、元のデータフレームにデータが追加されました。\n\npush!(df1, rand(3))\ndf1\n\n\n6×3 DataFrameRowx1x2x3Float64Float64Float6410.1601430.7746660.62438420.5011360.7817320.056577430.01874370.555380.87188740.8601830.9130380.35537550.6556360.4097580.52400860.2799070.2152930.379568\n\n\n更に、以下のように特徴をデータフレームに追加します。\n\ndf2 = DataFrame(:a => rand(6))\ndf3 = hcat(df1, df2)\ndf3\n\n\n6×4 DataFrameRowx1x2x3aFloat64Float64Float64Float6410.1601430.7746660.6243840.57718120.5011360.7817320.05657740.28177830.01874370.555380.8718870.89097340.8601830.9130380.3553750.13129150.6556360.4097580.5240080.3021560.2799070.2152930.3795680.642936\n\n\n\n\nSQLライクな操作\nDataFramesの機能を用いてSQLっぽい操作ができます。\n\nselect\n\n# select x1, x4, x5 as a\ndf_select = select(df, :x1, :x4, :x5 => :a)\nfirst(df_select, 5)\n\n\n5×3 DataFrameRowx1x4aFloat64Float64Float6410.4550.8760.10720.5480.5720.1730.7730.9750.43540.9410.5940.92850.030.6590.37\n\n\n\n\nwhere\n\n# where x1 < 0.5 & x1 > 0.2\nf = x -> (0.2 < x[:x1] < 0.5)\ndf_filter = filter(f, df)\nfirst(df_filter, 5)\n\n\n5×10 DataFrameRowx1x2x3x4x5x6x7x8x9x10Float64Float64Float64Float64Float64Float64Float64Float64Float64Float6410.4550.7350.5550.8760.1070.2910.6940.8640.9190.40820.3290.2540.5960.2480.7980.7250.8550.8990.510.1530.230.4560.8670.1980.6940.0040.6860.990.0220.6740.470.3520.1580.9380.5370.9790.5280.9330.171.050.4150.6770.6880.0420.3260.1640.4470.5320.610.386\n\n\n\n\n他の関数\n他にもgroupby, join, sort, aggregateなどがあります。 でもあまり使わないと思います。"
  },
  {
    "objectID": "page-julia-crypto-2.html",
    "href": "page-julia-crypto-2.html",
    "title": "mysite",
    "section": "",
    "text": "暗号理論\n\n暗号アルゴリズム（計算機登場以前）\n\nシーザー暗号\nシーザー暗号は、古代ローマの将軍であるガイウス・ユリウス・カエサルが使用したとされる、非常にシンプルな代替暗号の一種です。 シーザー暗号は、アルファベットの文字を一定の数だけシフトさせて暗号化します。\n単位換字暗号\n単一換字暗号は、平文の各文字を別の文字に1対1で置き換える暗号化手法です。\nエニグマ\nエニグマは、第二次世界大戦中にドイツが使用した複雑な電子機械式暗号装置です。\n\n\n\nシーザー暗号\nシーザー暗号は、「鍵」を文字のシフト数 \\(n \\in K=\\{0,1,2,\\dots,2\\}\\) とする暗号です。 鍵空間 \\(K\\) の大きさはここでは \\(|K|=26\\) であり、ブルート・フォース・アタックでの突破が容易な暗号である。\n文字のシフトとは、例えば以下のように、表をもとに文字をずらす手法です。\n\n'あ' + 5\n\n'ぇ': Unicode U+3047 (category Lo: Letter, other)\n\n\nそれぞれの文字（アルファベット）を n_shift だけシフトさせるプログラムは以下の通りです。\n\nfunction char_shift(c, n_shift)\n    if !isletter(c)\n        return c\n    end\n    if !('a' <= lowercase(c) <= 'z')\n        return c\n    end\n    a = 'a'\n    if isuppercase(c)\n        a = 'A'\n    end\n    i = c - a\n    j = (i + n_shift) % 26\n    return a + j\nend\n\nchar_shift.(['a', 'X'], 3)\n\n2-element Vector{Char}:\n 'd': ASCII/Unicode U+0064 (category Ll: Letter, lowercase)\n 'A': ASCII/Unicode U+0041 (category Lu: Letter, uppercase)\n\n\nシーザー暗号の実装は以下の通りです。\n\nfunction encode_caesar(\n    plaintext::AbstractString, \n    n_shift::Integer # key\n)\n    l_plaintext  = collect(plaintext)\n    l_ciphertext = char_shift.(l_plaintext, n_shift)\n    ciphertext   = join(l_ciphertext)\n    return ciphertext\nend\n\nfunction decode_caesar(ciphertext, n_shift)\n    return encode_caesar(ciphertext, 26 - n_shift)\nend\n\n# key\nmykey = 3\n\n# encode\nplaintext  = \"hello world\"\nciphertext = encode_caesar(plaintext, mykey)\n\n# decode\nplaintext_ = decode_caesar(ciphertext, mykey)\n\nplaintext_\n\n\"hello world\"\n\n\n\n\n単一換字暗号\n単一換字暗号は、「鍵」を換字表 \\(\\text{Tbl} \\in K\\) とする暗号です。 鍵空間 \\(K\\) の大きさは \\(|K|=26!=403291461126605635584000000\\) であり、ブルート・フォース・アタックでの突破は困難ですが、頻度分析により比較的簡単に突破できます。\nそれぞれの文字（アルファベット）を Tbl に従って置換するプログラムは以下の通りです。\n\nfunction char_replace(c, tbl)\n    if !isletter(c)\n        return c\n    end\n    if !('a' <= lowercase(c) <= 'z')\n        return c\n    end\n    return tbl[c]\nend\n\nchar_replace (generic function with 1 method)\n\n\n単一換字暗号の暗号は以下の通りです。\n\nfunction encode_monoalphabetic(\n    plaintext::AbstractString, \n    key\n)\n    tbl = Dict(\n        zip(\n            collect(key[1]), collect(key[2])\n        )\n    )\n    l_plaintext  = collect(plaintext)\n    l_ciphertext = (c -> char_replace(c, tbl)).(l_plaintext)\n    ciphertext   = join(l_ciphertext)\n    return ciphertext\nend\n\nfunction decode_monoalphabetic(ciphertext, key)\n    key = (key[2], key[1])\n    return encode_monoalphabetic(ciphertext, key)\nend\n\n# key\nmykey = (\n    collect(\"abcdefghijklmnopqrstuvwxyz\"), \n    collect(\"gpkhayvwcoxzqntudeflmijbrs\")\n)\n\n# encode\nplaintext  = \"hello world\"\nciphertext = encode_monoalphabetic(plaintext, mykey)\n\n# decode\nplaintext_ = decode_monoalphabetic(ciphertext, mykey)\n\nplaintext_\n\n\"hello world\"\n\n\n\n\nエニグマ\nエニグマ（Enigma）は、第二次世界大戦中にドイツで使用された暗号化機械です。 当時は非常に高度な暗号化手法であるとされ、暗号文の解読が非常に困難であると考えられていました。\n機械式の代替暗号装置であり、電気信号を用いて文字を暗号化した暗号です。\nエニグマは、複数の可変ローター（回転ディスク）とプラグボード（Steckerboard）と呼ばれる接続装置から構成されており、これによって文字の置換と交換が行われました。 暗号学の歴史上、重要な節目となる装置であり、暗号解読の研究や教育においても広く取り上げられています。 平文の文字を入力すると、可変ローターの回転と接続装置の置換によって暗号文の文字が出力されます。\nエニグマは KEK(key encrypting key)と言われる、鍵を暗号化するための日替わり鍵を導入したことでも知られています。 そのため、同じ文字が連続して入力されても、異なる文字が出力されるため、エニグマは多重換字暗号として知られる複雑な暗号方式でした。\n※実装は省略します。\n\n\n\n\ngraph LR\n    A[平文] --> B((暗号化))\n    D --> E[暗号化通信鍵と暗号文]\n    F[通信鍵] -.-> B\n    B --> C[暗号文]\n    F --> H((暗号化))\n    I[KEK] -.-> H\n    subgraph LR\n        B\n        C --> D((結合))\n        G[暗号化通信鍵] --> D\n        H --> G\n    end\n\n\n\n\n\n\n\n\n\n\n解読アルゴリズム\n\nブルート・フォース・アタック\nブルート・フォース・アタックは、全ての可能な組み合わせを試行することで、暗号を解読する攻撃手法です。\n頻度分析\n頻度分析は、暗号文の中の文字や記号の出現頻度を解析し、元の平文を特定する手法です。\n\n\n\nブルート・フォース・アタック\nencode_caesarによる暗号は鍵空間が小さいので、ブルート・フォース・アタックで簡単に解読できる。\n以下のシーザー暗号によって暗号化された暗号文を解読することを考える。\n\nciphertext = \"twzgpozrd\"\n\n\"twzgpozrd\"\n\n\n復号化のアルゴリズムは知っているため、decode_caesarを使うことができるものと考え、鍵を\n\nkeys        = collect(0:25)\ndecodetexts = (key -> decode_caesar(ciphertext, key)).(keys)\noutputs     = collect(zip(keys, decodetexts))\n\n26-element Vector{Tuple{Int64, String}}:\n (0, \"twzgpozrd\")\n (1, \"svyfonyqc\")\n (2, \"ruxenmxpb\")\n (3, \"qtwdmlwoa\")\n (4, \"psvclkvnz\")\n (5, \"orubkjumy\")\n (6, \"nqtajitlx\")\n (7, \"mpszihskw\")\n (8, \"loryhgrjv\")\n (9, \"knqxgfqiu\")\n (10, \"jmpwfepht\")\n (11, \"ilovedogs\")\n (12, \"hknudcnfr\")\n (13, \"gjmtcbmeq\")\n (14, \"filsbaldp\")\n (15, \"ehkrazkco\")\n (16, \"dgjqzyjbn\")\n (17, \"cfipyxiam\")\n (18, \"behoxwhzl\")\n (19, \"adgnwvgyk\")\n (20, \"zcfmvufxj\")\n (21, \"ybelutewi\")\n (22, \"xadktsdvh\")\n (23, \"wzcjsrcug\")\n (24, \"vybirqbtf\")\n (25, \"uxahqpase\")\n\n\nこの中で、意味の通る文章は\"ilovedogs\"だけです。 鍵は11なので、次も同じ鍵を使ってた場合、内容がバレバレになってしまいます。\n犬が好きらしいですね。\n\n\n頻度分析\nencode_monoalphabeticによる暗号は鍵空間は少々大きいので、ブルート・フォース・アタックで解読するのは難しそうです。なので、頻度分析と言う手法を使います。\n以下の単一換字暗号によって暗号化された暗号文を解読することを考える。\n\nciphertext = \"cnkerultveguwrgkcuwaetekruwaecfgngzvteclwqyteuaeyteqcnvankerulctntehakerulctngfaecaftyjazzhaycnahflauflwglkgnpaytzztjahgfguetkahmeagngzlaenglciazaffktqqtnlaeqcfankcuwaeqanlltankcuwaeteankthacfltktniaelcnyteqglctncnltkcuwaetekthacnktqqtnugezgnkakcuwaecffrntnrqtmfjclwkthagflwargeaptlwgfaltyflauflwglankerulgqaffgvawtjaiaelwaktnkaulfgeahcflcnklcnkerultveguwrafuakcgzzrkzgffckgzkerultveguwr\"\n\n\"cnkerultveguwrgkcuwaetekruwaecfgngzvteclwqyteuaeyteqcnvankerulctntehakerulctngfaecaftyjazzhaycnahflauflwglkgnpaytzztjahgfguetkahmeagngzlaenglciazaffktqqtnlaeqcfankcuwaeqanlltankcuwaeteankthacfltktniaelcnyteqglctncnltkcuwaetekthacnktqqtnugezgnkakcuwaecffrntnrqtmfjclwkthagflwargeaptlwgfaltyflauflwglankerulgqaffgvawtjaiaelwaktnkaulfgeahcflcnklcnkerultveguwrafuakcgzzrkzgffckgzkerultveguwr\"\n\n\n古典的な頻度分析の手法として、以下のようなアイデアがある。文字列の中に頻出する文字（文字列）を推定できる可能性がある。ただし、これらのアイデアは偏りのない巨大な文章に対しては意味があるが、そうでなければ上手くいかない。\n\n出現するアルファベットの頻度\n多い順に、e, t, a, o, i, n, …, j, x, q, z\n出現する２文字のアルファベット文字列の頻度\n多い順に、th, he, in, er, …\n出現する３文字のアルファベット文字列の頻度\nthe, and, ing, ion,\n参考\n\nこれらのアイデアを利用するために、以下のようにパターンを解析するプログラムを実装した。\n\nfunction pattern_frequency_analysis(\n    text::AbstractString, n::Integer\n)\n    pattern_counts = Dict() # Dict{SubString, Int64}()\n    for i in 1:length(text)- n + 1\n        pattern = text[i:i+n-1]\n        if haskey(pattern_counts, pattern)\n            pattern_counts[pattern] += 1\n        else\n            pattern_counts[pattern] = 1\n        end\n    end\n    result = sort(collect(pattern_counts), by = x -> x[2], rev=true)\n    return result\nend\n\nfunction frequency_analysis(ciphertext, N)\n    for n = 1:N\n        result = pattern_frequency_analysis(ciphertext, n)\n        display(result[1:8])\n    end\nend\n\nfrequency_analysis(ciphertext, 3)\n\n\n\n8-element Vector{Pair{Any, Any}}:\n \"a\" => 46\n \"t\" => 35\n \"e\" => 34\n \"l\" => 30\n \"n\" => 28\n \"c\" => 27\n \"g\" => 27\n \"k\" => 27\n\n\n8-element Vector{Pair{Any, Any}}:\n \"ae\" => 12\n \"nk\" => 11\n \"uw\" => 9\n \"wa\" => 8\n \"tn\" => 8\n \"te\" => 8\n \"cn\" => 8\n \"ul\" => 7\n\n\n8-element Vector{Pair{Any, Any}}:\n \"ker\" => 6\n \"wae\" => 6\n \"eru\" => 6\n \"rul\" => 6\n \"uwa\" => 6\n \"cuw\" => 5\n \"kcu\" => 5\n \"ank\" => 5\n\n\n\n\nここで、aの頻度が多いことから、aをeだと考えて置換する。\n\nciphertext = replace(ciphertext, 'a' => 'e', 'e' => 'a')\nfrequency_analysis(ciphertext, 3)\n\n\n\n8-element Vector{Pair{Any, Any}}:\n \"e\" => 46\n \"t\" => 35\n \"a\" => 34\n \"l\" => 30\n \"n\" => 28\n \"c\" => 27\n \"g\" => 27\n \"k\" => 27\n\n\n8-element Vector{Pair{Any, Any}}:\n \"ea\" => 12\n \"nk\" => 11\n \"uw\" => 9\n \"we\" => 8\n \"tn\" => 8\n \"cn\" => 8\n \"ta\" => 8\n \"ul\" => 7\n\n\n8-element Vector{Pair{Any, Any}}:\n \"wea\" => 6\n \"aru\" => 6\n \"uwe\" => 6\n \"rul\" => 6\n \"kar\" => 6\n \"enk\" => 5\n \"cuw\" => 5\n \"kcu\" => 5\n\n\n\n\nここで、eaはerとすることにする。\n\nciphertext = replace(ciphertext, 'a' => 'r', 'r' => 'a')\nfrequency_analysis(ciphertext, 3)\n\n\n\n8-element Vector{Pair{Any, Any}}:\n \"e\" => 46\n \"t\" => 35\n \"r\" => 34\n \"l\" => 30\n \"n\" => 28\n \"c\" => 27\n \"g\" => 27\n \"k\" => 27\n\n\n8-element Vector{Pair{Any, Any}}:\n \"er\" => 12\n \"nk\" => 11\n \"uw\" => 9\n \"we\" => 8\n \"tn\" => 8\n \"cn\" => 8\n \"tr\" => 8\n \"ul\" => 7\n\n\n8-element Vector{Pair{Any, Any}}:\n \"aul\" => 6\n \"uwe\" => 6\n \"rau\" => 6\n \"wer\" => 6\n \"kra\" => 6\n \"enk\" => 5\n \"cuw\" => 5\n \"kcu\" => 5\n\n\n\n\nこのように、頻度表を用いて試行錯誤していくことで少ない時間で解ける……場合がある。\n# 元の文章\nincryptographyacipherorcypherisanalgorithmforperformingencryptionordecryption—aseriesofwelldefinedstepsthatcanbefollowedasaprocedureanalternativelesscommontermisenciphermenttoencipherorencodeistoconvertinformationintocipherorcodeincommonparlancecipherissynonymouswithcodeastheyarebothasetofstepsthatencryptamessagehowevertheconceptsaredistinctincryptographyespeciallyclassicalcryptography\n引用した文章"
  },
  {
    "objectID": "page-julia-numericalanalysis-LU.html",
    "href": "page-julia-numericalanalysis-LU.html",
    "title": "mysite",
    "section": "",
    "text": "数値解析の基礎\n\nLU分解\nLU分解（LU decomposition）は、正方行列 \\(A\\) を下三角行列（Lower triangular matrix） \\(L\\) と上三角行列（Upper triangular matrix） \\(U\\) の積に分解することです。\nLU分解は数値解析や線形代数の応用分野で広く使われています。\n以下のように、\\(L\\) の対角成分を \\(1\\) とすることが多いです。\n\\[\nA = LU\n  =\n\\begin{bmatrix}\n  1      & 0      & 0      & \\dots  \\\\\n  l_{21} & 1      & 0      & \\dots  \\\\\n  l_{31} & l_{32} & 1      & \\dots  \\\\\n  \\vdots & \\vdots & \\vdots & \\vdots  \n\\end{bmatrix}\n\\begin{bmatrix}\n  u_{11} & u_{12} & u_{13} & \\dots  \\\\\n  0      & u_{22} & u_{23} & \\dots  \\\\\n  0      & 0      & u_{33} & \\dots  \\\\\n  \\vdots & \\vdots & \\vdots & \\vdots\n\\end{bmatrix}\n\\]\nまた、LU分解により生じる行列は、零要素や \\(L\\) の1になる対角成分が含まれ、メモリに格納する際に無駄になることから、プログラム上では以下のような因子として保存されているものと考えてください。\n\\[\nF_\\text{lu} =\n\\begin{bmatrix}\n  u_{11} & u_{12} & u_{13} & \\dots  \\\\\n  l_{21} & u_{22} & u_{23} & \\dots  \\\\\n  l_{31} & l_{32} & u_{33} & \\dots  \\\\\n  \\vdots & \\vdots & \\vdots & \\vdots\n\\end{bmatrix}\n\\]\nなお、この説明では行列が適当に使いやすい行列であるものと仮定してます（一部の要素が０の場合、ピボッティングをしない場合は上手くいかないケースがあるので……）。\n\n\nJuliaのLU分解\nJuliaではLinearAlgebraパッケージにluという関数が用意されています。 以下のように使用できます。\n一見、格納されている行列に無駄があるように見えますが、実際に格納されているのはF.factorsなので大丈夫です。\n\nusing LinearAlgebra\n\nA = rand(5, 5)\nF = lu(A)\nA[F.p, :] - F.L * F.U\n\n5×5 Matrix{Float64}:\n 0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0\n\n\n\n\nガウスの消去法（ドゥーリトル法）\n\nガウスの消去法\nまず、\\(A\\) を以下のようにベクトルとして考えて、\\(L_1, U_1, A_1\\) を以下のように設定してください。\n\\[\nU_1 = A_1 = A = \\begin{bmatrix} a_1^\\mathrm{T} \\\\ a_2^\\mathrm{T} \\\\ \\vdots \\\\ a_n^\\mathrm{T} \\end{bmatrix}\n, \\;\\;\\;\nL_1 = I\n\\]\nガウスの消去法による列の消去は以下の方法で行います（\\(a_i\\) の１つ目の要素を消したいというモチベーションが働いています）。\n\\[\nu_i \\gets a_i - \\frac{a_{i1}}{a_{11}} a_1, \\;\\;\\; i=2, 3, \\dots, n\n\\]\nこれを行列化すると、以下の通りです。\n\\[\nU_2\n=\n\\begin{bmatrix} a_1^\\mathrm{T} \\\\ a_2^\\mathrm{T} - \\frac{a_{21}}{a_{11}} a_1^\\mathrm{T} \\\\ \\vdots \\\\ a_n^\\mathrm{T} - \\frac{a_{n1}}{a_{11}} a_1^\\mathrm{T} \\end{bmatrix}\n=\n\\begin{bmatrix}\n    1                       & 0     & 0     & \\dots & 0 \\\\\n    - \\frac{a_{21}}{a_{11}} & 1     & 0     & \\dots & 0 \\\\\n    - \\frac{a_{31}}{a_{11}} & 0     & 1     & \\dots & 0 \\\\\n    \\vdots                  & \\vdots& \\vdots& \\dots & 0 \\\\\n    - \\frac{a_{n1}}{a_{11}} & 0     & 0     & \\dots & 1\n\\end{bmatrix}\n\\begin{bmatrix} a_1^\\mathrm{T} \\\\ a_2^\\mathrm{T} \\\\ \\vdots \\\\ a_n^\\mathrm{T} \\end{bmatrix}\n=\nL_2 A\n\\]\nここで、出来上がった行列 \\(U_2\\) は１列目の第１要素以外の全てが0になっています。 即ち、以下のような行列になっています。 ここの \\(A_2\\) という行列は、\\(U_2\\) の小行列です。\n\\[\nU_2 =\n\\begin{bmatrix}\n  a_{11} & \\begin{bmatrix}a_{12} & \\dots & a_{1n} \\end{bmatrix}\\\\\n  \\begin{bmatrix} 0\\\\ \\vdots \\\\0 \\end{bmatrix}       & A_2\n\\end{bmatrix}\n\\]\nこの行列 \\(A_2\\) に対して、同じことをやっていけば、最終的には以下のような行列になるって寸法です。\n\\[\nL^{-1} A = (L_n \\dots L_3 L_2)^{-1} A = U_n = U\n\\]\nLの逆行列は単に符号を逆にしていけばいいだけなので、恐れるに足りません。即座に以下の行列が得られます。\n\\[\nA = LU\n\\]\n\n\nガウスの消去法のコード\nまず、小行列 \\(A_k\\) に対して１行目に対する処理を行う関数は以下の通りです。\n\n\"\"\"\n行列 Amin から L, U の要素を生成する関数です。\n\"\"\"\nfunction gausselim!(L, U, Amin, idx)\n    # 小行列のビューの作成（破壊的操作を可能とする）\n    Lmin, Umin = view(L, idx, idx), view(U, idx, idx)\n    # 小行列に対する消去法による列の変形\n    jdx = 2:length(idx)\n    Lmin[jdx, 1] = Amin[jdx, 1] / Amin[1, 1]\n    for i = jdx\n        Umin[i, jdx] = Umin[i, jdx] - Lmin[i, 1] * Umin[1, jdx]\n    end\n    Umin[jdx, 1] .= 0\nend\n\nA    = rand(3, 3)\nL, U = diagm(ones(3)), copy(A)\n\ngausselim!(L, U, A, 1:3)\ndisplay.(\n    [L, U, L*U - A]\n)\n;\n\n\n\n3×3 Matrix{Float64}:\n 1.0       0.0  0.0\n 1.2901    1.0  0.0\n 0.935978  0.0  1.0\n\n\n3×3 Matrix{Float64}:\n 0.336371  0.297635   0.741915\n 0.0       0.491222  -0.237071\n 0.0       0.415236  -0.226011\n\n\n3×3 Matrix{Float64}:\n 0.0          0.0  0.0\n 5.55112e-17  0.0  0.0\n 0.0          0.0  0.0\n\n\n\n\n次に、LU分解を行う関数は以下の通りです。\n\nfunction lu_Doolittle(A)\n    n = size(A, 1)\n    L, U = diagm(ones(n)), copy(A)\n    for k = 1:n # n-1まででも同じです。\n        idx  = k:n\n        Amin = U[idx, idx]\n        gausselim!(L, U, Amin, idx)\n    end\n    return L, U\nend\n\nA    = rand(5, 5)\nL, U = lu_Doolittle(A)\nA - L * U\n\n5×5 Matrix{Float64}:\n 0.0           0.0           0.0           0.0           0.0\n 1.11022e-16   0.0           0.0           0.0           0.0\n 0.0          -1.11022e-16   0.0           0.0           0.0\n 0.0           0.0           0.0          -5.55112e-17  -2.22045e-16\n 0.0           0.0          -2.77556e-17   5.55112e-17   1.11022e-16\n\n\n\n\n\nクラウトの方法\n以下のように上三角行列の対角要素を1とします。\n\\[\nA = LU\n  =\n\\begin{bmatrix}\n  l_{11} & 0      & 0      & \\dots  \\\\\n  l_{21} & l_{22} & 0      & \\dots  \\\\\n  l_{31} & l_{32} & l_{33} & \\dots  \\\\\n  \\vdots & \\vdots & \\vdots & \\vdots  \n\\end{bmatrix}\n\\begin{bmatrix}\n  1      & u_{12} & u_{13} & \\dots  \\\\\n  0      & 1      & u_{23} & \\dots  \\\\\n  0      & 0      & 1      & \\dots  \\\\\n  \\vdots & \\vdots & \\vdots & \\vdots\n\\end{bmatrix}\n\\]\n上記の等式を書き直すと、以下のようになります。\n\\[\nA\n=\n\\begin{bmatrix}\n  l_1^\\mathrm{T} \\\\ l_2^\\mathrm{T} \\\\ \\vdots \\\\ l_n^\\mathrm{T}\n\\end{bmatrix}\n\\begin{bmatrix}\n  u_1 & u_2 & \\dots & u_n\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n  l_1^\\mathrm{T} u_1 & l_1^\\mathrm{T} u_2 & \\dots & l_1^\\mathrm{T} u_n \\\\\n  l_2^\\mathrm{T} u_1 & l_2^\\mathrm{T} u_2 & \\dots & l_2^\\mathrm{T} u_n \\\\\n  \\vdots             & \\vdots             & \\dots & \\vdots             \\\\\n  l_n^\\mathrm{T} u_1 & l_n^\\mathrm{T} u_2 & \\dots & l_n^\\mathrm{T} u_n\n\\end{bmatrix}\n\\] \\[\nl_k =\n\\begin{bmatrix}\n  l_{k1} & \\dots & l_{kk} & 0 & \\dots & 0\n\\end{bmatrix}\n^\\mathrm{T}\n\\] \\[\nu_k =\n\\begin{bmatrix}\n  u_{k1} & \\dots & u_{kk} & 0 & \\dots & 0\n\\end{bmatrix}\n^\\mathrm{T}\n\\]\nすなわち、以下が成り立ちます。\n\\[\na_{ij} = l_{i}^\\mathrm{T} u_j = \\sum_{k=1}^{\\min(i, j)} l_{ik} u_{kj}\n\\]\nこれを、\\(l_{ij}\\) と \\(u_{ij}\\) について解くと以下の式が得られます。\n\\[\n\\left\\{\n\\begin{matrix}\nl_{ij} = a_{ij} - \\sum_{k=1}^{j-1} l_{ik} u_{kj} & (i \\ge j)\\\\\nu_{ij} = \\left( a_{ij} - \\sum_{k=1}^{j-1} l_{ik} u_{kj} \\right) / l_{ii} & (i<j, \\;\\; l_{ii} \\neq 0)\n\\end{matrix}\n\\right.\n\\]\n以下が、クラウト法のプログラムとなります。 loop1, loop2とloop1', loop2'はそれぞれループを交換できます。\n\nfunction lu_Crout(A)\n    n = size(A, 1)\n    L = zeros(n, n)\n    U = zeros(n, n)\n    for k = 1:n\n        # lij\n        for i = k:n # loop1\n            if k == 1\n                s = 0.0\n            else\n                s = sum(L[i, j] * U[j, k] for j = 1:k-1) # loop2\n            end\n            L[i,k] = A[i,k] - s\n        end\n        # uij\n        for j = k+1:n # loop1'\n            if k == 1\n                s = 0.0\n            else\n                s = sum(L[k,i] * U[i,j] for i = 1:k-1) # loop2'\n            end\n            U[k,j] = (A[k,j] - s) / L[k,k]\n        end\n    end\n    U = U + diagm(ones(n))\n    return L, U\nend\n\n\nA = rand(5, 5)\nL, U = lu_Clout(A)\n\nA - L * U\n\n5×5 Matrix{Float64}:\n 0.0  0.0  0.0  0.0   0.0\n 0.0  0.0  0.0  0.0  -1.11022e-16\n 0.0  0.0  0.0  0.0   0.0\n 0.0  0.0  0.0  0.0   2.08167e-17\n 0.0  0.0  0.0  0.0  -1.11022e-16"
  },
  {
    "objectID": "page-julia-complexanalysis-useful.html",
    "href": "page-julia-complexanalysis-useful.html",
    "title": "mysite",
    "section": "",
    "text": "複素解析\n\n複素数の便利さ\nあ、この記事は数学の振りした物理とかそっち系の記事だと思ってください。 厳密さが要求される場合、複素数の世界での準備はかなり大変なので、やりません。\n\n\n三角関数と指数関数\n複素数の世界だと、指数関数は三角関数と同じです。\nこのことが、途轍もなく複素数を便利なものだと実感させてくれます。\nまずは、以下の重要な公式（オイラーの公式）があります。 この公式は要は、２次元の実平面 \\(\\mathbb{R}^{2}\\) で単位円上の点の座標を \\(\\begin{bmatrix}\\cos \\theta \\\\ \\sin \\theta \\end{bmatrix}\\) とするのと同じようにして、複素平面上ではこのように表せるよ……って式なのです。\nちなみに、\\(i\\) は虚数単位です。お忘れなく。\n\\[\ne^{i \\theta} = \\cos \\theta + i \\sin \\theta\n\\]\nこれを覚えておけば（当然、指数の知識は要りますが）、面倒くさいサインコサインの公式、微分の公式、積分の公式、全部一瞬で導出できるようになります。\n\n微分\n三角関数の微分は、指数関数の微分から求められます。 幾何学的解釈として、位相を90度ずらすのが微分だと言うこともできます。\n\\[\n\\frac{d}{d \\theta} e^{i \\theta} = i e^{i \\theta} = i (\\cos \\theta + i \\sin \\theta)\n=  - \\sin \\theta + i \\cos \\theta\n\\]\n変形すると、以下のようになります。\n\\[\n\\frac{d}{d \\theta} \\cos \\theta + i \\frac{d}{d \\theta} \\sin \\theta\n=\n- \\sin \\theta + i \\cos \\theta\n\\]\n係数比較すると、以下のようになります。 \\[\n\\frac{d}{d \\theta} \\cos \\theta = - \\sin \\theta, \\;\\;\\;\n\\frac{d}{d \\theta} \\sin \\theta = \\cos \\theta\n\\]\n\n\n積分\n積分はその逆です。\n\\[\n\\int e^{i \\theta} d \\theta= \\frac{1}{i} e^{i \\theta} = - i e^{i \\theta} = - i (\\cos \\theta + i \\sin \\theta)\n=  \\sin \\theta - i \\cos \\theta\n\\]\n変形すると、以下のようになります。\n\\[\n\\int \\cos \\theta d \\theta  + i \\int \\sin \\theta d \\theta\n=\n\\sin \\theta - i \\cos \\theta\n\\]\n比較すると、以下のようになります。 \\[\n\\int \\cos \\theta d \\theta = \\sin \\theta, \\;\\;\\;\n\\int \\sin \\theta d \\theta = -\\cos \\theta\n\\]\n\n\n加法定理\n\\[\ne^{i (\\theta + \\phi)}  = \\cos (\\theta+\\phi) + i \\sin (\\theta + \\phi)\n\\]\n\\[\ne^{i (\\theta + \\phi)} = e^{i \\theta} e^{i \\phi} =\n(\\cos \\theta + i \\sin \\theta)(\\cos \\phi + i \\sin \\phi)\n= (\\cos \\theta \\cos \\phi - \\sin \\theta \\sin \\phi) +\ni (\\cos \\theta \\sin \\phi + \\sin \\theta \\cos \\phi)\n\\]\n比較すると、以下のようになります。 \\[\n\\cos (\\theta+\\phi) = \\cos \\theta \\cos \\phi - \\sin \\theta \\sin \\phi, \\;\\;\\;\n\\sin (\\theta + \\phi) = \\cos \\theta \\sin \\phi + \\sin \\theta \\cos \\phi\n\\]\n\n\n三角関数の性質の式\n三角関数の周期について、ちゃんと覚えてないと、\\(\\frac{\\pi}{2}\\) だけ位相をずらすとどうなるっけ？……的な疑問が出てくることがあります。\n複素数の式を使えば、すぐに導出できます。\n\\[\ne^{i (\\theta + \\frac{\\pi}{2})} = e^{i \\frac{\\pi}{2}} e^{i \\theta} = i e^{i \\theta} = - \\sin \\theta + i \\cos \\theta\n\\]\nよって、比較すると以下のようになります。\n\\[\n\\cos (\\theta + \\frac{\\pi}{2}) = - \\sin \\theta, \\;\\;\\;\n\\sin (\\theta + \\frac{\\pi}{2}) = \\cos \\theta\n\\]\nここで、\\(i = e^{i\\frac{\\pi}{2}}\\) を使っていますが、これは、複素平面上で、\\(\\frac{\\pi}{2}\\) 角度を曲げると \\(i\\) になるというだけの式です。\n他の角度も以下のように、複素数で書けます。\n\\(e^{i \\frac{\\pi}{2}}=i\\), \\(e^{i \\frac{\\pi}{3}}=\\frac{1 + \\sqrt{3}i}{2}\\), \\(e^{i \\frac{\\pi}{4}}=\\frac{1+i}{\\sqrt{2}}\\) など……。"
  },
  {
    "objectID": "page-julia-numericalanalysis-Cholesky.html",
    "href": "page-julia-numericalanalysis-Cholesky.html",
    "title": "mysite",
    "section": "",
    "text": "数値解析の基礎\n\nCholesky分解\nコレスキー分解とは、正定値エルミート行列 \\(A\\) を下三角行列 \\(L\\) を用いて以下のような分解形式で表すことである。 この分解の手法は、ガウスの消去法の自然な拡張とも言える。\n\n\n具体的な手法\n\\[\nA_1 = A\n\\]\nここで、以下のように各変数を定める。\n\\[\nA_1\n=\n\\begin{bmatrix}\n  a_{11} & \\begin{bmatrix} a_{12} & \\dots & a_{1n} \\end{bmatrix} \\\\\n  \\begin{bmatrix} a_{12} \\\\ \\vdots \\\\ a_{1n} \\end{bmatrix} & *\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n  a_{11} & c_1^* \\\\\n  c_1 & B_1\n\\end{bmatrix}\n\\]\nこの行列を \\(a_{11} \\gets 1\\) （\\(a_{11}\\) の場所が1になるようにしたい）かつ、\\(c_1=1\\)（列要素をガウスの消去法的に削除したい） にしたい。 そのため、以下のように変形する。\n\\[\n\\begin{bmatrix}\n  a_{11} & c_1^* \\\\\n  c_1 & B_1\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n  \\sqrt{a_{11}} & 0 \\\\\n  \\frac{1}{\\sqrt{a_{11}}} c_1 & I\n\\end{bmatrix}\n\\begin{bmatrix}\n  \\sqrt{a_{11}} & \\frac{1}{\\sqrt{a_{11}}} c_1^* \\\\\n  0 & B_1 - \\frac{1}{a_{11}} c_1 c_1^*\n\\end{bmatrix}\n\\]\n\\[\n\\begin{bmatrix}\n  a_{11} & c_1^* \\\\\n  c_1 & B_1\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n  \\sqrt{a_{11}} & 0^* \\\\\n  \\frac{1}{\\sqrt{a_{11}}} c_1 & I\n\\end{bmatrix}\n\\begin{bmatrix}\n  1 & 0^* \\\\\n  0 & B_1 - \\frac{1}{a_{11}} c_1 c_1^*\n\\end{bmatrix}\n\\begin{bmatrix}\n  \\sqrt{a_{11}} & \\frac{1}{\\sqrt{a_{11}}} c_1^* \\\\\n   0 & I\n\\end{bmatrix}\n\\]\nまとめると、\\(A_1\\) は以下のようになる。 \\[\nA_1 =\nL_1\n\\begin{bmatrix}  \n  1 & 0^* \\\\\n  0 & A_2\n\\end{bmatrix}\nL_1^*\n, \\;\\;\\;\nL_1 =\n\\begin{bmatrix}\n  \\sqrt{a_{11}} & 0^* \\\\\n  \\frac{1}{\\sqrt{a_{11}}} c_1 & I\n\\end{bmatrix}\n, \\;\\;\\;\nA_2 = B_1 - \\frac{1}{a_{11}} c_1 c_1^*\n\\]\nこの行列 \\(A_2\\) に対して、同じことをやっていけば、最終的には以下のような行列になります。 \\[\nA = (L_n \\dots L_2 L_1) (L_1^* L_2^* \\dots L_n^*)\n\\]\nよって、以下の式が求められました。\n\\[\nA = L L^*\n\\]\n\n\n実装\n消去法の実装は以下の通りです。\n\nusing LinearAlgebra\n\nfunction cholelim!(LL, AA, idx)\n  n = size(AA, 1)\n  jdx = 2:size(idx, 1)\n  L, A = view(LL, idx, idx), view(AA, idx, idx)\n\n  # 行列Lの要素を作成\n  L[1, 1] = √(A[1, 1])\n  L[jdx, 1] = A[jdx, 1] / √(A[1, 1])\n  for j = jdx\n    L[j, j] = 1\n  end\n  # 行列Aの要素を作成\n  A[jdx, jdx] = A[jdx, jdx] - A[jdx, 1] * A[jdx, 1]' / A[1, 1]\n  A[jdx, 1] .= 0; A[1, jdx] .= 0\n  A[1, 1] = 1\nend\n\nA = (x -> tril(x, -1) + triu(x))(rand(5, 5))\nL = zeros(size(A))\nA_orig = copy(A)\ncholelim!(L, A, 1:5)\n\ndisplay.([L, A]);\n\n5×5 Matrix{Float64}:\n 0.896486   0.0  0.0  0.0  0.0\n 0.832987   1.0  0.0  0.0  0.0\n 0.494651   0.0  1.0  0.0  0.0\n 0.0813545  0.0  0.0  1.0  0.0\n 0.0992239  0.0  0.0  0.0  1.0\n\n\n5×5 Matrix{Float64}:\n 1.0   0.0         0.0       0.0       0.0\n 0.0   0.175474   -0.168414  0.423201  0.600195\n 0.0  -0.0333654  -0.17168   0.841061  0.634558\n 0.0   0.45925     0.014949  0.831753  0.0624153\n 0.0   0.560973    0.313459  0.522894  0.271689\n\n\nコレスキー分解の実装は以下の通りです。\n\nfunction colesky_func(A)\n  n = size(A, 1)\n  AA = copy(A)\n  L  = zeros(n, n)\n  for i = 1:n-1\n    idx = i:n\n    if size(idx, 1) <= 1 \n      continue\n    end\n    cholelim!(L, AA, idx)\n  end\n  return L\nend\n\nA = (x -> tril(x) * tril(x)')(rand(5,5))\nL = colesky_func(A)\n\nA - L * L'\n\n5×5 Matrix{Float64}:\n 0.0  0.0   0.0           0.0           0.0\n 0.0  0.0   0.0           0.0           0.0\n 0.0  0.0   0.0          -5.55112e-17   0.0\n 0.0  0.0  -5.55112e-17  -2.22045e-16   0.0\n 0.0  0.0   0.0           0.0          -0.728"
  }
]